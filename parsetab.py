
# parsetab.py
# This file is automatically generated. Do not edit.
# pylint: disable=W,C,R
_tabversion = '3.10'

_lr_method = 'LALR'

_lr_signature = 'AMPERSAND AND ARROW_FUNCTION_TYPE ARROW_SEND_RECEIVE AS ASSERT BITWISE_AND_EQ BITWISE_OR_EQ BITWISE_XOR BITWISE_XOR_ASSIGN BITWISE_XOR_EQ BOOLEAN BOOLEAN_DATA_TYPE BREAK CLASS COLON COMMA COMMENT COMMENT_MULTI CONST CONTINUE DEF DEL DIVIDE DIVIDE_EQ DOT ELIF ELLIPSIS ELSE ENTERE_DIVIDE EQUAL EQUALEQUAL EXCEPT FALSE FAT_ARROW FINALLY FLOAT32 FLOAT32_DATA_TYPE FLOAT64 FLOAT64_DATA_TYPE FOR FROM GLOBAL GREATER GREATER_EQUAL GREATER_THAN HEX_NUMBER IDENTIFIER IF IMPORT IN INTEGER INTEGER_DATA_TYPE IS LAMBDA LBRACKET LEFT_SHIFT_EQ LESS LESS_EQUAL LESS_THAN LKEY LOGICAL_AND LOGICAL_NOT LOGICAL_OR LPAREN MINUS MINUS_EQ MODULE MODULO_EQ NONE NONLOCAL NOT NOT_EQUAL NULL OR PASS PIPE PLUS PLUS_EQ PRINTF PRINTF PRINTLN PRINTLN RAISE RBRACKET RETURN RIGHT_SHIFT_EQ RKEY RPAREN SCIENTIFIC_NOTATION SHORT_VAR_DECL STRING STRING_DATA_TYPE TIMES TIMES_EQ TMF_LIBRARY TMF_LIBRARY TRUE TRY VAR WHILE WITH YIELDprint : TMF_LIBRARY DOT PRINTLN LPAREN value RPAREN\n          | TMF_LIBRARY DOT PRINTF LPAREN value RPARENasignacion : VAR IDENTIFIER data_type EQUAL value\n                | CONST IDENTIFIER data_type EQUAL valuedata_type : STRING\n   | INTEGER_DATA_TYPE\n   | FLOAT32_DATA_TYPE\n   | FLOAT64_DATA_TYPE\n   | BOOLEAN_DATA_TYPE\n   | STRING_DATA_TYPEvalue : STRING\n         | INTEGER\n         | FLOAT32\n         | FLOAT64\n         | BOOLEAN'
    
_lr_action_items = {'TMF_LIBRARY':([0,],[2,]),'$end':([1,15,16,],[0,-1,-2,]),'DOT':([2,],[3,]),'PRINTLN':([3,],[4,]),'PRINTF':([3,],[5,]),'LPAREN':([4,5,],[6,7,]),'STRING':([6,7,],[9,9,]),'INTEGER':([6,7,],[10,10,]),'FLOAT32':([6,7,],[11,11,]),'FLOAT64':([6,7,],[12,12,]),'BOOLEAN':([6,7,],[13,13,]),'RPAREN':([8,9,10,11,12,13,14,],[15,-11,-12,-13,-14,-15,16,]),}

_lr_action = {}
for _k, _v in _lr_action_items.items():
   for _x,_y in zip(_v[0],_v[1]):
      if not _x in _lr_action:  _lr_action[_x] = {}
      _lr_action[_x][_k] = _y
del _lr_action_items

_lr_goto_items = {'print':([0,],[1,]),'value':([6,7,],[8,14,]),}

_lr_goto = {}
for _k, _v in _lr_goto_items.items():
   for _x, _y in zip(_v[0], _v[1]):
       if not _x in _lr_goto: _lr_goto[_x] = {}
       _lr_goto[_x][_k] = _y
del _lr_goto_items
_lr_productions = [
  ("S' -> print","S'",1,None,None,None),
  ('print -> TMF_LIBRARY DOT PRINTLN LPAREN value RPAREN','print',6,'p_print','syntax_analyzer.py',5),
  ('print -> TMF_LIBRARY DOT PRINTF LPAREN value RPAREN','print',6,'p_print','syntax_analyzer.py',6),
  ('asignacion -> VAR IDENTIFIER data_type EQUAL value','asignacion',5,'p_asignacion','syntax_analyzer.py',9),
  ('asignacion -> CONST IDENTIFIER data_type EQUAL value','asignacion',5,'p_asignacion','syntax_analyzer.py',10),
  ('data_type -> STRING','data_type',1,'p_data_type','syntax_analyzer.py',13),
  ('data_type -> INTEGER_DATA_TYPE','data_type',1,'p_data_type','syntax_analyzer.py',14),
  ('data_type -> FLOAT32_DATA_TYPE','data_type',1,'p_data_type','syntax_analyzer.py',15),
  ('data_type -> FLOAT64_DATA_TYPE','data_type',1,'p_data_type','syntax_analyzer.py',16),
  ('data_type -> BOOLEAN_DATA_TYPE','data_type',1,'p_data_type','syntax_analyzer.py',17),
  ('data_type -> STRING_DATA_TYPE','data_type',1,'p_data_type','syntax_analyzer.py',18),
  ('value -> STRING','value',1,'p_value','syntax_analyzer.py',21),
  ('value -> INTEGER','value',1,'p_value','syntax_analyzer.py',22),
  ('value -> FLOAT32','value',1,'p_value','syntax_analyzer.py',23),
  ('value -> FLOAT64','value',1,'p_value','syntax_analyzer.py',24),
  ('value -> BOOLEAN','value',1,'p_value','syntax_analyzer.py',25),
]
