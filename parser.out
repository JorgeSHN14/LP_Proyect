Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AND
    ARROW_FUNCTION_TYPE
    ARROW_SEND_RECEIVE
    AS
    ASSERT
    BITWISE_XOR
    BITWISE_XOR_ASSIGN
    BREAK
    CLASS
    COMMENT
    COMMENT_MULTI
    CONTINUE
    DEL
    DIVIDE
    ELIF
    ELLIPSIS
    ELSE
    ENTERE_DIVIDE
    EXCEPT
    FALSE
    FAT_ARROW
    FINALLY
    FROM
    GLOBAL
    GREATER_THAN
    HEX_NUMBER
    IF
    IMPORT
    IN
    IS
    LAMBDA
    LBRACKET
    LESS_THAN
    LOGICAL_NOT
    MINUS
    MODULE
    NEWLINE
    NONE
    NONLOCAL
    NOT
    NULL
    OR
    PASS
    PIPE
    PLUS
    RAISE
    RBRACKET
    RETURN
    SCIENTIFIC_NOTATION
    TIMES
    TRUE
    TRY
    WITH
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> sentencia
Rule 2     sentencia -> print
Rule 3     sentencia -> print_withoutvalue
Rule 4     sentencia -> for
Rule 5     sentencia -> def_function
Rule 6     sentencia -> call_function
Rule 7     sentencia -> input
Rule 8     sentencia -> assignment
Rule 9     sentencia -> short_assignment
Rule 10    for -> FOR rule_comparation LKEY program RKEY
Rule 11    print -> FMT_LIBRARY DOT PRINTLN LPAREN value RPAREN
Rule 12    print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
Rule 13    print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA identifiers RPAREN
Rule 14    print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
Rule 15    print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN
Rule 16    assignment -> VAR IDENTIFIER data_type EQUAL value
Rule 17    assignment -> CONST IDENTIFIER data_type EQUAL value
Rule 18    assignment -> VAR IDENTIFIER data_type EQUAL IDENTIFIER
Rule 19    assignment -> CONST IDENTIFIER data_type EQUAL IDENTIFIER
Rule 20    short_assignment -> IDENTIFIER SHORT_VAR_DECL value
Rule 21    short_assignment -> IDENTIFIER SHORT_VAR_DECL IDENTIFIER
Rule 22    arithmetic_operation -> IDENTIFIER PLUS_EQ value
Rule 23    arithmetic_operation -> IDENTIFIER MINUS_EQ value
Rule 24    arithmetic_operation -> IDENTIFIER TIMES_EQ value
Rule 25    arithmetic_operation -> IDENTIFIER DIVIDE_EQ value
Rule 26    arithmetic_operation -> IDENTIFIER MODULO_EQ value
Rule 27    arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value
Rule 28    arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value
Rule 29    arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value
Rule 30    arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value
Rule 31    arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value
Rule 32    rule_comparation -> IDENTIFIER EQUALEQUAL value
Rule 33    rule_comparation -> IDENTIFIER NOT_EQUAL value
Rule 34    rule_comparation -> IDENTIFIER LESS_EQUAL value
Rule 35    rule_comparation -> IDENTIFIER GREATER_EQUAL value
Rule 36    rule_comparation -> IDENTIFIER LESS value
Rule 37    rule_comparation -> IDENTIFIER GREATER value
Rule 38    rule_comparation -> IDENTIFIER LOGICAL_AND value
Rule 39    rule_comparation -> IDENTIFIER LOGICAL_OR value
Rule 40    comparation_operation -> value EQUALEQUAL value
Rule 41    comparation_operation -> value NOT_EQUAL value
Rule 42    comparation_operation -> value LESS_EQUAL value
Rule 43    comparation_operation -> value GREATER_EQUAL value
Rule 44    comparation_operation -> value LESS value
Rule 45    comparation_operation -> value GREATER value
Rule 46    comparation_operation -> value LOGICAL_AND value
Rule 47    comparation_operation -> value LOGICAL_OR value
Rule 48    identifiers -> IDENTIFIER
Rule 49    identifiers -> identifiers COMMA identifiers
Rule 50    def_function -> DEF IDENTIFIER LPAREN parameters RPAREN COLON sentencia
Rule 51    call_function -> IDENTIFIER LPAREN values RPAREN
Rule 52    parameters -> parameter
Rule 53    parameters -> parameters COMMA parameter
Rule 54    parameter -> IDENTIFIER value
Rule 55    values -> value
Rule 56    values -> values COMMA value
Rule 57    value -> STRING
Rule 58    value -> INTEGER
Rule 59    value -> FLOAT32
Rule 60    value -> FLOAT64
Rule 61    value -> BOOLEAN
Rule 62    data_type -> INTEGER_DATA_TYPE
Rule 63    data_type -> FLOAT32_DATA_TYPE
Rule 64    data_type -> FLOAT64_DATA_TYPE
Rule 65    data_type -> BOOLEAN_DATA_TYPE
Rule 66    data_type -> STRING_DATA_TYPE
Rule 67    input -> INPUT LPAREN RPAREN
Rule 68    input -> INPUT LPAREN value RPAREN
Rule 69    input -> INPUT LPAREN identifiers RPAREN

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 
ARROW_FUNCTION_TYPE  : 
ARROW_SEND_RECEIVE   : 
AS                   : 
ASSERT               : 
BITWISE_AND_EQ       : 27
BITWISE_OR_EQ        : 28
BITWISE_XOR          : 
BITWISE_XOR_ASSIGN   : 
BITWISE_XOR_EQ       : 29
BOOLEAN              : 61
BOOLEAN_DATA_TYPE    : 65
BREAK                : 
CLASS                : 
COLON                : 50
COMMA                : 12 13 49 53 56
COMMENT              : 
COMMENT_MULTI        : 
CONST                : 17 19
CONTINUE             : 
DEF                  : 50
DEL                  : 
DIVIDE               : 
DIVIDE_EQ            : 25
DOT                  : 11 12 13 14 15
ELIF                 : 
ELLIPSIS             : 
ELSE                 : 
ENTERE_DIVIDE        : 
EQUAL                : 16 17 18 19
EQUALEQUAL           : 32 40
EXCEPT               : 
FALSE                : 
FAT_ARROW            : 
FINALLY              : 
FLOAT32              : 59
FLOAT32_DATA_TYPE    : 63
FLOAT64              : 60
FLOAT64_DATA_TYPE    : 64
FMT_LIBRARY          : 11 12 13 14 15
FOR                  : 10
FROM                 : 
GLOBAL               : 
GREATER              : 37 45
GREATER_EQUAL        : 35 43
GREATER_THAN         : 
HEX_NUMBER           : 
IDENTIFIER           : 16 17 18 18 19 19 20 21 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 48 50 51 54
IF                   : 
IMPORT               : 
IN                   : 
INPUT                : 67 68 69
INTEGER              : 58
INTEGER_DATA_TYPE    : 62
IS                   : 
LAMBDA               : 
LBRACKET             : 
LEFT_SHIFT_EQ        : 30
LESS                 : 36 44
LESS_EQUAL           : 34 42
LESS_THAN            : 
LKEY                 : 10
LOGICAL_AND          : 38 46
LOGICAL_NOT          : 
LOGICAL_OR           : 39 47
LPAREN               : 11 12 13 14 15 50 51 67 68 69
MINUS                : 
MINUS_EQ             : 23
MODULE               : 
MODULO_EQ            : 26
NEWLINE              : 
NONE                 : 
NONLOCAL             : 
NOT                  : 
NOT_EQUAL            : 33 41
NULL                 : 
OR                   : 
PASS                 : 
PIPE                 : 
PLUS                 : 
PLUS_EQ              : 22
PRINTF               : 12 13 15
PRINTLN              : 11 14
RAISE                : 
RBRACKET             : 
RETURN               : 
RIGHT_SHIFT_EQ       : 31
RKEY                 : 10
RPAREN               : 11 12 13 14 15 50 51 67 68 69
SCIENTIFIC_NOTATION  : 
SHORT_VAR_DECL       : 20 21
STRING               : 57
STRING_DATA_TYPE     : 66
TIMES                : 
TIMES_EQ             : 24
TRUE                 : 
TRY                  : 
VAR                  : 16 18
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arithmetic_operation : 
assignment           : 8
call_function        : 6
comparation_operation : 
data_type            : 16 17 18 19
def_function         : 5
for                  : 4
identifiers          : 13 49 49 69
input                : 7
parameter            : 52 53
parameters           : 50 53
print                : 2
print_withoutvalue   : 3
program              : 10 0
rule_comparation     : 10
sentencia            : 1 50
short_assignment     : 9
value                : 11 12 13 16 17 20 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 54 55 56 68
values               : 51 56

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . sentencia
    (2) sentencia -> . print
    (3) sentencia -> . print_withoutvalue
    (4) sentencia -> . for
    (5) sentencia -> . def_function
    (6) sentencia -> . call_function
    (7) sentencia -> . input
    (8) sentencia -> . assignment
    (9) sentencia -> . short_assignment
    (11) print -> . FMT_LIBRARY DOT PRINTLN LPAREN value RPAREN
    (12) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (13) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA identifiers RPAREN
    (14) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (15) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (10) for -> . FOR rule_comparation LKEY program RKEY
    (50) def_function -> . DEF IDENTIFIER LPAREN parameters RPAREN COLON sentencia
    (51) call_function -> . IDENTIFIER LPAREN values RPAREN
    (67) input -> . INPUT LPAREN RPAREN
    (68) input -> . INPUT LPAREN value RPAREN
    (69) input -> . INPUT LPAREN identifiers RPAREN
    (16) assignment -> . VAR IDENTIFIER data_type EQUAL value
    (17) assignment -> . CONST IDENTIFIER data_type EQUAL value
    (18) assignment -> . VAR IDENTIFIER data_type EQUAL IDENTIFIER
    (19) assignment -> . CONST IDENTIFIER data_type EQUAL IDENTIFIER
    (20) short_assignment -> . IDENTIFIER SHORT_VAR_DECL value
    (21) short_assignment -> . IDENTIFIER SHORT_VAR_DECL IDENTIFIER

    FMT_LIBRARY     shift and go to state 11
    FOR             shift and go to state 12
    DEF             shift and go to state 13
    IDENTIFIER      shift and go to state 14
    INPUT           shift and go to state 15
    VAR             shift and go to state 16
    CONST           shift and go to state 17

    program                        shift and go to state 1
    sentencia                      shift and go to state 2
    print                          shift and go to state 3
    print_withoutvalue             shift and go to state 4
    for                            shift and go to state 5
    def_function                   shift and go to state 6
    call_function                  shift and go to state 7
    input                          shift and go to state 8
    assignment                     shift and go to state 9
    short_assignment               shift and go to state 10

state 1

    (0) S' -> program .



state 2

    (1) program -> sentencia .

    $end            reduce using rule 1 (program -> sentencia .)
    RKEY            reduce using rule 1 (program -> sentencia .)


state 3

    (2) sentencia -> print .

    $end            reduce using rule 2 (sentencia -> print .)
    RKEY            reduce using rule 2 (sentencia -> print .)


state 4

    (3) sentencia -> print_withoutvalue .

    $end            reduce using rule 3 (sentencia -> print_withoutvalue .)
    RKEY            reduce using rule 3 (sentencia -> print_withoutvalue .)


state 5

    (4) sentencia -> for .

    $end            reduce using rule 4 (sentencia -> for .)
    RKEY            reduce using rule 4 (sentencia -> for .)


state 6

    (5) sentencia -> def_function .

    $end            reduce using rule 5 (sentencia -> def_function .)
    RKEY            reduce using rule 5 (sentencia -> def_function .)


state 7

    (6) sentencia -> call_function .

    $end            reduce using rule 6 (sentencia -> call_function .)
    RKEY            reduce using rule 6 (sentencia -> call_function .)


state 8

    (7) sentencia -> input .

    $end            reduce using rule 7 (sentencia -> input .)
    RKEY            reduce using rule 7 (sentencia -> input .)


state 9

    (8) sentencia -> assignment .

    $end            reduce using rule 8 (sentencia -> assignment .)
    RKEY            reduce using rule 8 (sentencia -> assignment .)


state 10

    (9) sentencia -> short_assignment .

    $end            reduce using rule 9 (sentencia -> short_assignment .)
    RKEY            reduce using rule 9 (sentencia -> short_assignment .)


state 11

    (11) print -> FMT_LIBRARY . DOT PRINTLN LPAREN value RPAREN
    (12) print -> FMT_LIBRARY . DOT PRINTF LPAREN value COMMA RPAREN
    (13) print -> FMT_LIBRARY . DOT PRINTF LPAREN value COMMA identifiers RPAREN
    (14) print_withoutvalue -> FMT_LIBRARY . DOT PRINTLN LPAREN RPAREN
    (15) print_withoutvalue -> FMT_LIBRARY . DOT PRINTF LPAREN RPAREN

    DOT             shift and go to state 18


state 12

    (10) for -> FOR . rule_comparation LKEY program RKEY
    (32) rule_comparation -> . IDENTIFIER EQUALEQUAL value
    (33) rule_comparation -> . IDENTIFIER NOT_EQUAL value
    (34) rule_comparation -> . IDENTIFIER LESS_EQUAL value
    (35) rule_comparation -> . IDENTIFIER GREATER_EQUAL value
    (36) rule_comparation -> . IDENTIFIER LESS value
    (37) rule_comparation -> . IDENTIFIER GREATER value
    (38) rule_comparation -> . IDENTIFIER LOGICAL_AND value
    (39) rule_comparation -> . IDENTIFIER LOGICAL_OR value

    IDENTIFIER      shift and go to state 20

    rule_comparation               shift and go to state 19

state 13

    (50) def_function -> DEF . IDENTIFIER LPAREN parameters RPAREN COLON sentencia

    IDENTIFIER      shift and go to state 21


state 14

    (51) call_function -> IDENTIFIER . LPAREN values RPAREN
    (20) short_assignment -> IDENTIFIER . SHORT_VAR_DECL value
    (21) short_assignment -> IDENTIFIER . SHORT_VAR_DECL IDENTIFIER

    LPAREN          shift and go to state 22
    SHORT_VAR_DECL  shift and go to state 23


state 15

    (67) input -> INPUT . LPAREN RPAREN
    (68) input -> INPUT . LPAREN value RPAREN
    (69) input -> INPUT . LPAREN identifiers RPAREN

    LPAREN          shift and go to state 24


state 16

    (16) assignment -> VAR . IDENTIFIER data_type EQUAL value
    (18) assignment -> VAR . IDENTIFIER data_type EQUAL IDENTIFIER

    IDENTIFIER      shift and go to state 25


state 17

    (17) assignment -> CONST . IDENTIFIER data_type EQUAL value
    (19) assignment -> CONST . IDENTIFIER data_type EQUAL IDENTIFIER

    IDENTIFIER      shift and go to state 26


state 18

    (11) print -> FMT_LIBRARY DOT . PRINTLN LPAREN value RPAREN
    (12) print -> FMT_LIBRARY DOT . PRINTF LPAREN value COMMA RPAREN
    (13) print -> FMT_LIBRARY DOT . PRINTF LPAREN value COMMA identifiers RPAREN
    (14) print_withoutvalue -> FMT_LIBRARY DOT . PRINTLN LPAREN RPAREN
    (15) print_withoutvalue -> FMT_LIBRARY DOT . PRINTF LPAREN RPAREN

    PRINTLN         shift and go to state 27
    PRINTF          shift and go to state 28


state 19

    (10) for -> FOR rule_comparation . LKEY program RKEY

    LKEY            shift and go to state 29


state 20

    (32) rule_comparation -> IDENTIFIER . EQUALEQUAL value
    (33) rule_comparation -> IDENTIFIER . NOT_EQUAL value
    (34) rule_comparation -> IDENTIFIER . LESS_EQUAL value
    (35) rule_comparation -> IDENTIFIER . GREATER_EQUAL value
    (36) rule_comparation -> IDENTIFIER . LESS value
    (37) rule_comparation -> IDENTIFIER . GREATER value
    (38) rule_comparation -> IDENTIFIER . LOGICAL_AND value
    (39) rule_comparation -> IDENTIFIER . LOGICAL_OR value

    EQUALEQUAL      shift and go to state 30
    NOT_EQUAL       shift and go to state 31
    LESS_EQUAL      shift and go to state 32
    GREATER_EQUAL   shift and go to state 33
    LESS            shift and go to state 34
    GREATER         shift and go to state 35
    LOGICAL_AND     shift and go to state 36
    LOGICAL_OR      shift and go to state 37


state 21

    (50) def_function -> DEF IDENTIFIER . LPAREN parameters RPAREN COLON sentencia

    LPAREN          shift and go to state 38


state 22

    (51) call_function -> IDENTIFIER LPAREN . values RPAREN
    (55) values -> . value
    (56) values -> . values COMMA value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    values                         shift and go to state 39
    value                          shift and go to state 40

state 23

    (20) short_assignment -> IDENTIFIER SHORT_VAR_DECL . value
    (21) short_assignment -> IDENTIFIER SHORT_VAR_DECL . IDENTIFIER
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    IDENTIFIER      shift and go to state 46
    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 47

state 24

    (67) input -> INPUT LPAREN . RPAREN
    (68) input -> INPUT LPAREN . value RPAREN
    (69) input -> INPUT LPAREN . identifiers RPAREN
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN
    (48) identifiers -> . IDENTIFIER
    (49) identifiers -> . identifiers COMMA identifiers

    RPAREN          shift and go to state 48
    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45
    IDENTIFIER      shift and go to state 51

    value                          shift and go to state 49
    identifiers                    shift and go to state 50

state 25

    (16) assignment -> VAR IDENTIFIER . data_type EQUAL value
    (18) assignment -> VAR IDENTIFIER . data_type EQUAL IDENTIFIER
    (62) data_type -> . INTEGER_DATA_TYPE
    (63) data_type -> . FLOAT32_DATA_TYPE
    (64) data_type -> . FLOAT64_DATA_TYPE
    (65) data_type -> . BOOLEAN_DATA_TYPE
    (66) data_type -> . STRING_DATA_TYPE

    INTEGER_DATA_TYPE shift and go to state 53
    FLOAT32_DATA_TYPE shift and go to state 54
    FLOAT64_DATA_TYPE shift and go to state 55
    BOOLEAN_DATA_TYPE shift and go to state 56
    STRING_DATA_TYPE shift and go to state 57

    data_type                      shift and go to state 52

state 26

    (17) assignment -> CONST IDENTIFIER . data_type EQUAL value
    (19) assignment -> CONST IDENTIFIER . data_type EQUAL IDENTIFIER
    (62) data_type -> . INTEGER_DATA_TYPE
    (63) data_type -> . FLOAT32_DATA_TYPE
    (64) data_type -> . FLOAT64_DATA_TYPE
    (65) data_type -> . BOOLEAN_DATA_TYPE
    (66) data_type -> . STRING_DATA_TYPE

    INTEGER_DATA_TYPE shift and go to state 53
    FLOAT32_DATA_TYPE shift and go to state 54
    FLOAT64_DATA_TYPE shift and go to state 55
    BOOLEAN_DATA_TYPE shift and go to state 56
    STRING_DATA_TYPE shift and go to state 57

    data_type                      shift and go to state 58

state 27

    (11) print -> FMT_LIBRARY DOT PRINTLN . LPAREN value RPAREN
    (14) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN . LPAREN RPAREN

    LPAREN          shift and go to state 59


state 28

    (12) print -> FMT_LIBRARY DOT PRINTF . LPAREN value COMMA RPAREN
    (13) print -> FMT_LIBRARY DOT PRINTF . LPAREN value COMMA identifiers RPAREN
    (15) print_withoutvalue -> FMT_LIBRARY DOT PRINTF . LPAREN RPAREN

    LPAREN          shift and go to state 60


state 29

    (10) for -> FOR rule_comparation LKEY . program RKEY
    (1) program -> . sentencia
    (2) sentencia -> . print
    (3) sentencia -> . print_withoutvalue
    (4) sentencia -> . for
    (5) sentencia -> . def_function
    (6) sentencia -> . call_function
    (7) sentencia -> . input
    (8) sentencia -> . assignment
    (9) sentencia -> . short_assignment
    (11) print -> . FMT_LIBRARY DOT PRINTLN LPAREN value RPAREN
    (12) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (13) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA identifiers RPAREN
    (14) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (15) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (10) for -> . FOR rule_comparation LKEY program RKEY
    (50) def_function -> . DEF IDENTIFIER LPAREN parameters RPAREN COLON sentencia
    (51) call_function -> . IDENTIFIER LPAREN values RPAREN
    (67) input -> . INPUT LPAREN RPAREN
    (68) input -> . INPUT LPAREN value RPAREN
    (69) input -> . INPUT LPAREN identifiers RPAREN
    (16) assignment -> . VAR IDENTIFIER data_type EQUAL value
    (17) assignment -> . CONST IDENTIFIER data_type EQUAL value
    (18) assignment -> . VAR IDENTIFIER data_type EQUAL IDENTIFIER
    (19) assignment -> . CONST IDENTIFIER data_type EQUAL IDENTIFIER
    (20) short_assignment -> . IDENTIFIER SHORT_VAR_DECL value
    (21) short_assignment -> . IDENTIFIER SHORT_VAR_DECL IDENTIFIER

    FMT_LIBRARY     shift and go to state 11
    FOR             shift and go to state 12
    DEF             shift and go to state 13
    IDENTIFIER      shift and go to state 14
    INPUT           shift and go to state 15
    VAR             shift and go to state 16
    CONST           shift and go to state 17

    program                        shift and go to state 61
    sentencia                      shift and go to state 2
    print                          shift and go to state 3
    print_withoutvalue             shift and go to state 4
    for                            shift and go to state 5
    def_function                   shift and go to state 6
    call_function                  shift and go to state 7
    input                          shift and go to state 8
    assignment                     shift and go to state 9
    short_assignment               shift and go to state 10

state 30

    (32) rule_comparation -> IDENTIFIER EQUALEQUAL . value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 62

state 31

    (33) rule_comparation -> IDENTIFIER NOT_EQUAL . value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 63

state 32

    (34) rule_comparation -> IDENTIFIER LESS_EQUAL . value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 64

state 33

    (35) rule_comparation -> IDENTIFIER GREATER_EQUAL . value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 65

state 34

    (36) rule_comparation -> IDENTIFIER LESS . value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 66

state 35

    (37) rule_comparation -> IDENTIFIER GREATER . value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 67

state 36

    (38) rule_comparation -> IDENTIFIER LOGICAL_AND . value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 68

state 37

    (39) rule_comparation -> IDENTIFIER LOGICAL_OR . value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 69

state 38

    (50) def_function -> DEF IDENTIFIER LPAREN . parameters RPAREN COLON sentencia
    (52) parameters -> . parameter
    (53) parameters -> . parameters COMMA parameter
    (54) parameter -> . IDENTIFIER value

    IDENTIFIER      shift and go to state 70

    parameters                     shift and go to state 71
    parameter                      shift and go to state 72

state 39

    (51) call_function -> IDENTIFIER LPAREN values . RPAREN
    (56) values -> values . COMMA value

    RPAREN          shift and go to state 73
    COMMA           shift and go to state 74


state 40

    (55) values -> value .

    RPAREN          reduce using rule 55 (values -> value .)
    COMMA           reduce using rule 55 (values -> value .)


state 41

    (57) value -> STRING .

    RPAREN          reduce using rule 57 (value -> STRING .)
    COMMA           reduce using rule 57 (value -> STRING .)
    $end            reduce using rule 57 (value -> STRING .)
    RKEY            reduce using rule 57 (value -> STRING .)
    LKEY            reduce using rule 57 (value -> STRING .)


state 42

    (58) value -> INTEGER .

    RPAREN          reduce using rule 58 (value -> INTEGER .)
    COMMA           reduce using rule 58 (value -> INTEGER .)
    $end            reduce using rule 58 (value -> INTEGER .)
    RKEY            reduce using rule 58 (value -> INTEGER .)
    LKEY            reduce using rule 58 (value -> INTEGER .)


state 43

    (59) value -> FLOAT32 .

    RPAREN          reduce using rule 59 (value -> FLOAT32 .)
    COMMA           reduce using rule 59 (value -> FLOAT32 .)
    $end            reduce using rule 59 (value -> FLOAT32 .)
    RKEY            reduce using rule 59 (value -> FLOAT32 .)
    LKEY            reduce using rule 59 (value -> FLOAT32 .)


state 44

    (60) value -> FLOAT64 .

    RPAREN          reduce using rule 60 (value -> FLOAT64 .)
    COMMA           reduce using rule 60 (value -> FLOAT64 .)
    $end            reduce using rule 60 (value -> FLOAT64 .)
    RKEY            reduce using rule 60 (value -> FLOAT64 .)
    LKEY            reduce using rule 60 (value -> FLOAT64 .)


state 45

    (61) value -> BOOLEAN .

    RPAREN          reduce using rule 61 (value -> BOOLEAN .)
    COMMA           reduce using rule 61 (value -> BOOLEAN .)
    $end            reduce using rule 61 (value -> BOOLEAN .)
    RKEY            reduce using rule 61 (value -> BOOLEAN .)
    LKEY            reduce using rule 61 (value -> BOOLEAN .)


state 46

    (21) short_assignment -> IDENTIFIER SHORT_VAR_DECL IDENTIFIER .

    $end            reduce using rule 21 (short_assignment -> IDENTIFIER SHORT_VAR_DECL IDENTIFIER .)
    RKEY            reduce using rule 21 (short_assignment -> IDENTIFIER SHORT_VAR_DECL IDENTIFIER .)


state 47

    (20) short_assignment -> IDENTIFIER SHORT_VAR_DECL value .

    $end            reduce using rule 20 (short_assignment -> IDENTIFIER SHORT_VAR_DECL value .)
    RKEY            reduce using rule 20 (short_assignment -> IDENTIFIER SHORT_VAR_DECL value .)


state 48

    (67) input -> INPUT LPAREN RPAREN .

    $end            reduce using rule 67 (input -> INPUT LPAREN RPAREN .)
    RKEY            reduce using rule 67 (input -> INPUT LPAREN RPAREN .)


state 49

    (68) input -> INPUT LPAREN value . RPAREN

    RPAREN          shift and go to state 75


state 50

    (69) input -> INPUT LPAREN identifiers . RPAREN
    (49) identifiers -> identifiers . COMMA identifiers

    RPAREN          shift and go to state 76
    COMMA           shift and go to state 77


state 51

    (48) identifiers -> IDENTIFIER .

    RPAREN          reduce using rule 48 (identifiers -> IDENTIFIER .)
    COMMA           reduce using rule 48 (identifiers -> IDENTIFIER .)


state 52

    (16) assignment -> VAR IDENTIFIER data_type . EQUAL value
    (18) assignment -> VAR IDENTIFIER data_type . EQUAL IDENTIFIER

    EQUAL           shift and go to state 78


state 53

    (62) data_type -> INTEGER_DATA_TYPE .

    EQUAL           reduce using rule 62 (data_type -> INTEGER_DATA_TYPE .)


state 54

    (63) data_type -> FLOAT32_DATA_TYPE .

    EQUAL           reduce using rule 63 (data_type -> FLOAT32_DATA_TYPE .)


state 55

    (64) data_type -> FLOAT64_DATA_TYPE .

    EQUAL           reduce using rule 64 (data_type -> FLOAT64_DATA_TYPE .)


state 56

    (65) data_type -> BOOLEAN_DATA_TYPE .

    EQUAL           reduce using rule 65 (data_type -> BOOLEAN_DATA_TYPE .)


state 57

    (66) data_type -> STRING_DATA_TYPE .

    EQUAL           reduce using rule 66 (data_type -> STRING_DATA_TYPE .)


state 58

    (17) assignment -> CONST IDENTIFIER data_type . EQUAL value
    (19) assignment -> CONST IDENTIFIER data_type . EQUAL IDENTIFIER

    EQUAL           shift and go to state 79


state 59

    (11) print -> FMT_LIBRARY DOT PRINTLN LPAREN . value RPAREN
    (14) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN . RPAREN
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    RPAREN          shift and go to state 81
    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 80

state 60

    (12) print -> FMT_LIBRARY DOT PRINTF LPAREN . value COMMA RPAREN
    (13) print -> FMT_LIBRARY DOT PRINTF LPAREN . value COMMA identifiers RPAREN
    (15) print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN . RPAREN
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    RPAREN          shift and go to state 83
    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 82

state 61

    (10) for -> FOR rule_comparation LKEY program . RKEY

    RKEY            shift and go to state 84


state 62

    (32) rule_comparation -> IDENTIFIER EQUALEQUAL value .

    LKEY            reduce using rule 32 (rule_comparation -> IDENTIFIER EQUALEQUAL value .)


state 63

    (33) rule_comparation -> IDENTIFIER NOT_EQUAL value .

    LKEY            reduce using rule 33 (rule_comparation -> IDENTIFIER NOT_EQUAL value .)


state 64

    (34) rule_comparation -> IDENTIFIER LESS_EQUAL value .

    LKEY            reduce using rule 34 (rule_comparation -> IDENTIFIER LESS_EQUAL value .)


state 65

    (35) rule_comparation -> IDENTIFIER GREATER_EQUAL value .

    LKEY            reduce using rule 35 (rule_comparation -> IDENTIFIER GREATER_EQUAL value .)


state 66

    (36) rule_comparation -> IDENTIFIER LESS value .

    LKEY            reduce using rule 36 (rule_comparation -> IDENTIFIER LESS value .)


state 67

    (37) rule_comparation -> IDENTIFIER GREATER value .

    LKEY            reduce using rule 37 (rule_comparation -> IDENTIFIER GREATER value .)


state 68

    (38) rule_comparation -> IDENTIFIER LOGICAL_AND value .

    LKEY            reduce using rule 38 (rule_comparation -> IDENTIFIER LOGICAL_AND value .)


state 69

    (39) rule_comparation -> IDENTIFIER LOGICAL_OR value .

    LKEY            reduce using rule 39 (rule_comparation -> IDENTIFIER LOGICAL_OR value .)


state 70

    (54) parameter -> IDENTIFIER . value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 85

state 71

    (50) def_function -> DEF IDENTIFIER LPAREN parameters . RPAREN COLON sentencia
    (53) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 86
    COMMA           shift and go to state 87


state 72

    (52) parameters -> parameter .

    RPAREN          reduce using rule 52 (parameters -> parameter .)
    COMMA           reduce using rule 52 (parameters -> parameter .)


state 73

    (51) call_function -> IDENTIFIER LPAREN values RPAREN .

    $end            reduce using rule 51 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    RKEY            reduce using rule 51 (call_function -> IDENTIFIER LPAREN values RPAREN .)


state 74

    (56) values -> values COMMA . value
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 88

state 75

    (68) input -> INPUT LPAREN value RPAREN .

    $end            reduce using rule 68 (input -> INPUT LPAREN value RPAREN .)
    RKEY            reduce using rule 68 (input -> INPUT LPAREN value RPAREN .)


state 76

    (69) input -> INPUT LPAREN identifiers RPAREN .

    $end            reduce using rule 69 (input -> INPUT LPAREN identifiers RPAREN .)
    RKEY            reduce using rule 69 (input -> INPUT LPAREN identifiers RPAREN .)


state 77

    (49) identifiers -> identifiers COMMA . identifiers
    (48) identifiers -> . IDENTIFIER
    (49) identifiers -> . identifiers COMMA identifiers

    IDENTIFIER      shift and go to state 51

    identifiers                    shift and go to state 89

state 78

    (16) assignment -> VAR IDENTIFIER data_type EQUAL . value
    (18) assignment -> VAR IDENTIFIER data_type EQUAL . IDENTIFIER
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    IDENTIFIER      shift and go to state 90
    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 91

state 79

    (17) assignment -> CONST IDENTIFIER data_type EQUAL . value
    (19) assignment -> CONST IDENTIFIER data_type EQUAL . IDENTIFIER
    (57) value -> . STRING
    (58) value -> . INTEGER
    (59) value -> . FLOAT32
    (60) value -> . FLOAT64
    (61) value -> . BOOLEAN

    IDENTIFIER      shift and go to state 92
    STRING          shift and go to state 41
    INTEGER         shift and go to state 42
    FLOAT32         shift and go to state 43
    FLOAT64         shift and go to state 44
    BOOLEAN         shift and go to state 45

    value                          shift and go to state 93

state 80

    (11) print -> FMT_LIBRARY DOT PRINTLN LPAREN value . RPAREN

    RPAREN          shift and go to state 94


state 81

    (14) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .

    $end            reduce using rule 14 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    RKEY            reduce using rule 14 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)


state 82

    (12) print -> FMT_LIBRARY DOT PRINTF LPAREN value . COMMA RPAREN
    (13) print -> FMT_LIBRARY DOT PRINTF LPAREN value . COMMA identifiers RPAREN

    COMMA           shift and go to state 95


state 83

    (15) print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .

    $end            reduce using rule 15 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    RKEY            reduce using rule 15 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)


state 84

    (10) for -> FOR rule_comparation LKEY program RKEY .

    $end            reduce using rule 10 (for -> FOR rule_comparation LKEY program RKEY .)
    RKEY            reduce using rule 10 (for -> FOR rule_comparation LKEY program RKEY .)


state 85

    (54) parameter -> IDENTIFIER value .

    RPAREN          reduce using rule 54 (parameter -> IDENTIFIER value .)
    COMMA           reduce using rule 54 (parameter -> IDENTIFIER value .)


state 86

    (50) def_function -> DEF IDENTIFIER LPAREN parameters RPAREN . COLON sentencia

    COLON           shift and go to state 96


state 87

    (53) parameters -> parameters COMMA . parameter
    (54) parameter -> . IDENTIFIER value

    IDENTIFIER      shift and go to state 70

    parameter                      shift and go to state 97

state 88

    (56) values -> values COMMA value .

    RPAREN          reduce using rule 56 (values -> values COMMA value .)
    COMMA           reduce using rule 56 (values -> values COMMA value .)


state 89

    (49) identifiers -> identifiers COMMA identifiers .
    (49) identifiers -> identifiers . COMMA identifiers

  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 49 (identifiers -> identifiers COMMA identifiers .)
    COMMA           shift and go to state 77

  ! COMMA           [ reduce using rule 49 (identifiers -> identifiers COMMA identifiers .) ]


state 90

    (18) assignment -> VAR IDENTIFIER data_type EQUAL IDENTIFIER .

    $end            reduce using rule 18 (assignment -> VAR IDENTIFIER data_type EQUAL IDENTIFIER .)
    RKEY            reduce using rule 18 (assignment -> VAR IDENTIFIER data_type EQUAL IDENTIFIER .)


state 91

    (16) assignment -> VAR IDENTIFIER data_type EQUAL value .

    $end            reduce using rule 16 (assignment -> VAR IDENTIFIER data_type EQUAL value .)
    RKEY            reduce using rule 16 (assignment -> VAR IDENTIFIER data_type EQUAL value .)


state 92

    (19) assignment -> CONST IDENTIFIER data_type EQUAL IDENTIFIER .

    $end            reduce using rule 19 (assignment -> CONST IDENTIFIER data_type EQUAL IDENTIFIER .)
    RKEY            reduce using rule 19 (assignment -> CONST IDENTIFIER data_type EQUAL IDENTIFIER .)


state 93

    (17) assignment -> CONST IDENTIFIER data_type EQUAL value .

    $end            reduce using rule 17 (assignment -> CONST IDENTIFIER data_type EQUAL value .)
    RKEY            reduce using rule 17 (assignment -> CONST IDENTIFIER data_type EQUAL value .)


state 94

    (11) print -> FMT_LIBRARY DOT PRINTLN LPAREN value RPAREN .

    $end            reduce using rule 11 (print -> FMT_LIBRARY DOT PRINTLN LPAREN value RPAREN .)
    RKEY            reduce using rule 11 (print -> FMT_LIBRARY DOT PRINTLN LPAREN value RPAREN .)


state 95

    (12) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA . RPAREN
    (13) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA . identifiers RPAREN
    (48) identifiers -> . IDENTIFIER
    (49) identifiers -> . identifiers COMMA identifiers

    RPAREN          shift and go to state 98
    IDENTIFIER      shift and go to state 51

    identifiers                    shift and go to state 99

state 96

    (50) def_function -> DEF IDENTIFIER LPAREN parameters RPAREN COLON . sentencia
    (2) sentencia -> . print
    (3) sentencia -> . print_withoutvalue
    (4) sentencia -> . for
    (5) sentencia -> . def_function
    (6) sentencia -> . call_function
    (7) sentencia -> . input
    (8) sentencia -> . assignment
    (9) sentencia -> . short_assignment
    (11) print -> . FMT_LIBRARY DOT PRINTLN LPAREN value RPAREN
    (12) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (13) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA identifiers RPAREN
    (14) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (15) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (10) for -> . FOR rule_comparation LKEY program RKEY
    (50) def_function -> . DEF IDENTIFIER LPAREN parameters RPAREN COLON sentencia
    (51) call_function -> . IDENTIFIER LPAREN values RPAREN
    (67) input -> . INPUT LPAREN RPAREN
    (68) input -> . INPUT LPAREN value RPAREN
    (69) input -> . INPUT LPAREN identifiers RPAREN
    (16) assignment -> . VAR IDENTIFIER data_type EQUAL value
    (17) assignment -> . CONST IDENTIFIER data_type EQUAL value
    (18) assignment -> . VAR IDENTIFIER data_type EQUAL IDENTIFIER
    (19) assignment -> . CONST IDENTIFIER data_type EQUAL IDENTIFIER
    (20) short_assignment -> . IDENTIFIER SHORT_VAR_DECL value
    (21) short_assignment -> . IDENTIFIER SHORT_VAR_DECL IDENTIFIER

    FMT_LIBRARY     shift and go to state 11
    FOR             shift and go to state 12
    DEF             shift and go to state 13
    IDENTIFIER      shift and go to state 14
    INPUT           shift and go to state 15
    VAR             shift and go to state 16
    CONST           shift and go to state 17

    sentencia                      shift and go to state 100
    print                          shift and go to state 3
    print_withoutvalue             shift and go to state 4
    for                            shift and go to state 5
    def_function                   shift and go to state 6
    call_function                  shift and go to state 7
    input                          shift and go to state 8
    assignment                     shift and go to state 9
    short_assignment               shift and go to state 10

state 97

    (53) parameters -> parameters COMMA parameter .

    RPAREN          reduce using rule 53 (parameters -> parameters COMMA parameter .)
    COMMA           reduce using rule 53 (parameters -> parameters COMMA parameter .)


state 98

    (12) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .

    $end            reduce using rule 12 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    RKEY            reduce using rule 12 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)


state 99

    (13) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA identifiers . RPAREN
    (49) identifiers -> identifiers . COMMA identifiers

    RPAREN          shift and go to state 101
    COMMA           shift and go to state 77


state 100

    (50) def_function -> DEF IDENTIFIER LPAREN parameters RPAREN COLON sentencia .

    $end            reduce using rule 50 (def_function -> DEF IDENTIFIER LPAREN parameters RPAREN COLON sentencia .)
    RKEY            reduce using rule 50 (def_function -> DEF IDENTIFIER LPAREN parameters RPAREN COLON sentencia .)


state 101

    (13) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA identifiers RPAREN .

    $end            reduce using rule 13 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA identifiers RPAREN .)
    RKEY            reduce using rule 13 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA identifiers RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 89 resolved as shift
