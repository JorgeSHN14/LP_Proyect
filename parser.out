Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AND
    ARROW_FUNCTION_TYPE
    ARROW_SEND_RECEIVE
    AS
    ASSERT
    BITWISE_XOR
    BITWISE_XOR_ASSIGN
    CLASS
    COMMENT
    COMMENT_MULTI
    DEL
    DOUBLE_QUOTE
    ELIF
    ELLIPSIS
    EXCEPT
    FALSE
    FAT_ARROW
    FINALLY
    FMT_FORMAT_STRING
    FROM
    GLOBAL
    GREATER_THAN
    HEX_NUMBER
    IMPORT
    IN
    IS
    LAMBDA
    LBRACKET
    LESS_THAN
    NONE
    NONLOCAL
    NOT
    NULL
    OR
    PERCENT_D
    PIPE
    RAISE
    RBRACKET
    SCIENTIFIC_NOTATION
    TRUE
    TRY
    WITH
    YIELD

Grammar

Rule 0     S' -> loop_program
Rule 1     loop_program -> program
Rule 2     loop_program -> loop_reserved
Rule 3     loop_program -> loop_program program
Rule 4     loop_program -> loop_program loop_reserved
Rule 5     func_program -> program
Rule 6     func_program -> RETURN
Rule 7     func_program -> RETURN usable_value
Rule 8     func_program -> func_program program
Rule 9     func_program -> func_program RETURN
Rule 10    func_program -> func_program RETURN usable_value
Rule 11    program -> sentencia
Rule 12    program -> loop
Rule 13    program -> program sentencia
Rule 14    program -> program loop
Rule 15    loop_reserved -> BREAK
Rule 16    loop_reserved -> CONTINUE
Rule 17    loop_reserved -> PASS
Rule 18    loop -> for
Rule 19    sentencia -> print
Rule 20    sentencia -> print_withoutvalue
Rule 21    sentencia -> def_function
Rule 22    sentencia -> call_function
Rule 23    sentencia -> input
Rule 24    sentencia -> short_assignment
Rule 25    sentencia -> arithmetic_operation
Rule 26    sentencia -> direct_arithmetic_operation
Rule 27    sentencia -> if_statement
Rule 28    sentencia -> function_call
Rule 29    sentencia -> assignment_semantic
Rule 30    sentencia -> switch_statement
Rule 31    for -> FOR LKEY loop_program RKEY
Rule 32    for -> FOR comparation_operation LKEY loop_program RKEY
Rule 33    for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
Rule 34    operator_for -> INCREASE
Rule 35    operator_for -> DECREASE
Rule 36    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 37    if_statement -> IF comparation_operation LKEY program RKEY
Rule 38    if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif
Rule 39    if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
Rule 40    if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
Rule 41    conditions_elseif -> else_if
Rule 42    conditions_elseif -> conditions_elseif else_if
Rule 43    else_if -> ELSE IF comparation_operation LKEY program RKEY
Rule 44    switch_statement -> SWITCH expression LKEY case_clauses RKEY
Rule 45    switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
Rule 46    case_clauses -> case_clause case_clauses
Rule 47    case_clauses -> <empty>
Rule 48    case_clause -> CASE value COLON statements
Rule 49    statements -> statement statements
Rule 50    statements -> <empty>
Rule 51    statement -> print
Rule 52    statement -> print_withoutvalue
Rule 53    statement -> def_function
Rule 54    statement -> call_function
Rule 55    statement -> input
Rule 56    statement -> short_assignment
Rule 57    statement -> arithmetic_operation
Rule 58    statement -> direct_arithmetic_operation
Rule 59    statement -> if_statement
Rule 60    statement -> function_call
Rule 61    statement -> switch_statement
Rule 62    statement -> assignment_semantic
Rule 63    statement -> statement
Rule 64    expression -> value
Rule 65    expression -> expression PLUS expression
Rule 66    expression -> expression MINUS expression
Rule 67    expression -> expression TIMES expression
Rule 68    expression -> expression DIVIDE expression
Rule 69    expression -> expression ENTERE_DIVIDE expression
Rule 70    expression -> expression MODULE expression
Rule 71    expression -> expression EQUALEQUAL expression
Rule 72    expression -> expression NOT_EQUAL expression
Rule 73    expression -> expression LESS_EQUAL expression
Rule 74    expression -> expression GREATER_EQUAL expression
Rule 75    expression -> expression LESS expression
Rule 76    expression -> expression GREATER expression
Rule 77    expression -> expression LOGICAL_AND expression
Rule 78    expression -> expression LOGICAL_OR expression
Rule 79    print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
Rule 80    print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
Rule 81    print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
Rule 82    print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
Rule 83    data -> value
Rule 84    data -> IDENTIFIER
Rule 85    data -> data COMMA value
Rule 86    data -> data COMMA IDENTIFIER
Rule 87    print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
Rule 88    print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN
Rule 89    assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
Rule 90    assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
Rule 91    assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
Rule 92    assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
Rule 93    assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
Rule 94    assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
Rule 95    assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
Rule 96    assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
Rule 97    short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value
Rule 98    usable_value -> value
Rule 99    usable_value -> call_function
Rule 100   usable_value -> IDENTIFIER
Rule 101   usable_value -> arithmetic_operation
Rule 102   usable_value -> comparation_operation
Rule 103   direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value
Rule 104   direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value
Rule 105   direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value
Rule 106   direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value
Rule 107   direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value
Rule 108   direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value
Rule 109   direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value
Rule 110   direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value
Rule 111   direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value
Rule 112   direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value
Rule 113   arithmetic_operation -> usable_value PLUS usable_value
Rule 114   arithmetic_operation -> usable_value MINUS usable_value
Rule 115   arithmetic_operation -> usable_value DIVIDE usable_value
Rule 116   arithmetic_operation -> usable_value TIMES usable_value
Rule 117   arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value
Rule 118   arithmetic_operation -> usable_value MODULE usable_value
Rule 119   comparation_operation -> usable_value EQUALEQUAL usable_value
Rule 120   comparation_operation -> usable_value NOT_EQUAL usable_value
Rule 121   comparation_operation -> usable_value LESS_EQUAL usable_value
Rule 122   comparation_operation -> usable_value GREATER_EQUAL usable_value
Rule 123   comparation_operation -> usable_value LESS usable_value
Rule 124   comparation_operation -> usable_value GREATER usable_value
Rule 125   comparation_operation -> usable_value LOGICAL_AND usable_value
Rule 126   comparation_operation -> usable_value LOGICAL_OR usable_value
Rule 127   identifiers -> IDENTIFIER
Rule 128   identifiers -> identifiers COMMA identifiers
Rule 129   rule_comparation -> IDENTIFIER EQUALEQUAL value
Rule 130   rule_comparation -> IDENTIFIER NOT_EQUAL value
Rule 131   rule_comparation -> IDENTIFIER LESS_EQUAL value
Rule 132   rule_comparation -> IDENTIFIER GREATER_EQUAL value
Rule 133   rule_comparation -> IDENTIFIER LESS value
Rule 134   rule_comparation -> IDENTIFIER GREATER value
Rule 135   rule_comparation -> IDENTIFIER LOGICAL_AND value
Rule 136   rule_comparation -> IDENTIFIER LOGICAL_OR value
Rule 137   condition -> value comparation_operation value
Rule 138   condition -> condition LOGICAL_AND condition
Rule 139   condition -> condition LOGICAL_OR condition
Rule 140   condition -> LOGICAL_NOT condition
Rule 141   def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
Rule 142   def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
Rule 143   call_function -> IDENTIFIER LPAREN values RPAREN
Rule 144   parameters -> parameter
Rule 145   parameters -> parameters COMMA parameter
Rule 146   parameter -> IDENTIFIER data_type
Rule 147   values -> value
Rule 148   values -> values COMMA value
Rule 149   value -> STRING
Rule 150   value -> INTEGER
Rule 151   value -> FLOAT
Rule 152   value -> BOOLEAN
Rule 153   value -> IDENTIFIER
Rule 154   data_type -> INTEGER_DATA_TYPE
Rule 155   data_type -> FLOAT_DATA_TYPE
Rule 156   data_type -> BOOLEAN_DATA_TYPE
Rule 157   data_type -> STRING_DATA_TYPE
Rule 158   input -> INPUT LPAREN RPAREN
Rule 159   input -> INPUT LPAREN value RPAREN
Rule 160   input -> INPUT LPAREN identifiers RPAREN

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 
ARROW_FUNCTION_TYPE  : 
ARROW_SEND_RECEIVE   : 
AS                   : 
ASSERT               : 
BITWISE_AND_EQ       : 108
BITWISE_OR_EQ        : 109
BITWISE_XOR          : 
BITWISE_XOR_ASSIGN   : 
BITWISE_XOR_EQ       : 110
BOOLEAN              : 95 96 152
BOOLEAN_DATA_TYPE    : 95 96 156
BREAK                : 15
CASE                 : 48
CLASS                : 
COLON                : 45 48
COMMA                : 81 82 85 86 128 145 148
COMMENT              : 
COMMENT_MULTI        : 
CONST                : 90 92 94 96
CONTINUE             : 16
DECREASE             : 35
DEFAULT              : 45
DEL                  : 
DIVIDE               : 68 115
DIVIDE_EQ            : 106
DOT                  : 79 80 81 82 87 88
DOUBLE_QUOTE         : 
ELIF                 : 
ELLIPSIS             : 
ELSE                 : 39 40 43
ENTERE_DIVIDE        : 69 117
EQUAL                : 89 90 91 92 93 94 95 96
EQUALEQUAL           : 71 119 129
EXCEPT               : 
FALSE                : 
FAT_ARROW            : 
FINALLY              : 
FLOAT                : 91 92 151
FLOAT_DATA_TYPE      : 91 92 155
FMT_FORMAT_STRING    : 
FMT_LIBRARY          : 79 80 81 82 87 88
FOR                  : 31 32 33
FROM                 : 
FUNC                 : 141 142
GLOBAL               : 
GREATER              : 76 124 134
GREATER_EQUAL        : 74 122 132
GREATER_THAN         : 
HEX_NUMBER           : 
IDENTIFIER           : 33 36 84 86 89 90 91 92 93 94 95 96 97 100 103 104 105 106 107 108 109 110 111 112 127 129 130 131 132 133 134 135 136 141 142 143 146 153
IF                   : 37 38 39 40 43
IMPORT               : 
IN                   : 
INCREASE             : 34
INPUT                : 158 159 160
INTEGER              : 89 90 150
INTEGER_DATA_TYPE    : 89 90 154
IS                   : 
LAMBDA               : 
LBRACKET             : 
LEFT_SHIFT_EQ        : 111
LESS                 : 75 123 133
LESS_EQUAL           : 73 121 131
LESS_THAN            : 
LKEY                 : 31 32 33 37 38 39 39 40 40 43 44 45 141 142
LOGICAL_AND          : 77 125 135 138
LOGICAL_NOT          : 140
LOGICAL_OR           : 78 126 136 139
LPAREN               : 36 79 80 81 82 87 88 141 142 143 158 159 160
MINUS                : 66 114
MINUS_EQ             : 104
MODULE               : 70 118
MODULO_EQ            : 107
NONE                 : 
NONLOCAL             : 
NOT                  : 
NOT_EQUAL            : 72 120 130
NULL                 : 
OR                   : 
PASS                 : 17
PERCENT_D            : 
PIPE                 : 
PLUS                 : 65 113
PLUS_EQ              : 103
PRINTF               : 80 81 82 88
PRINTLN              : 79 87
RAISE                : 
RBRACKET             : 
RETURN               : 6 7 9 10
RIGHT_SHIFT_EQ       : 112
RKEY                 : 31 32 33 37 38 39 39 40 40 43 44 45 141 142
RPAREN               : 36 79 80 81 82 87 88 141 142 143 158 159 160
SCIENTIFIC_NOTATION  : 
SEMICOLON            : 33 33
SHORT_VAR_DECL       : 97
STRING               : 80 81 82 93 94 149
STRING_DATA_TYPE     : 93 94 157
SWITCH               : 44 45
TIMES                : 67 116
TIMES_EQ             : 105
TRUE                 : 
TRY                  : 
VAR                  : 89 91 93 95
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arithmetic_operation : 25 57 101
assignment_semantic  : 29 62
call_function        : 22 54 99
case_clause          : 46
case_clauses         : 44 45 46
comparation_operation : 32 33 37 38 39 40 43 102 137
condition            : 138 138 139 139 140
conditions_elseif    : 38 40 42
data                 : 79 82 85 86
data_type            : 142 146
def_function         : 21 53
direct_arithmetic_operation : 26 58
else_if              : 41 42
expression           : 44 45 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 78 78
for                  : 18
func_program         : 8 9 10 141 142
function_call        : 28 60
identifiers          : 128 128 160
if_statement         : 27 59
input                : 23 55
loop                 : 12 14
loop_program         : 3 4 31 32 33 0
loop_reserved        : 2 4
operator_for         : 33
parameter            : 144 145
parameters           : 141 142 145
print                : 19 51
print_withoutvalue   : 20 52
program              : 1 3 5 8 13 14 37 38 39 39 40 40 43
rule_comparation     : 
sentencia            : 11 13
short_assignment     : 24 33 56
statement            : 49 63
statements           : 45 48 49
switch_statement     : 30 61
usable_value         : 7 10 97 113 113 114 114 115 115 116 116 117 117 118 118 119 119 120 120 121 121 122 122 123 123 124 124 125 125 126 126
value                : 48 64 83 85 98 103 104 105 106 107 108 109 110 111 112 129 130 131 132 133 134 135 136 137 137 147 148 159
values               : 36 143 148

Parsing method: LALR

state 0

    (0) S' -> . loop_program
    (1) loop_program -> . program
    (2) loop_program -> . loop_reserved
    (3) loop_program -> . loop_program program
    (4) loop_program -> . loop_program loop_reserved
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (15) loop_reserved -> . BREAK
    (16) loop_reserved -> . CONTINUE
    (17) loop_reserved -> . PASS
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PASS            shift and go to state 8
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    loop_program                   shift and go to state 1
    program                        shift and go to state 2
    loop_reserved                  shift and go to state 3
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 1

    (0) S' -> loop_program .
    (3) loop_program -> loop_program . program
    (4) loop_program -> loop_program . loop_reserved
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (15) loop_reserved -> . BREAK
    (16) loop_reserved -> . CONTINUE
    (17) loop_reserved -> . PASS
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PASS            shift and go to state 8
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    program                        shift and go to state 38
    loop_reserved                  shift and go to state 39
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 2

    (1) loop_program -> program .
    (13) program -> program . sentencia
    (14) program -> program . loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! shift/reduce conflict for FMT_LIBRARY resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    BREAK           reduce using rule 1 (loop_program -> program .)
    CONTINUE        reduce using rule 1 (loop_program -> program .)
    PASS            reduce using rule 1 (loop_program -> program .)
    $end            reduce using rule 1 (loop_program -> program .)
    RKEY            reduce using rule 1 (loop_program -> program .)
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

  ! FMT_LIBRARY     [ reduce using rule 1 (loop_program -> program .) ]
  ! FUNC            [ reduce using rule 1 (loop_program -> program .) ]
  ! IDENTIFIER      [ reduce using rule 1 (loop_program -> program .) ]
  ! INPUT           [ reduce using rule 1 (loop_program -> program .) ]
  ! IF              [ reduce using rule 1 (loop_program -> program .) ]
  ! VAR             [ reduce using rule 1 (loop_program -> program .) ]
  ! CONST           [ reduce using rule 1 (loop_program -> program .) ]
  ! SWITCH          [ reduce using rule 1 (loop_program -> program .) ]
  ! FOR             [ reduce using rule 1 (loop_program -> program .) ]
  ! STRING          [ reduce using rule 1 (loop_program -> program .) ]
  ! INTEGER         [ reduce using rule 1 (loop_program -> program .) ]
  ! FLOAT           [ reduce using rule 1 (loop_program -> program .) ]
  ! BOOLEAN         [ reduce using rule 1 (loop_program -> program .) ]

    sentencia                      shift and go to state 40
    loop                           shift and go to state 41
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 3

    (2) loop_program -> loop_reserved .

    BREAK           reduce using rule 2 (loop_program -> loop_reserved .)
    CONTINUE        reduce using rule 2 (loop_program -> loop_reserved .)
    PASS            reduce using rule 2 (loop_program -> loop_reserved .)
    FMT_LIBRARY     reduce using rule 2 (loop_program -> loop_reserved .)
    FUNC            reduce using rule 2 (loop_program -> loop_reserved .)
    IDENTIFIER      reduce using rule 2 (loop_program -> loop_reserved .)
    INPUT           reduce using rule 2 (loop_program -> loop_reserved .)
    IF              reduce using rule 2 (loop_program -> loop_reserved .)
    VAR             reduce using rule 2 (loop_program -> loop_reserved .)
    CONST           reduce using rule 2 (loop_program -> loop_reserved .)
    SWITCH          reduce using rule 2 (loop_program -> loop_reserved .)
    FOR             reduce using rule 2 (loop_program -> loop_reserved .)
    STRING          reduce using rule 2 (loop_program -> loop_reserved .)
    INTEGER         reduce using rule 2 (loop_program -> loop_reserved .)
    FLOAT           reduce using rule 2 (loop_program -> loop_reserved .)
    BOOLEAN         reduce using rule 2 (loop_program -> loop_reserved .)
    $end            reduce using rule 2 (loop_program -> loop_reserved .)
    RKEY            reduce using rule 2 (loop_program -> loop_reserved .)


state 4

    (11) program -> sentencia .

    FMT_LIBRARY     reduce using rule 11 (program -> sentencia .)
    FUNC            reduce using rule 11 (program -> sentencia .)
    IDENTIFIER      reduce using rule 11 (program -> sentencia .)
    INPUT           reduce using rule 11 (program -> sentencia .)
    IF              reduce using rule 11 (program -> sentencia .)
    VAR             reduce using rule 11 (program -> sentencia .)
    CONST           reduce using rule 11 (program -> sentencia .)
    SWITCH          reduce using rule 11 (program -> sentencia .)
    FOR             reduce using rule 11 (program -> sentencia .)
    STRING          reduce using rule 11 (program -> sentencia .)
    INTEGER         reduce using rule 11 (program -> sentencia .)
    FLOAT           reduce using rule 11 (program -> sentencia .)
    BOOLEAN         reduce using rule 11 (program -> sentencia .)
    BREAK           reduce using rule 11 (program -> sentencia .)
    CONTINUE        reduce using rule 11 (program -> sentencia .)
    PASS            reduce using rule 11 (program -> sentencia .)
    $end            reduce using rule 11 (program -> sentencia .)
    RKEY            reduce using rule 11 (program -> sentencia .)
    RETURN          reduce using rule 11 (program -> sentencia .)


state 5

    (12) program -> loop .

    FMT_LIBRARY     reduce using rule 12 (program -> loop .)
    FUNC            reduce using rule 12 (program -> loop .)
    IDENTIFIER      reduce using rule 12 (program -> loop .)
    INPUT           reduce using rule 12 (program -> loop .)
    IF              reduce using rule 12 (program -> loop .)
    VAR             reduce using rule 12 (program -> loop .)
    CONST           reduce using rule 12 (program -> loop .)
    SWITCH          reduce using rule 12 (program -> loop .)
    FOR             reduce using rule 12 (program -> loop .)
    STRING          reduce using rule 12 (program -> loop .)
    INTEGER         reduce using rule 12 (program -> loop .)
    FLOAT           reduce using rule 12 (program -> loop .)
    BOOLEAN         reduce using rule 12 (program -> loop .)
    BREAK           reduce using rule 12 (program -> loop .)
    CONTINUE        reduce using rule 12 (program -> loop .)
    PASS            reduce using rule 12 (program -> loop .)
    $end            reduce using rule 12 (program -> loop .)
    RKEY            reduce using rule 12 (program -> loop .)
    RETURN          reduce using rule 12 (program -> loop .)


state 6

    (15) loop_reserved -> BREAK .

    BREAK           reduce using rule 15 (loop_reserved -> BREAK .)
    CONTINUE        reduce using rule 15 (loop_reserved -> BREAK .)
    PASS            reduce using rule 15 (loop_reserved -> BREAK .)
    FMT_LIBRARY     reduce using rule 15 (loop_reserved -> BREAK .)
    FUNC            reduce using rule 15 (loop_reserved -> BREAK .)
    IDENTIFIER      reduce using rule 15 (loop_reserved -> BREAK .)
    INPUT           reduce using rule 15 (loop_reserved -> BREAK .)
    IF              reduce using rule 15 (loop_reserved -> BREAK .)
    VAR             reduce using rule 15 (loop_reserved -> BREAK .)
    CONST           reduce using rule 15 (loop_reserved -> BREAK .)
    SWITCH          reduce using rule 15 (loop_reserved -> BREAK .)
    FOR             reduce using rule 15 (loop_reserved -> BREAK .)
    STRING          reduce using rule 15 (loop_reserved -> BREAK .)
    INTEGER         reduce using rule 15 (loop_reserved -> BREAK .)
    FLOAT           reduce using rule 15 (loop_reserved -> BREAK .)
    BOOLEAN         reduce using rule 15 (loop_reserved -> BREAK .)
    $end            reduce using rule 15 (loop_reserved -> BREAK .)
    RKEY            reduce using rule 15 (loop_reserved -> BREAK .)


state 7

    (16) loop_reserved -> CONTINUE .

    BREAK           reduce using rule 16 (loop_reserved -> CONTINUE .)
    CONTINUE        reduce using rule 16 (loop_reserved -> CONTINUE .)
    PASS            reduce using rule 16 (loop_reserved -> CONTINUE .)
    FMT_LIBRARY     reduce using rule 16 (loop_reserved -> CONTINUE .)
    FUNC            reduce using rule 16 (loop_reserved -> CONTINUE .)
    IDENTIFIER      reduce using rule 16 (loop_reserved -> CONTINUE .)
    INPUT           reduce using rule 16 (loop_reserved -> CONTINUE .)
    IF              reduce using rule 16 (loop_reserved -> CONTINUE .)
    VAR             reduce using rule 16 (loop_reserved -> CONTINUE .)
    CONST           reduce using rule 16 (loop_reserved -> CONTINUE .)
    SWITCH          reduce using rule 16 (loop_reserved -> CONTINUE .)
    FOR             reduce using rule 16 (loop_reserved -> CONTINUE .)
    STRING          reduce using rule 16 (loop_reserved -> CONTINUE .)
    INTEGER         reduce using rule 16 (loop_reserved -> CONTINUE .)
    FLOAT           reduce using rule 16 (loop_reserved -> CONTINUE .)
    BOOLEAN         reduce using rule 16 (loop_reserved -> CONTINUE .)
    $end            reduce using rule 16 (loop_reserved -> CONTINUE .)
    RKEY            reduce using rule 16 (loop_reserved -> CONTINUE .)


state 8

    (17) loop_reserved -> PASS .

    BREAK           reduce using rule 17 (loop_reserved -> PASS .)
    CONTINUE        reduce using rule 17 (loop_reserved -> PASS .)
    PASS            reduce using rule 17 (loop_reserved -> PASS .)
    FMT_LIBRARY     reduce using rule 17 (loop_reserved -> PASS .)
    FUNC            reduce using rule 17 (loop_reserved -> PASS .)
    IDENTIFIER      reduce using rule 17 (loop_reserved -> PASS .)
    INPUT           reduce using rule 17 (loop_reserved -> PASS .)
    IF              reduce using rule 17 (loop_reserved -> PASS .)
    VAR             reduce using rule 17 (loop_reserved -> PASS .)
    CONST           reduce using rule 17 (loop_reserved -> PASS .)
    SWITCH          reduce using rule 17 (loop_reserved -> PASS .)
    FOR             reduce using rule 17 (loop_reserved -> PASS .)
    STRING          reduce using rule 17 (loop_reserved -> PASS .)
    INTEGER         reduce using rule 17 (loop_reserved -> PASS .)
    FLOAT           reduce using rule 17 (loop_reserved -> PASS .)
    BOOLEAN         reduce using rule 17 (loop_reserved -> PASS .)
    $end            reduce using rule 17 (loop_reserved -> PASS .)
    RKEY            reduce using rule 17 (loop_reserved -> PASS .)


state 9

    (19) sentencia -> print .

    FMT_LIBRARY     reduce using rule 19 (sentencia -> print .)
    FUNC            reduce using rule 19 (sentencia -> print .)
    IDENTIFIER      reduce using rule 19 (sentencia -> print .)
    INPUT           reduce using rule 19 (sentencia -> print .)
    IF              reduce using rule 19 (sentencia -> print .)
    VAR             reduce using rule 19 (sentencia -> print .)
    CONST           reduce using rule 19 (sentencia -> print .)
    SWITCH          reduce using rule 19 (sentencia -> print .)
    FOR             reduce using rule 19 (sentencia -> print .)
    STRING          reduce using rule 19 (sentencia -> print .)
    INTEGER         reduce using rule 19 (sentencia -> print .)
    FLOAT           reduce using rule 19 (sentencia -> print .)
    BOOLEAN         reduce using rule 19 (sentencia -> print .)
    BREAK           reduce using rule 19 (sentencia -> print .)
    CONTINUE        reduce using rule 19 (sentencia -> print .)
    PASS            reduce using rule 19 (sentencia -> print .)
    $end            reduce using rule 19 (sentencia -> print .)
    RKEY            reduce using rule 19 (sentencia -> print .)
    RETURN          reduce using rule 19 (sentencia -> print .)


state 10

    (20) sentencia -> print_withoutvalue .

    FMT_LIBRARY     reduce using rule 20 (sentencia -> print_withoutvalue .)
    FUNC            reduce using rule 20 (sentencia -> print_withoutvalue .)
    IDENTIFIER      reduce using rule 20 (sentencia -> print_withoutvalue .)
    INPUT           reduce using rule 20 (sentencia -> print_withoutvalue .)
    IF              reduce using rule 20 (sentencia -> print_withoutvalue .)
    VAR             reduce using rule 20 (sentencia -> print_withoutvalue .)
    CONST           reduce using rule 20 (sentencia -> print_withoutvalue .)
    SWITCH          reduce using rule 20 (sentencia -> print_withoutvalue .)
    FOR             reduce using rule 20 (sentencia -> print_withoutvalue .)
    STRING          reduce using rule 20 (sentencia -> print_withoutvalue .)
    INTEGER         reduce using rule 20 (sentencia -> print_withoutvalue .)
    FLOAT           reduce using rule 20 (sentencia -> print_withoutvalue .)
    BOOLEAN         reduce using rule 20 (sentencia -> print_withoutvalue .)
    BREAK           reduce using rule 20 (sentencia -> print_withoutvalue .)
    CONTINUE        reduce using rule 20 (sentencia -> print_withoutvalue .)
    PASS            reduce using rule 20 (sentencia -> print_withoutvalue .)
    $end            reduce using rule 20 (sentencia -> print_withoutvalue .)
    RKEY            reduce using rule 20 (sentencia -> print_withoutvalue .)
    RETURN          reduce using rule 20 (sentencia -> print_withoutvalue .)


state 11

    (21) sentencia -> def_function .

    FMT_LIBRARY     reduce using rule 21 (sentencia -> def_function .)
    FUNC            reduce using rule 21 (sentencia -> def_function .)
    IDENTIFIER      reduce using rule 21 (sentencia -> def_function .)
    INPUT           reduce using rule 21 (sentencia -> def_function .)
    IF              reduce using rule 21 (sentencia -> def_function .)
    VAR             reduce using rule 21 (sentencia -> def_function .)
    CONST           reduce using rule 21 (sentencia -> def_function .)
    SWITCH          reduce using rule 21 (sentencia -> def_function .)
    FOR             reduce using rule 21 (sentencia -> def_function .)
    STRING          reduce using rule 21 (sentencia -> def_function .)
    INTEGER         reduce using rule 21 (sentencia -> def_function .)
    FLOAT           reduce using rule 21 (sentencia -> def_function .)
    BOOLEAN         reduce using rule 21 (sentencia -> def_function .)
    BREAK           reduce using rule 21 (sentencia -> def_function .)
    CONTINUE        reduce using rule 21 (sentencia -> def_function .)
    PASS            reduce using rule 21 (sentencia -> def_function .)
    $end            reduce using rule 21 (sentencia -> def_function .)
    RKEY            reduce using rule 21 (sentencia -> def_function .)
    RETURN          reduce using rule 21 (sentencia -> def_function .)


state 12

    (22) sentencia -> call_function .
    (99) usable_value -> call_function .

    FMT_LIBRARY     reduce using rule 22 (sentencia -> call_function .)
    FUNC            reduce using rule 22 (sentencia -> call_function .)
    IDENTIFIER      reduce using rule 22 (sentencia -> call_function .)
    INPUT           reduce using rule 22 (sentencia -> call_function .)
    IF              reduce using rule 22 (sentencia -> call_function .)
    VAR             reduce using rule 22 (sentencia -> call_function .)
    CONST           reduce using rule 22 (sentencia -> call_function .)
    SWITCH          reduce using rule 22 (sentencia -> call_function .)
    FOR             reduce using rule 22 (sentencia -> call_function .)
    STRING          reduce using rule 22 (sentencia -> call_function .)
    INTEGER         reduce using rule 22 (sentencia -> call_function .)
    FLOAT           reduce using rule 22 (sentencia -> call_function .)
    BOOLEAN         reduce using rule 22 (sentencia -> call_function .)
    BREAK           reduce using rule 22 (sentencia -> call_function .)
    CONTINUE        reduce using rule 22 (sentencia -> call_function .)
    PASS            reduce using rule 22 (sentencia -> call_function .)
    $end            reduce using rule 22 (sentencia -> call_function .)
    RKEY            reduce using rule 22 (sentencia -> call_function .)
    RETURN          reduce using rule 22 (sentencia -> call_function .)
    PLUS            reduce using rule 99 (usable_value -> call_function .)
    MINUS           reduce using rule 99 (usable_value -> call_function .)
    DIVIDE          reduce using rule 99 (usable_value -> call_function .)
    TIMES           reduce using rule 99 (usable_value -> call_function .)
    ENTERE_DIVIDE   reduce using rule 99 (usable_value -> call_function .)
    MODULE          reduce using rule 99 (usable_value -> call_function .)
    EQUALEQUAL      reduce using rule 99 (usable_value -> call_function .)
    NOT_EQUAL       reduce using rule 99 (usable_value -> call_function .)
    LESS_EQUAL      reduce using rule 99 (usable_value -> call_function .)
    GREATER_EQUAL   reduce using rule 99 (usable_value -> call_function .)
    LESS            reduce using rule 99 (usable_value -> call_function .)
    GREATER         reduce using rule 99 (usable_value -> call_function .)
    LOGICAL_AND     reduce using rule 99 (usable_value -> call_function .)
    LOGICAL_OR      reduce using rule 99 (usable_value -> call_function .)


state 13

    (23) sentencia -> input .

    FMT_LIBRARY     reduce using rule 23 (sentencia -> input .)
    FUNC            reduce using rule 23 (sentencia -> input .)
    IDENTIFIER      reduce using rule 23 (sentencia -> input .)
    INPUT           reduce using rule 23 (sentencia -> input .)
    IF              reduce using rule 23 (sentencia -> input .)
    VAR             reduce using rule 23 (sentencia -> input .)
    CONST           reduce using rule 23 (sentencia -> input .)
    SWITCH          reduce using rule 23 (sentencia -> input .)
    FOR             reduce using rule 23 (sentencia -> input .)
    STRING          reduce using rule 23 (sentencia -> input .)
    INTEGER         reduce using rule 23 (sentencia -> input .)
    FLOAT           reduce using rule 23 (sentencia -> input .)
    BOOLEAN         reduce using rule 23 (sentencia -> input .)
    BREAK           reduce using rule 23 (sentencia -> input .)
    CONTINUE        reduce using rule 23 (sentencia -> input .)
    PASS            reduce using rule 23 (sentencia -> input .)
    $end            reduce using rule 23 (sentencia -> input .)
    RKEY            reduce using rule 23 (sentencia -> input .)
    RETURN          reduce using rule 23 (sentencia -> input .)


state 14

    (24) sentencia -> short_assignment .

    FMT_LIBRARY     reduce using rule 24 (sentencia -> short_assignment .)
    FUNC            reduce using rule 24 (sentencia -> short_assignment .)
    IDENTIFIER      reduce using rule 24 (sentencia -> short_assignment .)
    INPUT           reduce using rule 24 (sentencia -> short_assignment .)
    IF              reduce using rule 24 (sentencia -> short_assignment .)
    VAR             reduce using rule 24 (sentencia -> short_assignment .)
    CONST           reduce using rule 24 (sentencia -> short_assignment .)
    SWITCH          reduce using rule 24 (sentencia -> short_assignment .)
    FOR             reduce using rule 24 (sentencia -> short_assignment .)
    STRING          reduce using rule 24 (sentencia -> short_assignment .)
    INTEGER         reduce using rule 24 (sentencia -> short_assignment .)
    FLOAT           reduce using rule 24 (sentencia -> short_assignment .)
    BOOLEAN         reduce using rule 24 (sentencia -> short_assignment .)
    BREAK           reduce using rule 24 (sentencia -> short_assignment .)
    CONTINUE        reduce using rule 24 (sentencia -> short_assignment .)
    PASS            reduce using rule 24 (sentencia -> short_assignment .)
    $end            reduce using rule 24 (sentencia -> short_assignment .)
    RKEY            reduce using rule 24 (sentencia -> short_assignment .)
    RETURN          reduce using rule 24 (sentencia -> short_assignment .)


state 15

    (25) sentencia -> arithmetic_operation .
    (101) usable_value -> arithmetic_operation .

    FMT_LIBRARY     reduce using rule 25 (sentencia -> arithmetic_operation .)
    FUNC            reduce using rule 25 (sentencia -> arithmetic_operation .)
    IDENTIFIER      reduce using rule 25 (sentencia -> arithmetic_operation .)
    INPUT           reduce using rule 25 (sentencia -> arithmetic_operation .)
    IF              reduce using rule 25 (sentencia -> arithmetic_operation .)
    VAR             reduce using rule 25 (sentencia -> arithmetic_operation .)
    CONST           reduce using rule 25 (sentencia -> arithmetic_operation .)
    SWITCH          reduce using rule 25 (sentencia -> arithmetic_operation .)
    FOR             reduce using rule 25 (sentencia -> arithmetic_operation .)
    STRING          reduce using rule 25 (sentencia -> arithmetic_operation .)
    INTEGER         reduce using rule 25 (sentencia -> arithmetic_operation .)
    FLOAT           reduce using rule 25 (sentencia -> arithmetic_operation .)
    BOOLEAN         reduce using rule 25 (sentencia -> arithmetic_operation .)
    BREAK           reduce using rule 25 (sentencia -> arithmetic_operation .)
    CONTINUE        reduce using rule 25 (sentencia -> arithmetic_operation .)
    PASS            reduce using rule 25 (sentencia -> arithmetic_operation .)
    $end            reduce using rule 25 (sentencia -> arithmetic_operation .)
    RKEY            reduce using rule 25 (sentencia -> arithmetic_operation .)
    RETURN          reduce using rule 25 (sentencia -> arithmetic_operation .)
    PLUS            reduce using rule 101 (usable_value -> arithmetic_operation .)
    MINUS           reduce using rule 101 (usable_value -> arithmetic_operation .)
    DIVIDE          reduce using rule 101 (usable_value -> arithmetic_operation .)
    TIMES           reduce using rule 101 (usable_value -> arithmetic_operation .)
    ENTERE_DIVIDE   reduce using rule 101 (usable_value -> arithmetic_operation .)
    MODULE          reduce using rule 101 (usable_value -> arithmetic_operation .)
    EQUALEQUAL      reduce using rule 101 (usable_value -> arithmetic_operation .)
    NOT_EQUAL       reduce using rule 101 (usable_value -> arithmetic_operation .)
    LESS_EQUAL      reduce using rule 101 (usable_value -> arithmetic_operation .)
    GREATER_EQUAL   reduce using rule 101 (usable_value -> arithmetic_operation .)
    LESS            reduce using rule 101 (usable_value -> arithmetic_operation .)
    GREATER         reduce using rule 101 (usable_value -> arithmetic_operation .)
    LOGICAL_AND     reduce using rule 101 (usable_value -> arithmetic_operation .)
    LOGICAL_OR      reduce using rule 101 (usable_value -> arithmetic_operation .)


state 16

    (26) sentencia -> direct_arithmetic_operation .

    FMT_LIBRARY     reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    FUNC            reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    IDENTIFIER      reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    INPUT           reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    IF              reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    VAR             reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    CONST           reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    SWITCH          reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    FOR             reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    STRING          reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    INTEGER         reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    FLOAT           reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    BOOLEAN         reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    BREAK           reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    CONTINUE        reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    PASS            reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    $end            reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    RKEY            reduce using rule 26 (sentencia -> direct_arithmetic_operation .)
    RETURN          reduce using rule 26 (sentencia -> direct_arithmetic_operation .)


state 17

    (27) sentencia -> if_statement .

    FMT_LIBRARY     reduce using rule 27 (sentencia -> if_statement .)
    FUNC            reduce using rule 27 (sentencia -> if_statement .)
    IDENTIFIER      reduce using rule 27 (sentencia -> if_statement .)
    INPUT           reduce using rule 27 (sentencia -> if_statement .)
    IF              reduce using rule 27 (sentencia -> if_statement .)
    VAR             reduce using rule 27 (sentencia -> if_statement .)
    CONST           reduce using rule 27 (sentencia -> if_statement .)
    SWITCH          reduce using rule 27 (sentencia -> if_statement .)
    FOR             reduce using rule 27 (sentencia -> if_statement .)
    STRING          reduce using rule 27 (sentencia -> if_statement .)
    INTEGER         reduce using rule 27 (sentencia -> if_statement .)
    FLOAT           reduce using rule 27 (sentencia -> if_statement .)
    BOOLEAN         reduce using rule 27 (sentencia -> if_statement .)
    BREAK           reduce using rule 27 (sentencia -> if_statement .)
    CONTINUE        reduce using rule 27 (sentencia -> if_statement .)
    PASS            reduce using rule 27 (sentencia -> if_statement .)
    $end            reduce using rule 27 (sentencia -> if_statement .)
    RKEY            reduce using rule 27 (sentencia -> if_statement .)
    RETURN          reduce using rule 27 (sentencia -> if_statement .)


state 18

    (28) sentencia -> function_call .

    FMT_LIBRARY     reduce using rule 28 (sentencia -> function_call .)
    FUNC            reduce using rule 28 (sentencia -> function_call .)
    IDENTIFIER      reduce using rule 28 (sentencia -> function_call .)
    INPUT           reduce using rule 28 (sentencia -> function_call .)
    IF              reduce using rule 28 (sentencia -> function_call .)
    VAR             reduce using rule 28 (sentencia -> function_call .)
    CONST           reduce using rule 28 (sentencia -> function_call .)
    SWITCH          reduce using rule 28 (sentencia -> function_call .)
    FOR             reduce using rule 28 (sentencia -> function_call .)
    STRING          reduce using rule 28 (sentencia -> function_call .)
    INTEGER         reduce using rule 28 (sentencia -> function_call .)
    FLOAT           reduce using rule 28 (sentencia -> function_call .)
    BOOLEAN         reduce using rule 28 (sentencia -> function_call .)
    BREAK           reduce using rule 28 (sentencia -> function_call .)
    CONTINUE        reduce using rule 28 (sentencia -> function_call .)
    PASS            reduce using rule 28 (sentencia -> function_call .)
    $end            reduce using rule 28 (sentencia -> function_call .)
    RKEY            reduce using rule 28 (sentencia -> function_call .)
    RETURN          reduce using rule 28 (sentencia -> function_call .)


state 19

    (29) sentencia -> assignment_semantic .

    FMT_LIBRARY     reduce using rule 29 (sentencia -> assignment_semantic .)
    FUNC            reduce using rule 29 (sentencia -> assignment_semantic .)
    IDENTIFIER      reduce using rule 29 (sentencia -> assignment_semantic .)
    INPUT           reduce using rule 29 (sentencia -> assignment_semantic .)
    IF              reduce using rule 29 (sentencia -> assignment_semantic .)
    VAR             reduce using rule 29 (sentencia -> assignment_semantic .)
    CONST           reduce using rule 29 (sentencia -> assignment_semantic .)
    SWITCH          reduce using rule 29 (sentencia -> assignment_semantic .)
    FOR             reduce using rule 29 (sentencia -> assignment_semantic .)
    STRING          reduce using rule 29 (sentencia -> assignment_semantic .)
    INTEGER         reduce using rule 29 (sentencia -> assignment_semantic .)
    FLOAT           reduce using rule 29 (sentencia -> assignment_semantic .)
    BOOLEAN         reduce using rule 29 (sentencia -> assignment_semantic .)
    BREAK           reduce using rule 29 (sentencia -> assignment_semantic .)
    CONTINUE        reduce using rule 29 (sentencia -> assignment_semantic .)
    PASS            reduce using rule 29 (sentencia -> assignment_semantic .)
    $end            reduce using rule 29 (sentencia -> assignment_semantic .)
    RKEY            reduce using rule 29 (sentencia -> assignment_semantic .)
    RETURN          reduce using rule 29 (sentencia -> assignment_semantic .)


state 20

    (30) sentencia -> switch_statement .

    FMT_LIBRARY     reduce using rule 30 (sentencia -> switch_statement .)
    FUNC            reduce using rule 30 (sentencia -> switch_statement .)
    IDENTIFIER      reduce using rule 30 (sentencia -> switch_statement .)
    INPUT           reduce using rule 30 (sentencia -> switch_statement .)
    IF              reduce using rule 30 (sentencia -> switch_statement .)
    VAR             reduce using rule 30 (sentencia -> switch_statement .)
    CONST           reduce using rule 30 (sentencia -> switch_statement .)
    SWITCH          reduce using rule 30 (sentencia -> switch_statement .)
    FOR             reduce using rule 30 (sentencia -> switch_statement .)
    STRING          reduce using rule 30 (sentencia -> switch_statement .)
    INTEGER         reduce using rule 30 (sentencia -> switch_statement .)
    FLOAT           reduce using rule 30 (sentencia -> switch_statement .)
    BOOLEAN         reduce using rule 30 (sentencia -> switch_statement .)
    BREAK           reduce using rule 30 (sentencia -> switch_statement .)
    CONTINUE        reduce using rule 30 (sentencia -> switch_statement .)
    PASS            reduce using rule 30 (sentencia -> switch_statement .)
    $end            reduce using rule 30 (sentencia -> switch_statement .)
    RKEY            reduce using rule 30 (sentencia -> switch_statement .)
    RETURN          reduce using rule 30 (sentencia -> switch_statement .)


state 21

    (18) loop -> for .

    FMT_LIBRARY     reduce using rule 18 (loop -> for .)
    FUNC            reduce using rule 18 (loop -> for .)
    IDENTIFIER      reduce using rule 18 (loop -> for .)
    INPUT           reduce using rule 18 (loop -> for .)
    IF              reduce using rule 18 (loop -> for .)
    VAR             reduce using rule 18 (loop -> for .)
    CONST           reduce using rule 18 (loop -> for .)
    SWITCH          reduce using rule 18 (loop -> for .)
    FOR             reduce using rule 18 (loop -> for .)
    STRING          reduce using rule 18 (loop -> for .)
    INTEGER         reduce using rule 18 (loop -> for .)
    FLOAT           reduce using rule 18 (loop -> for .)
    BOOLEAN         reduce using rule 18 (loop -> for .)
    BREAK           reduce using rule 18 (loop -> for .)
    CONTINUE        reduce using rule 18 (loop -> for .)
    PASS            reduce using rule 18 (loop -> for .)
    $end            reduce using rule 18 (loop -> for .)
    RKEY            reduce using rule 18 (loop -> for .)
    RETURN          reduce using rule 18 (loop -> for .)


state 22

    (79) print -> FMT_LIBRARY . DOT PRINTLN LPAREN data RPAREN
    (80) print -> FMT_LIBRARY . DOT PRINTF LPAREN STRING RPAREN
    (81) print -> FMT_LIBRARY . DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> FMT_LIBRARY . DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> FMT_LIBRARY . DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> FMT_LIBRARY . DOT PRINTF LPAREN RPAREN

    DOT             shift and go to state 42


state 23

    (149) value -> STRING .

    PLUS            reduce using rule 149 (value -> STRING .)
    MINUS           reduce using rule 149 (value -> STRING .)
    DIVIDE          reduce using rule 149 (value -> STRING .)
    TIMES           reduce using rule 149 (value -> STRING .)
    ENTERE_DIVIDE   reduce using rule 149 (value -> STRING .)
    MODULE          reduce using rule 149 (value -> STRING .)
    EQUALEQUAL      reduce using rule 149 (value -> STRING .)
    NOT_EQUAL       reduce using rule 149 (value -> STRING .)
    LESS_EQUAL      reduce using rule 149 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 149 (value -> STRING .)
    LESS            reduce using rule 149 (value -> STRING .)
    GREATER         reduce using rule 149 (value -> STRING .)
    LOGICAL_AND     reduce using rule 149 (value -> STRING .)
    LOGICAL_OR      reduce using rule 149 (value -> STRING .)
    LKEY            reduce using rule 149 (value -> STRING .)
    RPAREN          reduce using rule 149 (value -> STRING .)
    COMMA           reduce using rule 149 (value -> STRING .)
    FMT_LIBRARY     reduce using rule 149 (value -> STRING .)
    FUNC            reduce using rule 149 (value -> STRING .)
    IDENTIFIER      reduce using rule 149 (value -> STRING .)
    INPUT           reduce using rule 149 (value -> STRING .)
    IF              reduce using rule 149 (value -> STRING .)
    VAR             reduce using rule 149 (value -> STRING .)
    CONST           reduce using rule 149 (value -> STRING .)
    SWITCH          reduce using rule 149 (value -> STRING .)
    FOR             reduce using rule 149 (value -> STRING .)
    STRING          reduce using rule 149 (value -> STRING .)
    INTEGER         reduce using rule 149 (value -> STRING .)
    FLOAT           reduce using rule 149 (value -> STRING .)
    BOOLEAN         reduce using rule 149 (value -> STRING .)
    BREAK           reduce using rule 149 (value -> STRING .)
    CONTINUE        reduce using rule 149 (value -> STRING .)
    PASS            reduce using rule 149 (value -> STRING .)
    $end            reduce using rule 149 (value -> STRING .)
    RKEY            reduce using rule 149 (value -> STRING .)
    SEMICOLON       reduce using rule 149 (value -> STRING .)
    RETURN          reduce using rule 149 (value -> STRING .)
    CASE            reduce using rule 149 (value -> STRING .)
    DEFAULT         reduce using rule 149 (value -> STRING .)
    COLON           reduce using rule 149 (value -> STRING .)


state 24

    (141) def_function -> FUNC . IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> FUNC . IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY

    IDENTIFIER      shift and go to state 43


state 25

    (143) call_function -> IDENTIFIER . LPAREN values RPAREN
    (97) short_assignment -> IDENTIFIER . SHORT_VAR_DECL usable_value
    (103) direct_arithmetic_operation -> IDENTIFIER . PLUS_EQ value
    (104) direct_arithmetic_operation -> IDENTIFIER . MINUS_EQ value
    (105) direct_arithmetic_operation -> IDENTIFIER . TIMES_EQ value
    (106) direct_arithmetic_operation -> IDENTIFIER . DIVIDE_EQ value
    (107) direct_arithmetic_operation -> IDENTIFIER . MODULO_EQ value
    (108) direct_arithmetic_operation -> IDENTIFIER . BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> IDENTIFIER . BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> IDENTIFIER . BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> IDENTIFIER . LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> IDENTIFIER . RIGHT_SHIFT_EQ value
    (36) function_call -> IDENTIFIER . LPAREN values RPAREN
    (100) usable_value -> IDENTIFIER .
    (153) value -> IDENTIFIER .

  ! reduce/reduce conflict for PLUS resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for ENTERE_DIVIDE resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for MODULE resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 100 (usable_value -> IDENTIFIER .)
    LPAREN          shift and go to state 44
    SHORT_VAR_DECL  shift and go to state 45
    PLUS_EQ         shift and go to state 46
    MINUS_EQ        shift and go to state 47
    TIMES_EQ        shift and go to state 48
    DIVIDE_EQ       shift and go to state 49
    MODULO_EQ       shift and go to state 50
    BITWISE_AND_EQ  shift and go to state 51
    BITWISE_OR_EQ   shift and go to state 52
    BITWISE_XOR_EQ  shift and go to state 53
    LEFT_SHIFT_EQ   shift and go to state 54
    RIGHT_SHIFT_EQ  shift and go to state 55
    PLUS            reduce using rule 100 (usable_value -> IDENTIFIER .)
    MINUS           reduce using rule 100 (usable_value -> IDENTIFIER .)
    DIVIDE          reduce using rule 100 (usable_value -> IDENTIFIER .)
    TIMES           reduce using rule 100 (usable_value -> IDENTIFIER .)
    ENTERE_DIVIDE   reduce using rule 100 (usable_value -> IDENTIFIER .)
    MODULE          reduce using rule 100 (usable_value -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 100 (usable_value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 100 (usable_value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 100 (usable_value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 100 (usable_value -> IDENTIFIER .)
    LESS            reduce using rule 100 (usable_value -> IDENTIFIER .)
    GREATER         reduce using rule 100 (usable_value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 100 (usable_value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 100 (usable_value -> IDENTIFIER .)

  ! PLUS            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! MODULE          [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! EQUALEQUAL      [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! NOT_EQUAL       [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LESS_EQUAL      [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! GREATER_EQUAL   [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LESS            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! GREATER         [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LOGICAL_AND     [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LOGICAL_OR      [ reduce using rule 153 (value -> IDENTIFIER .) ]


state 26

    (158) input -> INPUT . LPAREN RPAREN
    (159) input -> INPUT . LPAREN value RPAREN
    (160) input -> INPUT . LPAREN identifiers RPAREN

    LPAREN          shift and go to state 56


state 27

    (98) usable_value -> value .

    PLUS            reduce using rule 98 (usable_value -> value .)
    MINUS           reduce using rule 98 (usable_value -> value .)
    DIVIDE          reduce using rule 98 (usable_value -> value .)
    TIMES           reduce using rule 98 (usable_value -> value .)
    ENTERE_DIVIDE   reduce using rule 98 (usable_value -> value .)
    MODULE          reduce using rule 98 (usable_value -> value .)
    EQUALEQUAL      reduce using rule 98 (usable_value -> value .)
    NOT_EQUAL       reduce using rule 98 (usable_value -> value .)
    LESS_EQUAL      reduce using rule 98 (usable_value -> value .)
    GREATER_EQUAL   reduce using rule 98 (usable_value -> value .)
    LESS            reduce using rule 98 (usable_value -> value .)
    GREATER         reduce using rule 98 (usable_value -> value .)
    LOGICAL_AND     reduce using rule 98 (usable_value -> value .)
    LOGICAL_OR      reduce using rule 98 (usable_value -> value .)
    FMT_LIBRARY     reduce using rule 98 (usable_value -> value .)
    FUNC            reduce using rule 98 (usable_value -> value .)
    IDENTIFIER      reduce using rule 98 (usable_value -> value .)
    INPUT           reduce using rule 98 (usable_value -> value .)
    IF              reduce using rule 98 (usable_value -> value .)
    VAR             reduce using rule 98 (usable_value -> value .)
    CONST           reduce using rule 98 (usable_value -> value .)
    SWITCH          reduce using rule 98 (usable_value -> value .)
    FOR             reduce using rule 98 (usable_value -> value .)
    STRING          reduce using rule 98 (usable_value -> value .)
    INTEGER         reduce using rule 98 (usable_value -> value .)
    FLOAT           reduce using rule 98 (usable_value -> value .)
    BOOLEAN         reduce using rule 98 (usable_value -> value .)
    BREAK           reduce using rule 98 (usable_value -> value .)
    CONTINUE        reduce using rule 98 (usable_value -> value .)
    PASS            reduce using rule 98 (usable_value -> value .)
    $end            reduce using rule 98 (usable_value -> value .)
    RKEY            reduce using rule 98 (usable_value -> value .)
    SEMICOLON       reduce using rule 98 (usable_value -> value .)
    RETURN          reduce using rule 98 (usable_value -> value .)
    CASE            reduce using rule 98 (usable_value -> value .)
    DEFAULT         reduce using rule 98 (usable_value -> value .)
    LKEY            reduce using rule 98 (usable_value -> value .)


state 28

    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70


state 29

    (37) if_statement -> IF . comparation_operation LKEY program RKEY
    (38) if_statement -> IF . comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> IF . comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> IF . comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 71
    usable_value                   shift and go to state 72
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75

state 30

    (102) usable_value -> comparation_operation .

    PLUS            reduce using rule 102 (usable_value -> comparation_operation .)
    MINUS           reduce using rule 102 (usable_value -> comparation_operation .)
    DIVIDE          reduce using rule 102 (usable_value -> comparation_operation .)
    TIMES           reduce using rule 102 (usable_value -> comparation_operation .)
    ENTERE_DIVIDE   reduce using rule 102 (usable_value -> comparation_operation .)
    MODULE          reduce using rule 102 (usable_value -> comparation_operation .)
    EQUALEQUAL      reduce using rule 102 (usable_value -> comparation_operation .)
    NOT_EQUAL       reduce using rule 102 (usable_value -> comparation_operation .)
    LESS_EQUAL      reduce using rule 102 (usable_value -> comparation_operation .)
    GREATER_EQUAL   reduce using rule 102 (usable_value -> comparation_operation .)
    LESS            reduce using rule 102 (usable_value -> comparation_operation .)
    GREATER         reduce using rule 102 (usable_value -> comparation_operation .)
    LOGICAL_AND     reduce using rule 102 (usable_value -> comparation_operation .)
    LOGICAL_OR      reduce using rule 102 (usable_value -> comparation_operation .)
    FMT_LIBRARY     reduce using rule 102 (usable_value -> comparation_operation .)
    FUNC            reduce using rule 102 (usable_value -> comparation_operation .)
    IDENTIFIER      reduce using rule 102 (usable_value -> comparation_operation .)
    INPUT           reduce using rule 102 (usable_value -> comparation_operation .)
    IF              reduce using rule 102 (usable_value -> comparation_operation .)
    VAR             reduce using rule 102 (usable_value -> comparation_operation .)
    CONST           reduce using rule 102 (usable_value -> comparation_operation .)
    SWITCH          reduce using rule 102 (usable_value -> comparation_operation .)
    FOR             reduce using rule 102 (usable_value -> comparation_operation .)
    STRING          reduce using rule 102 (usable_value -> comparation_operation .)
    INTEGER         reduce using rule 102 (usable_value -> comparation_operation .)
    FLOAT           reduce using rule 102 (usable_value -> comparation_operation .)
    BOOLEAN         reduce using rule 102 (usable_value -> comparation_operation .)
    BREAK           reduce using rule 102 (usable_value -> comparation_operation .)
    CONTINUE        reduce using rule 102 (usable_value -> comparation_operation .)
    PASS            reduce using rule 102 (usable_value -> comparation_operation .)
    $end            reduce using rule 102 (usable_value -> comparation_operation .)
    RKEY            reduce using rule 102 (usable_value -> comparation_operation .)
    SEMICOLON       reduce using rule 102 (usable_value -> comparation_operation .)
    RETURN          reduce using rule 102 (usable_value -> comparation_operation .)
    CASE            reduce using rule 102 (usable_value -> comparation_operation .)
    DEFAULT         reduce using rule 102 (usable_value -> comparation_operation .)
    LKEY            reduce using rule 102 (usable_value -> comparation_operation .)


state 31

    (89) assignment_semantic -> VAR . IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> VAR . IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> VAR . IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> VAR . IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN

    IDENTIFIER      shift and go to state 76


state 32

    (150) value -> INTEGER .

    PLUS            reduce using rule 150 (value -> INTEGER .)
    MINUS           reduce using rule 150 (value -> INTEGER .)
    DIVIDE          reduce using rule 150 (value -> INTEGER .)
    TIMES           reduce using rule 150 (value -> INTEGER .)
    ENTERE_DIVIDE   reduce using rule 150 (value -> INTEGER .)
    MODULE          reduce using rule 150 (value -> INTEGER .)
    EQUALEQUAL      reduce using rule 150 (value -> INTEGER .)
    NOT_EQUAL       reduce using rule 150 (value -> INTEGER .)
    LESS_EQUAL      reduce using rule 150 (value -> INTEGER .)
    GREATER_EQUAL   reduce using rule 150 (value -> INTEGER .)
    LESS            reduce using rule 150 (value -> INTEGER .)
    GREATER         reduce using rule 150 (value -> INTEGER .)
    LOGICAL_AND     reduce using rule 150 (value -> INTEGER .)
    LOGICAL_OR      reduce using rule 150 (value -> INTEGER .)
    LKEY            reduce using rule 150 (value -> INTEGER .)
    RPAREN          reduce using rule 150 (value -> INTEGER .)
    COMMA           reduce using rule 150 (value -> INTEGER .)
    FMT_LIBRARY     reduce using rule 150 (value -> INTEGER .)
    FUNC            reduce using rule 150 (value -> INTEGER .)
    IDENTIFIER      reduce using rule 150 (value -> INTEGER .)
    INPUT           reduce using rule 150 (value -> INTEGER .)
    IF              reduce using rule 150 (value -> INTEGER .)
    VAR             reduce using rule 150 (value -> INTEGER .)
    CONST           reduce using rule 150 (value -> INTEGER .)
    SWITCH          reduce using rule 150 (value -> INTEGER .)
    FOR             reduce using rule 150 (value -> INTEGER .)
    STRING          reduce using rule 150 (value -> INTEGER .)
    INTEGER         reduce using rule 150 (value -> INTEGER .)
    FLOAT           reduce using rule 150 (value -> INTEGER .)
    BOOLEAN         reduce using rule 150 (value -> INTEGER .)
    BREAK           reduce using rule 150 (value -> INTEGER .)
    CONTINUE        reduce using rule 150 (value -> INTEGER .)
    PASS            reduce using rule 150 (value -> INTEGER .)
    $end            reduce using rule 150 (value -> INTEGER .)
    RKEY            reduce using rule 150 (value -> INTEGER .)
    SEMICOLON       reduce using rule 150 (value -> INTEGER .)
    RETURN          reduce using rule 150 (value -> INTEGER .)
    CASE            reduce using rule 150 (value -> INTEGER .)
    DEFAULT         reduce using rule 150 (value -> INTEGER .)
    COLON           reduce using rule 150 (value -> INTEGER .)


state 33

    (90) assignment_semantic -> CONST . IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (92) assignment_semantic -> CONST . IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (94) assignment_semantic -> CONST . IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (96) assignment_semantic -> CONST . IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN

    IDENTIFIER      shift and go to state 77


state 34

    (151) value -> FLOAT .

    PLUS            reduce using rule 151 (value -> FLOAT .)
    MINUS           reduce using rule 151 (value -> FLOAT .)
    DIVIDE          reduce using rule 151 (value -> FLOAT .)
    TIMES           reduce using rule 151 (value -> FLOAT .)
    ENTERE_DIVIDE   reduce using rule 151 (value -> FLOAT .)
    MODULE          reduce using rule 151 (value -> FLOAT .)
    EQUALEQUAL      reduce using rule 151 (value -> FLOAT .)
    NOT_EQUAL       reduce using rule 151 (value -> FLOAT .)
    LESS_EQUAL      reduce using rule 151 (value -> FLOAT .)
    GREATER_EQUAL   reduce using rule 151 (value -> FLOAT .)
    LESS            reduce using rule 151 (value -> FLOAT .)
    GREATER         reduce using rule 151 (value -> FLOAT .)
    LOGICAL_AND     reduce using rule 151 (value -> FLOAT .)
    LOGICAL_OR      reduce using rule 151 (value -> FLOAT .)
    LKEY            reduce using rule 151 (value -> FLOAT .)
    RPAREN          reduce using rule 151 (value -> FLOAT .)
    COMMA           reduce using rule 151 (value -> FLOAT .)
    FMT_LIBRARY     reduce using rule 151 (value -> FLOAT .)
    FUNC            reduce using rule 151 (value -> FLOAT .)
    IDENTIFIER      reduce using rule 151 (value -> FLOAT .)
    INPUT           reduce using rule 151 (value -> FLOAT .)
    IF              reduce using rule 151 (value -> FLOAT .)
    VAR             reduce using rule 151 (value -> FLOAT .)
    CONST           reduce using rule 151 (value -> FLOAT .)
    SWITCH          reduce using rule 151 (value -> FLOAT .)
    FOR             reduce using rule 151 (value -> FLOAT .)
    STRING          reduce using rule 151 (value -> FLOAT .)
    INTEGER         reduce using rule 151 (value -> FLOAT .)
    FLOAT           reduce using rule 151 (value -> FLOAT .)
    BOOLEAN         reduce using rule 151 (value -> FLOAT .)
    BREAK           reduce using rule 151 (value -> FLOAT .)
    CONTINUE        reduce using rule 151 (value -> FLOAT .)
    PASS            reduce using rule 151 (value -> FLOAT .)
    $end            reduce using rule 151 (value -> FLOAT .)
    RKEY            reduce using rule 151 (value -> FLOAT .)
    SEMICOLON       reduce using rule 151 (value -> FLOAT .)
    RETURN          reduce using rule 151 (value -> FLOAT .)
    CASE            reduce using rule 151 (value -> FLOAT .)
    DEFAULT         reduce using rule 151 (value -> FLOAT .)
    COLON           reduce using rule 151 (value -> FLOAT .)


state 35

    (152) value -> BOOLEAN .

    PLUS            reduce using rule 152 (value -> BOOLEAN .)
    MINUS           reduce using rule 152 (value -> BOOLEAN .)
    DIVIDE          reduce using rule 152 (value -> BOOLEAN .)
    TIMES           reduce using rule 152 (value -> BOOLEAN .)
    ENTERE_DIVIDE   reduce using rule 152 (value -> BOOLEAN .)
    MODULE          reduce using rule 152 (value -> BOOLEAN .)
    EQUALEQUAL      reduce using rule 152 (value -> BOOLEAN .)
    NOT_EQUAL       reduce using rule 152 (value -> BOOLEAN .)
    LESS_EQUAL      reduce using rule 152 (value -> BOOLEAN .)
    GREATER_EQUAL   reduce using rule 152 (value -> BOOLEAN .)
    LESS            reduce using rule 152 (value -> BOOLEAN .)
    GREATER         reduce using rule 152 (value -> BOOLEAN .)
    LOGICAL_AND     reduce using rule 152 (value -> BOOLEAN .)
    LOGICAL_OR      reduce using rule 152 (value -> BOOLEAN .)
    LKEY            reduce using rule 152 (value -> BOOLEAN .)
    RPAREN          reduce using rule 152 (value -> BOOLEAN .)
    COMMA           reduce using rule 152 (value -> BOOLEAN .)
    FMT_LIBRARY     reduce using rule 152 (value -> BOOLEAN .)
    FUNC            reduce using rule 152 (value -> BOOLEAN .)
    IDENTIFIER      reduce using rule 152 (value -> BOOLEAN .)
    INPUT           reduce using rule 152 (value -> BOOLEAN .)
    IF              reduce using rule 152 (value -> BOOLEAN .)
    VAR             reduce using rule 152 (value -> BOOLEAN .)
    CONST           reduce using rule 152 (value -> BOOLEAN .)
    SWITCH          reduce using rule 152 (value -> BOOLEAN .)
    FOR             reduce using rule 152 (value -> BOOLEAN .)
    STRING          reduce using rule 152 (value -> BOOLEAN .)
    INTEGER         reduce using rule 152 (value -> BOOLEAN .)
    FLOAT           reduce using rule 152 (value -> BOOLEAN .)
    BOOLEAN         reduce using rule 152 (value -> BOOLEAN .)
    BREAK           reduce using rule 152 (value -> BOOLEAN .)
    CONTINUE        reduce using rule 152 (value -> BOOLEAN .)
    PASS            reduce using rule 152 (value -> BOOLEAN .)
    $end            reduce using rule 152 (value -> BOOLEAN .)
    RKEY            reduce using rule 152 (value -> BOOLEAN .)
    SEMICOLON       reduce using rule 152 (value -> BOOLEAN .)
    RETURN          reduce using rule 152 (value -> BOOLEAN .)
    CASE            reduce using rule 152 (value -> BOOLEAN .)
    DEFAULT         reduce using rule 152 (value -> BOOLEAN .)
    COLON           reduce using rule 152 (value -> BOOLEAN .)


state 36

    (44) switch_statement -> SWITCH . expression LKEY case_clauses RKEY
    (45) switch_statement -> SWITCH . expression LKEY case_clauses DEFAULT COLON statements RKEY
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 78
    value                          shift and go to state 79

state 37

    (31) for -> FOR . LKEY loop_program RKEY
    (32) for -> FOR . comparation_operation LKEY loop_program RKEY
    (33) for -> FOR . short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value

    LKEY            shift and go to state 81
    IDENTIFIER      shift and go to state 84
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 82
    short_assignment               shift and go to state 83
    usable_value                   shift and go to state 72
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75

state 38

    (3) loop_program -> loop_program program .
    (13) program -> program . sentencia
    (14) program -> program . loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! shift/reduce conflict for FMT_LIBRARY resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    BREAK           reduce using rule 3 (loop_program -> loop_program program .)
    CONTINUE        reduce using rule 3 (loop_program -> loop_program program .)
    PASS            reduce using rule 3 (loop_program -> loop_program program .)
    $end            reduce using rule 3 (loop_program -> loop_program program .)
    RKEY            reduce using rule 3 (loop_program -> loop_program program .)
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

  ! FMT_LIBRARY     [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FUNC            [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! IDENTIFIER      [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! INPUT           [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! IF              [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! VAR             [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! CONST           [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! SWITCH          [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FOR             [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! STRING          [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! INTEGER         [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FLOAT           [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! BOOLEAN         [ reduce using rule 3 (loop_program -> loop_program program .) ]

    sentencia                      shift and go to state 40
    loop                           shift and go to state 41
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 39

    (4) loop_program -> loop_program loop_reserved .

    BREAK           reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    CONTINUE        reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    PASS            reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    FMT_LIBRARY     reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    FUNC            reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    IDENTIFIER      reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    INPUT           reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    IF              reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    VAR             reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    CONST           reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    SWITCH          reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    FOR             reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    STRING          reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    INTEGER         reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    FLOAT           reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    BOOLEAN         reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    $end            reduce using rule 4 (loop_program -> loop_program loop_reserved .)
    RKEY            reduce using rule 4 (loop_program -> loop_program loop_reserved .)


state 40

    (13) program -> program sentencia .

    FMT_LIBRARY     reduce using rule 13 (program -> program sentencia .)
    FUNC            reduce using rule 13 (program -> program sentencia .)
    IDENTIFIER      reduce using rule 13 (program -> program sentencia .)
    INPUT           reduce using rule 13 (program -> program sentencia .)
    IF              reduce using rule 13 (program -> program sentencia .)
    VAR             reduce using rule 13 (program -> program sentencia .)
    CONST           reduce using rule 13 (program -> program sentencia .)
    SWITCH          reduce using rule 13 (program -> program sentencia .)
    FOR             reduce using rule 13 (program -> program sentencia .)
    STRING          reduce using rule 13 (program -> program sentencia .)
    INTEGER         reduce using rule 13 (program -> program sentencia .)
    FLOAT           reduce using rule 13 (program -> program sentencia .)
    BOOLEAN         reduce using rule 13 (program -> program sentencia .)
    BREAK           reduce using rule 13 (program -> program sentencia .)
    CONTINUE        reduce using rule 13 (program -> program sentencia .)
    PASS            reduce using rule 13 (program -> program sentencia .)
    $end            reduce using rule 13 (program -> program sentencia .)
    RKEY            reduce using rule 13 (program -> program sentencia .)
    RETURN          reduce using rule 13 (program -> program sentencia .)


state 41

    (14) program -> program loop .

    FMT_LIBRARY     reduce using rule 14 (program -> program loop .)
    FUNC            reduce using rule 14 (program -> program loop .)
    IDENTIFIER      reduce using rule 14 (program -> program loop .)
    INPUT           reduce using rule 14 (program -> program loop .)
    IF              reduce using rule 14 (program -> program loop .)
    VAR             reduce using rule 14 (program -> program loop .)
    CONST           reduce using rule 14 (program -> program loop .)
    SWITCH          reduce using rule 14 (program -> program loop .)
    FOR             reduce using rule 14 (program -> program loop .)
    STRING          reduce using rule 14 (program -> program loop .)
    INTEGER         reduce using rule 14 (program -> program loop .)
    FLOAT           reduce using rule 14 (program -> program loop .)
    BOOLEAN         reduce using rule 14 (program -> program loop .)
    BREAK           reduce using rule 14 (program -> program loop .)
    CONTINUE        reduce using rule 14 (program -> program loop .)
    PASS            reduce using rule 14 (program -> program loop .)
    $end            reduce using rule 14 (program -> program loop .)
    RKEY            reduce using rule 14 (program -> program loop .)
    RETURN          reduce using rule 14 (program -> program loop .)


state 42

    (79) print -> FMT_LIBRARY DOT . PRINTLN LPAREN data RPAREN
    (80) print -> FMT_LIBRARY DOT . PRINTF LPAREN STRING RPAREN
    (81) print -> FMT_LIBRARY DOT . PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> FMT_LIBRARY DOT . PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> FMT_LIBRARY DOT . PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> FMT_LIBRARY DOT . PRINTF LPAREN RPAREN

    PRINTLN         shift and go to state 85
    PRINTF          shift and go to state 86


state 43

    (141) def_function -> FUNC IDENTIFIER . LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> FUNC IDENTIFIER . LPAREN parameters RPAREN data_type LKEY func_program RKEY

    LPAREN          shift and go to state 87


state 44

    (143) call_function -> IDENTIFIER LPAREN . values RPAREN
    (36) function_call -> IDENTIFIER LPAREN . values RPAREN
    (147) values -> . value
    (148) values -> . values COMMA value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    values                         shift and go to state 88
    value                          shift and go to state 89

state 45

    (97) short_assignment -> IDENTIFIER SHORT_VAR_DECL . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 90
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 46

    (103) direct_arithmetic_operation -> IDENTIFIER PLUS_EQ . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 91

state 47

    (104) direct_arithmetic_operation -> IDENTIFIER MINUS_EQ . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 92

state 48

    (105) direct_arithmetic_operation -> IDENTIFIER TIMES_EQ . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 93

state 49

    (106) direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 94

state 50

    (107) direct_arithmetic_operation -> IDENTIFIER MODULO_EQ . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 95

state 51

    (108) direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 96

state 52

    (109) direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 97

state 53

    (110) direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 98

state 54

    (111) direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 99

state 55

    (112) direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 100

state 56

    (158) input -> INPUT LPAREN . RPAREN
    (159) input -> INPUT LPAREN . value RPAREN
    (160) input -> INPUT LPAREN . identifiers RPAREN
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (127) identifiers -> . IDENTIFIER
    (128) identifiers -> . identifiers COMMA identifiers

    RPAREN          shift and go to state 101
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 104

    value                          shift and go to state 102
    identifiers                    shift and go to state 103

state 57

    (113) arithmetic_operation -> usable_value PLUS . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 105
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 58

    (114) arithmetic_operation -> usable_value MINUS . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 106
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 59

    (115) arithmetic_operation -> usable_value DIVIDE . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 107
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 60

    (116) arithmetic_operation -> usable_value TIMES . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 108
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 61

    (117) arithmetic_operation -> usable_value ENTERE_DIVIDE . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 109
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 62

    (118) arithmetic_operation -> usable_value MODULE . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 110
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 63

    (119) comparation_operation -> usable_value EQUALEQUAL . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 111
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 64

    (120) comparation_operation -> usable_value NOT_EQUAL . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 112
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 65

    (121) comparation_operation -> usable_value LESS_EQUAL . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 113
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 66

    (122) comparation_operation -> usable_value GREATER_EQUAL . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 114
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 67

    (123) comparation_operation -> usable_value LESS . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 115
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 68

    (124) comparation_operation -> usable_value GREATER . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 116
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 69

    (125) comparation_operation -> usable_value LOGICAL_AND . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 117
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 70

    (126) comparation_operation -> usable_value LOGICAL_OR . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 118
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 71

    (37) if_statement -> IF comparation_operation . LKEY program RKEY
    (38) if_statement -> IF comparation_operation . LKEY program RKEY conditions_elseif
    (39) if_statement -> IF comparation_operation . LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> IF comparation_operation . LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (102) usable_value -> comparation_operation .

    LKEY            shift and go to state 119
    EQUALEQUAL      reduce using rule 102 (usable_value -> comparation_operation .)
    NOT_EQUAL       reduce using rule 102 (usable_value -> comparation_operation .)
    LESS_EQUAL      reduce using rule 102 (usable_value -> comparation_operation .)
    GREATER_EQUAL   reduce using rule 102 (usable_value -> comparation_operation .)
    LESS            reduce using rule 102 (usable_value -> comparation_operation .)
    GREATER         reduce using rule 102 (usable_value -> comparation_operation .)
    LOGICAL_AND     reduce using rule 102 (usable_value -> comparation_operation .)
    LOGICAL_OR      reduce using rule 102 (usable_value -> comparation_operation .)
    PLUS            reduce using rule 102 (usable_value -> comparation_operation .)
    MINUS           reduce using rule 102 (usable_value -> comparation_operation .)
    DIVIDE          reduce using rule 102 (usable_value -> comparation_operation .)
    TIMES           reduce using rule 102 (usable_value -> comparation_operation .)
    ENTERE_DIVIDE   reduce using rule 102 (usable_value -> comparation_operation .)
    MODULE          reduce using rule 102 (usable_value -> comparation_operation .)


state 72

    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value

    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62


state 73

    (99) usable_value -> call_function .

    EQUALEQUAL      reduce using rule 99 (usable_value -> call_function .)
    NOT_EQUAL       reduce using rule 99 (usable_value -> call_function .)
    LESS_EQUAL      reduce using rule 99 (usable_value -> call_function .)
    GREATER_EQUAL   reduce using rule 99 (usable_value -> call_function .)
    LESS            reduce using rule 99 (usable_value -> call_function .)
    GREATER         reduce using rule 99 (usable_value -> call_function .)
    LOGICAL_AND     reduce using rule 99 (usable_value -> call_function .)
    LOGICAL_OR      reduce using rule 99 (usable_value -> call_function .)
    PLUS            reduce using rule 99 (usable_value -> call_function .)
    MINUS           reduce using rule 99 (usable_value -> call_function .)
    DIVIDE          reduce using rule 99 (usable_value -> call_function .)
    TIMES           reduce using rule 99 (usable_value -> call_function .)
    ENTERE_DIVIDE   reduce using rule 99 (usable_value -> call_function .)
    MODULE          reduce using rule 99 (usable_value -> call_function .)
    FMT_LIBRARY     reduce using rule 99 (usable_value -> call_function .)
    FUNC            reduce using rule 99 (usable_value -> call_function .)
    IDENTIFIER      reduce using rule 99 (usable_value -> call_function .)
    INPUT           reduce using rule 99 (usable_value -> call_function .)
    IF              reduce using rule 99 (usable_value -> call_function .)
    VAR             reduce using rule 99 (usable_value -> call_function .)
    CONST           reduce using rule 99 (usable_value -> call_function .)
    SWITCH          reduce using rule 99 (usable_value -> call_function .)
    FOR             reduce using rule 99 (usable_value -> call_function .)
    STRING          reduce using rule 99 (usable_value -> call_function .)
    INTEGER         reduce using rule 99 (usable_value -> call_function .)
    FLOAT           reduce using rule 99 (usable_value -> call_function .)
    BOOLEAN         reduce using rule 99 (usable_value -> call_function .)
    BREAK           reduce using rule 99 (usable_value -> call_function .)
    CONTINUE        reduce using rule 99 (usable_value -> call_function .)
    PASS            reduce using rule 99 (usable_value -> call_function .)
    $end            reduce using rule 99 (usable_value -> call_function .)
    RKEY            reduce using rule 99 (usable_value -> call_function .)
    SEMICOLON       reduce using rule 99 (usable_value -> call_function .)
    RETURN          reduce using rule 99 (usable_value -> call_function .)
    CASE            reduce using rule 99 (usable_value -> call_function .)
    DEFAULT         reduce using rule 99 (usable_value -> call_function .)
    LKEY            reduce using rule 99 (usable_value -> call_function .)


state 74

    (100) usable_value -> IDENTIFIER .
    (153) value -> IDENTIFIER .
    (143) call_function -> IDENTIFIER . LPAREN values RPAREN

  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for ENTERE_DIVIDE resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for MODULE resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for FMT_LIBRARY resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for FUNC resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for INPUT resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for VAR resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for CONST resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for FOR resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for STRING resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for BREAK resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for PASS resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for $end resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for RKEY resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for RETURN resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for CASE resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LKEY resolved using rule 100 (usable_value -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 100 (usable_value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 100 (usable_value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 100 (usable_value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 100 (usable_value -> IDENTIFIER .)
    LESS            reduce using rule 100 (usable_value -> IDENTIFIER .)
    GREATER         reduce using rule 100 (usable_value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 100 (usable_value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 100 (usable_value -> IDENTIFIER .)
    PLUS            reduce using rule 100 (usable_value -> IDENTIFIER .)
    MINUS           reduce using rule 100 (usable_value -> IDENTIFIER .)
    DIVIDE          reduce using rule 100 (usable_value -> IDENTIFIER .)
    TIMES           reduce using rule 100 (usable_value -> IDENTIFIER .)
    ENTERE_DIVIDE   reduce using rule 100 (usable_value -> IDENTIFIER .)
    MODULE          reduce using rule 100 (usable_value -> IDENTIFIER .)
    FMT_LIBRARY     reduce using rule 100 (usable_value -> IDENTIFIER .)
    FUNC            reduce using rule 100 (usable_value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 100 (usable_value -> IDENTIFIER .)
    INPUT           reduce using rule 100 (usable_value -> IDENTIFIER .)
    IF              reduce using rule 100 (usable_value -> IDENTIFIER .)
    VAR             reduce using rule 100 (usable_value -> IDENTIFIER .)
    CONST           reduce using rule 100 (usable_value -> IDENTIFIER .)
    SWITCH          reduce using rule 100 (usable_value -> IDENTIFIER .)
    FOR             reduce using rule 100 (usable_value -> IDENTIFIER .)
    STRING          reduce using rule 100 (usable_value -> IDENTIFIER .)
    INTEGER         reduce using rule 100 (usable_value -> IDENTIFIER .)
    FLOAT           reduce using rule 100 (usable_value -> IDENTIFIER .)
    BOOLEAN         reduce using rule 100 (usable_value -> IDENTIFIER .)
    BREAK           reduce using rule 100 (usable_value -> IDENTIFIER .)
    CONTINUE        reduce using rule 100 (usable_value -> IDENTIFIER .)
    PASS            reduce using rule 100 (usable_value -> IDENTIFIER .)
    $end            reduce using rule 100 (usable_value -> IDENTIFIER .)
    RKEY            reduce using rule 100 (usable_value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 100 (usable_value -> IDENTIFIER .)
    RETURN          reduce using rule 100 (usable_value -> IDENTIFIER .)
    CASE            reduce using rule 100 (usable_value -> IDENTIFIER .)
    DEFAULT         reduce using rule 100 (usable_value -> IDENTIFIER .)
    LKEY            reduce using rule 100 (usable_value -> IDENTIFIER .)
    LPAREN          shift and go to state 120

  ! EQUALEQUAL      [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! NOT_EQUAL       [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LESS_EQUAL      [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! GREATER_EQUAL   [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LESS            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! GREATER         [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LOGICAL_AND     [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LOGICAL_OR      [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! MODULE          [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! FMT_LIBRARY     [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! FUNC            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! INPUT           [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! IF              [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! VAR             [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! CONST           [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! SWITCH          [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! FOR             [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! STRING          [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! INTEGER         [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! FLOAT           [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! BOOLEAN         [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! BREAK           [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! CONTINUE        [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! PASS            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! $end            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! RKEY            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! SEMICOLON       [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! RETURN          [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! CASE            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! DEFAULT         [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LKEY            [ reduce using rule 153 (value -> IDENTIFIER .) ]


state 75

    (101) usable_value -> arithmetic_operation .

    EQUALEQUAL      reduce using rule 101 (usable_value -> arithmetic_operation .)
    NOT_EQUAL       reduce using rule 101 (usable_value -> arithmetic_operation .)
    LESS_EQUAL      reduce using rule 101 (usable_value -> arithmetic_operation .)
    GREATER_EQUAL   reduce using rule 101 (usable_value -> arithmetic_operation .)
    LESS            reduce using rule 101 (usable_value -> arithmetic_operation .)
    GREATER         reduce using rule 101 (usable_value -> arithmetic_operation .)
    LOGICAL_AND     reduce using rule 101 (usable_value -> arithmetic_operation .)
    LOGICAL_OR      reduce using rule 101 (usable_value -> arithmetic_operation .)
    PLUS            reduce using rule 101 (usable_value -> arithmetic_operation .)
    MINUS           reduce using rule 101 (usable_value -> arithmetic_operation .)
    DIVIDE          reduce using rule 101 (usable_value -> arithmetic_operation .)
    TIMES           reduce using rule 101 (usable_value -> arithmetic_operation .)
    ENTERE_DIVIDE   reduce using rule 101 (usable_value -> arithmetic_operation .)
    MODULE          reduce using rule 101 (usable_value -> arithmetic_operation .)
    FMT_LIBRARY     reduce using rule 101 (usable_value -> arithmetic_operation .)
    FUNC            reduce using rule 101 (usable_value -> arithmetic_operation .)
    IDENTIFIER      reduce using rule 101 (usable_value -> arithmetic_operation .)
    INPUT           reduce using rule 101 (usable_value -> arithmetic_operation .)
    IF              reduce using rule 101 (usable_value -> arithmetic_operation .)
    VAR             reduce using rule 101 (usable_value -> arithmetic_operation .)
    CONST           reduce using rule 101 (usable_value -> arithmetic_operation .)
    SWITCH          reduce using rule 101 (usable_value -> arithmetic_operation .)
    FOR             reduce using rule 101 (usable_value -> arithmetic_operation .)
    STRING          reduce using rule 101 (usable_value -> arithmetic_operation .)
    INTEGER         reduce using rule 101 (usable_value -> arithmetic_operation .)
    FLOAT           reduce using rule 101 (usable_value -> arithmetic_operation .)
    BOOLEAN         reduce using rule 101 (usable_value -> arithmetic_operation .)
    BREAK           reduce using rule 101 (usable_value -> arithmetic_operation .)
    CONTINUE        reduce using rule 101 (usable_value -> arithmetic_operation .)
    PASS            reduce using rule 101 (usable_value -> arithmetic_operation .)
    $end            reduce using rule 101 (usable_value -> arithmetic_operation .)
    RKEY            reduce using rule 101 (usable_value -> arithmetic_operation .)
    SEMICOLON       reduce using rule 101 (usable_value -> arithmetic_operation .)
    RETURN          reduce using rule 101 (usable_value -> arithmetic_operation .)
    CASE            reduce using rule 101 (usable_value -> arithmetic_operation .)
    DEFAULT         reduce using rule 101 (usable_value -> arithmetic_operation .)
    LKEY            reduce using rule 101 (usable_value -> arithmetic_operation .)


state 76

    (89) assignment_semantic -> VAR IDENTIFIER . INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> VAR IDENTIFIER . FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> VAR IDENTIFIER . STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> VAR IDENTIFIER . BOOLEAN_DATA_TYPE EQUAL BOOLEAN

    INTEGER_DATA_TYPE shift and go to state 121
    FLOAT_DATA_TYPE shift and go to state 122
    STRING_DATA_TYPE shift and go to state 123
    BOOLEAN_DATA_TYPE shift and go to state 124


state 77

    (90) assignment_semantic -> CONST IDENTIFIER . INTEGER_DATA_TYPE EQUAL INTEGER
    (92) assignment_semantic -> CONST IDENTIFIER . FLOAT_DATA_TYPE EQUAL FLOAT
    (94) assignment_semantic -> CONST IDENTIFIER . STRING_DATA_TYPE EQUAL STRING
    (96) assignment_semantic -> CONST IDENTIFIER . BOOLEAN_DATA_TYPE EQUAL BOOLEAN

    INTEGER_DATA_TYPE shift and go to state 125
    FLOAT_DATA_TYPE shift and go to state 126
    STRING_DATA_TYPE shift and go to state 127
    BOOLEAN_DATA_TYPE shift and go to state 128


state 78

    (44) switch_statement -> SWITCH expression . LKEY case_clauses RKEY
    (45) switch_statement -> SWITCH expression . LKEY case_clauses DEFAULT COLON statements RKEY
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

    LKEY            shift and go to state 129
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143


state 79

    (64) expression -> value .

    LKEY            reduce using rule 64 (expression -> value .)
    PLUS            reduce using rule 64 (expression -> value .)
    MINUS           reduce using rule 64 (expression -> value .)
    TIMES           reduce using rule 64 (expression -> value .)
    DIVIDE          reduce using rule 64 (expression -> value .)
    ENTERE_DIVIDE   reduce using rule 64 (expression -> value .)
    MODULE          reduce using rule 64 (expression -> value .)
    EQUALEQUAL      reduce using rule 64 (expression -> value .)
    NOT_EQUAL       reduce using rule 64 (expression -> value .)
    LESS_EQUAL      reduce using rule 64 (expression -> value .)
    GREATER_EQUAL   reduce using rule 64 (expression -> value .)
    LESS            reduce using rule 64 (expression -> value .)
    GREATER         reduce using rule 64 (expression -> value .)
    LOGICAL_AND     reduce using rule 64 (expression -> value .)
    LOGICAL_OR      reduce using rule 64 (expression -> value .)


state 80

    (153) value -> IDENTIFIER .

    LKEY            reduce using rule 153 (value -> IDENTIFIER .)
    PLUS            reduce using rule 153 (value -> IDENTIFIER .)
    MINUS           reduce using rule 153 (value -> IDENTIFIER .)
    TIMES           reduce using rule 153 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 153 (value -> IDENTIFIER .)
    ENTERE_DIVIDE   reduce using rule 153 (value -> IDENTIFIER .)
    MODULE          reduce using rule 153 (value -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 153 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 153 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 153 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 153 (value -> IDENTIFIER .)
    LESS            reduce using rule 153 (value -> IDENTIFIER .)
    GREATER         reduce using rule 153 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 153 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 153 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 153 (value -> IDENTIFIER .)
    COMMA           reduce using rule 153 (value -> IDENTIFIER .)
    FMT_LIBRARY     reduce using rule 153 (value -> IDENTIFIER .)
    FUNC            reduce using rule 153 (value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 153 (value -> IDENTIFIER .)
    INPUT           reduce using rule 153 (value -> IDENTIFIER .)
    IF              reduce using rule 153 (value -> IDENTIFIER .)
    VAR             reduce using rule 153 (value -> IDENTIFIER .)
    CONST           reduce using rule 153 (value -> IDENTIFIER .)
    SWITCH          reduce using rule 153 (value -> IDENTIFIER .)
    FOR             reduce using rule 153 (value -> IDENTIFIER .)
    STRING          reduce using rule 153 (value -> IDENTIFIER .)
    INTEGER         reduce using rule 153 (value -> IDENTIFIER .)
    FLOAT           reduce using rule 153 (value -> IDENTIFIER .)
    BOOLEAN         reduce using rule 153 (value -> IDENTIFIER .)
    BREAK           reduce using rule 153 (value -> IDENTIFIER .)
    CONTINUE        reduce using rule 153 (value -> IDENTIFIER .)
    PASS            reduce using rule 153 (value -> IDENTIFIER .)
    $end            reduce using rule 153 (value -> IDENTIFIER .)
    RKEY            reduce using rule 153 (value -> IDENTIFIER .)
    RETURN          reduce using rule 153 (value -> IDENTIFIER .)
    CASE            reduce using rule 153 (value -> IDENTIFIER .)
    DEFAULT         reduce using rule 153 (value -> IDENTIFIER .)
    COLON           reduce using rule 153 (value -> IDENTIFIER .)


state 81

    (31) for -> FOR LKEY . loop_program RKEY
    (1) loop_program -> . program
    (2) loop_program -> . loop_reserved
    (3) loop_program -> . loop_program program
    (4) loop_program -> . loop_program loop_reserved
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (15) loop_reserved -> . BREAK
    (16) loop_reserved -> . CONTINUE
    (17) loop_reserved -> . PASS
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PASS            shift and go to state 8
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    loop_program                   shift and go to state 144
    program                        shift and go to state 2
    loop_reserved                  shift and go to state 3
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 82

    (32) for -> FOR comparation_operation . LKEY loop_program RKEY
    (102) usable_value -> comparation_operation .

    LKEY            shift and go to state 145
    EQUALEQUAL      reduce using rule 102 (usable_value -> comparation_operation .)
    NOT_EQUAL       reduce using rule 102 (usable_value -> comparation_operation .)
    LESS_EQUAL      reduce using rule 102 (usable_value -> comparation_operation .)
    GREATER_EQUAL   reduce using rule 102 (usable_value -> comparation_operation .)
    LESS            reduce using rule 102 (usable_value -> comparation_operation .)
    GREATER         reduce using rule 102 (usable_value -> comparation_operation .)
    LOGICAL_AND     reduce using rule 102 (usable_value -> comparation_operation .)
    LOGICAL_OR      reduce using rule 102 (usable_value -> comparation_operation .)
    PLUS            reduce using rule 102 (usable_value -> comparation_operation .)
    MINUS           reduce using rule 102 (usable_value -> comparation_operation .)
    DIVIDE          reduce using rule 102 (usable_value -> comparation_operation .)
    TIMES           reduce using rule 102 (usable_value -> comparation_operation .)
    ENTERE_DIVIDE   reduce using rule 102 (usable_value -> comparation_operation .)
    MODULE          reduce using rule 102 (usable_value -> comparation_operation .)


state 83

    (33) for -> FOR short_assignment . SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY

    SEMICOLON       shift and go to state 146


state 84

    (97) short_assignment -> IDENTIFIER . SHORT_VAR_DECL usable_value
    (100) usable_value -> IDENTIFIER .
    (153) value -> IDENTIFIER .
    (143) call_function -> IDENTIFIER . LPAREN values RPAREN

  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for ENTERE_DIVIDE resolved using rule 100 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for MODULE resolved using rule 100 (usable_value -> IDENTIFIER .)
    SHORT_VAR_DECL  shift and go to state 45
    EQUALEQUAL      reduce using rule 100 (usable_value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 100 (usable_value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 100 (usable_value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 100 (usable_value -> IDENTIFIER .)
    LESS            reduce using rule 100 (usable_value -> IDENTIFIER .)
    GREATER         reduce using rule 100 (usable_value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 100 (usable_value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 100 (usable_value -> IDENTIFIER .)
    PLUS            reduce using rule 100 (usable_value -> IDENTIFIER .)
    MINUS           reduce using rule 100 (usable_value -> IDENTIFIER .)
    DIVIDE          reduce using rule 100 (usable_value -> IDENTIFIER .)
    TIMES           reduce using rule 100 (usable_value -> IDENTIFIER .)
    ENTERE_DIVIDE   reduce using rule 100 (usable_value -> IDENTIFIER .)
    MODULE          reduce using rule 100 (usable_value -> IDENTIFIER .)
    LPAREN          shift and go to state 120

  ! EQUALEQUAL      [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! NOT_EQUAL       [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LESS_EQUAL      [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! GREATER_EQUAL   [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LESS            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! GREATER         [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LOGICAL_AND     [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! LOGICAL_OR      [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! MODULE          [ reduce using rule 153 (value -> IDENTIFIER .) ]


state 85

    (79) print -> FMT_LIBRARY DOT PRINTLN . LPAREN data RPAREN
    (87) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN . LPAREN RPAREN

    LPAREN          shift and go to state 147


state 86

    (80) print -> FMT_LIBRARY DOT PRINTF . LPAREN STRING RPAREN
    (81) print -> FMT_LIBRARY DOT PRINTF . LPAREN STRING COMMA RPAREN
    (82) print -> FMT_LIBRARY DOT PRINTF . LPAREN STRING COMMA data RPAREN
    (88) print_withoutvalue -> FMT_LIBRARY DOT PRINTF . LPAREN RPAREN

    LPAREN          shift and go to state 148


state 87

    (141) def_function -> FUNC IDENTIFIER LPAREN . parameters RPAREN LKEY func_program RKEY
    (142) def_function -> FUNC IDENTIFIER LPAREN . parameters RPAREN data_type LKEY func_program RKEY
    (144) parameters -> . parameter
    (145) parameters -> . parameters COMMA parameter
    (146) parameter -> . IDENTIFIER data_type

    IDENTIFIER      shift and go to state 149

    parameters                     shift and go to state 150
    parameter                      shift and go to state 151

state 88

    (143) call_function -> IDENTIFIER LPAREN values . RPAREN
    (36) function_call -> IDENTIFIER LPAREN values . RPAREN
    (148) values -> values . COMMA value

    RPAREN          shift and go to state 152
    COMMA           shift and go to state 153


state 89

    (147) values -> value .

    RPAREN          reduce using rule 147 (values -> value .)
    COMMA           reduce using rule 147 (values -> value .)


state 90

    (97) short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

    FMT_LIBRARY     reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FUNC            reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    IDENTIFIER      reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    INPUT           reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    IF              reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    VAR             reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    CONST           reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    SWITCH          reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FOR             reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    STRING          reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    INTEGER         reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FLOAT           reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    BOOLEAN         reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    BREAK           reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    CONTINUE        reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    PASS            reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    $end            reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    RKEY            reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    SEMICOLON       reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    RETURN          reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    CASE            reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    DEFAULT         reduce using rule 97 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70


state 91

    (103) direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .

    FMT_LIBRARY     reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FUNC            reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    IDENTIFIER      reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    INPUT           reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    IF              reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    VAR             reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    CONST           reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    SWITCH          reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FOR             reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    STRING          reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    INTEGER         reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FLOAT           reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    BOOLEAN         reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    BREAK           reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    CONTINUE        reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    PASS            reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    $end            reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    RKEY            reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    RETURN          reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    CASE            reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    DEFAULT         reduce using rule 103 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)


state 92

    (104) direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .

    FMT_LIBRARY     reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FUNC            reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    IDENTIFIER      reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    INPUT           reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    IF              reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    VAR             reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    CONST           reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    SWITCH          reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FOR             reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    STRING          reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    INTEGER         reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FLOAT           reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    BOOLEAN         reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    BREAK           reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    CONTINUE        reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    PASS            reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    $end            reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    RKEY            reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    RETURN          reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    CASE            reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    DEFAULT         reduce using rule 104 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)


state 93

    (105) direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .

    FMT_LIBRARY     reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FUNC            reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    IDENTIFIER      reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    INPUT           reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    IF              reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    VAR             reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    CONST           reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    SWITCH          reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FOR             reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    STRING          reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    INTEGER         reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FLOAT           reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    BOOLEAN         reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    BREAK           reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    CONTINUE        reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    PASS            reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    $end            reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    RKEY            reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    RETURN          reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    CASE            reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    DEFAULT         reduce using rule 105 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)


state 94

    (106) direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .

    FMT_LIBRARY     reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FUNC            reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    IDENTIFIER      reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    INPUT           reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    IF              reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    VAR             reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    CONST           reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    SWITCH          reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FOR             reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    STRING          reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    INTEGER         reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FLOAT           reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    BOOLEAN         reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    BREAK           reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    CONTINUE        reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    PASS            reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    $end            reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    RKEY            reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    RETURN          reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    CASE            reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    DEFAULT         reduce using rule 106 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)


state 95

    (107) direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .

    FMT_LIBRARY     reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FUNC            reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    IDENTIFIER      reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    INPUT           reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    IF              reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    VAR             reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    CONST           reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    SWITCH          reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FOR             reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    STRING          reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    INTEGER         reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FLOAT           reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    BOOLEAN         reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    BREAK           reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    CONTINUE        reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    PASS            reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    $end            reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    RKEY            reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    RETURN          reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    CASE            reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    DEFAULT         reduce using rule 107 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)


state 96

    (108) direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .

    FMT_LIBRARY     reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FUNC            reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    IDENTIFIER      reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    INPUT           reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    IF              reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    VAR             reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    CONST           reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    SWITCH          reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FOR             reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    STRING          reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    INTEGER         reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FLOAT           reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    BOOLEAN         reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    BREAK           reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    CONTINUE        reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    PASS            reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    $end            reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    RKEY            reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    RETURN          reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    CASE            reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    DEFAULT         reduce using rule 108 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)


state 97

    (109) direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .

    FMT_LIBRARY     reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FUNC            reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    IDENTIFIER      reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    INPUT           reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    IF              reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    VAR             reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    CONST           reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    SWITCH          reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FOR             reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    STRING          reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    INTEGER         reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FLOAT           reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    BOOLEAN         reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    BREAK           reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    CONTINUE        reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    PASS            reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    $end            reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    RKEY            reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    RETURN          reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    CASE            reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    DEFAULT         reduce using rule 109 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)


state 98

    (110) direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .

    FMT_LIBRARY     reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FUNC            reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    IDENTIFIER      reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    INPUT           reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    IF              reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    VAR             reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    CONST           reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    SWITCH          reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FOR             reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    STRING          reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    INTEGER         reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FLOAT           reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    BOOLEAN         reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    BREAK           reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    CONTINUE        reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    PASS            reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    $end            reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    RKEY            reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    RETURN          reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    CASE            reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    DEFAULT         reduce using rule 110 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)


state 99

    (111) direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .

    FMT_LIBRARY     reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FUNC            reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    IDENTIFIER      reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    INPUT           reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    IF              reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    VAR             reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    CONST           reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    SWITCH          reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FOR             reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    STRING          reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    INTEGER         reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FLOAT           reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    BOOLEAN         reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    BREAK           reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    CONTINUE        reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    PASS            reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    $end            reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    RKEY            reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    RETURN          reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    CASE            reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    DEFAULT         reduce using rule 111 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)


state 100

    (112) direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .

    FMT_LIBRARY     reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FUNC            reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    IDENTIFIER      reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    INPUT           reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    IF              reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    VAR             reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    CONST           reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    SWITCH          reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FOR             reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    STRING          reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    INTEGER         reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FLOAT           reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    BOOLEAN         reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    BREAK           reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    CONTINUE        reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    PASS            reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    $end            reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    RKEY            reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    RETURN          reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    CASE            reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    DEFAULT         reduce using rule 112 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)


state 101

    (158) input -> INPUT LPAREN RPAREN .

    FMT_LIBRARY     reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    FUNC            reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    CONST           reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    SWITCH          reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    STRING          reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    INTEGER         reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    FLOAT           reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    BOOLEAN         reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    BREAK           reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    CONTINUE        reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    PASS            reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    RKEY            reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    RETURN          reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    CASE            reduce using rule 158 (input -> INPUT LPAREN RPAREN .)
    DEFAULT         reduce using rule 158 (input -> INPUT LPAREN RPAREN .)


state 102

    (159) input -> INPUT LPAREN value . RPAREN

    RPAREN          shift and go to state 154


state 103

    (160) input -> INPUT LPAREN identifiers . RPAREN
    (128) identifiers -> identifiers . COMMA identifiers

    RPAREN          shift and go to state 155
    COMMA           shift and go to state 156


state 104

    (153) value -> IDENTIFIER .
    (127) identifiers -> IDENTIFIER .

  ! reduce/reduce conflict for RPAREN resolved using rule 127 (identifiers -> IDENTIFIER .)
    RPAREN          reduce using rule 127 (identifiers -> IDENTIFIER .)
    COMMA           reduce using rule 127 (identifiers -> IDENTIFIER .)

  ! RPAREN          [ reduce using rule 153 (value -> IDENTIFIER .) ]


state 105

    (113) arithmetic_operation -> usable_value PLUS usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    FUNC            reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    IDENTIFIER      reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    INPUT           reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    IF              reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    VAR             reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    CONST           reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    SWITCH          reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    FOR             reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    STRING          reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    INTEGER         reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    FLOAT           reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    BOOLEAN         reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    BREAK           reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    CONTINUE        reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    PASS            reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    $end            reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    RKEY            reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    SEMICOLON       reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    RETURN          reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    CASE            reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    DEFAULT         reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    LKEY            reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! MINUS           [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! DIVIDE          [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! TIMES           [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! MODULE          [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LESS            [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! GREATER         [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 113 (arithmetic_operation -> usable_value PLUS usable_value .) ]


state 106

    (114) arithmetic_operation -> usable_value MINUS usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    FUNC            reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    IDENTIFIER      reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    INPUT           reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    IF              reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    VAR             reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    CONST           reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    SWITCH          reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    FOR             reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    STRING          reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    INTEGER         reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    FLOAT           reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    BOOLEAN         reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    BREAK           reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    CONTINUE        reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    PASS            reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    $end            reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    RKEY            reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    SEMICOLON       reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    RETURN          reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    CASE            reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    DEFAULT         reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    LKEY            reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! MINUS           [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! DIVIDE          [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! TIMES           [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! MODULE          [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LESS            [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! GREATER         [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 114 (arithmetic_operation -> usable_value MINUS usable_value .) ]


state 107

    (115) arithmetic_operation -> usable_value DIVIDE usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FUNC            reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    IDENTIFIER      reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    INPUT           reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    IF              reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    VAR             reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    CONST           reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    SWITCH          reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FOR             reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    STRING          reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    INTEGER         reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FLOAT           reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    BOOLEAN         reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    BREAK           reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    CONTINUE        reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    PASS            reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    $end            reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    RKEY            reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    SEMICOLON       reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    RETURN          reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    CASE            reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    DEFAULT         reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    LKEY            reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! MINUS           [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! DIVIDE          [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! TIMES           [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! MODULE          [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LESS            [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! GREATER         [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 115 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]


state 108

    (116) arithmetic_operation -> usable_value TIMES usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    FUNC            reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    IDENTIFIER      reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    INPUT           reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    IF              reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    VAR             reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    CONST           reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    SWITCH          reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    FOR             reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    STRING          reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    INTEGER         reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    FLOAT           reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    BOOLEAN         reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    BREAK           reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    CONTINUE        reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    PASS            reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    $end            reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    RKEY            reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    SEMICOLON       reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    RETURN          reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    CASE            reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    DEFAULT         reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    LKEY            reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! MINUS           [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! DIVIDE          [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! TIMES           [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! MODULE          [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LESS            [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! GREATER         [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 116 (arithmetic_operation -> usable_value TIMES usable_value .) ]


state 109

    (117) arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FUNC            reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    IDENTIFIER      reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    INPUT           reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    IF              reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    VAR             reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    CONST           reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    SWITCH          reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FOR             reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    STRING          reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    INTEGER         reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FLOAT           reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    BOOLEAN         reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    BREAK           reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    CONTINUE        reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    PASS            reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    $end            reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    RKEY            reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    SEMICOLON       reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    RETURN          reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    CASE            reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    DEFAULT         reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    LKEY            reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! MINUS           [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! DIVIDE          [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! TIMES           [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! MODULE          [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LESS            [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! GREATER         [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 117 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]


state 110

    (118) arithmetic_operation -> usable_value MODULE usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    FUNC            reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    IDENTIFIER      reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    INPUT           reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    IF              reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    VAR             reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    CONST           reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    SWITCH          reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    FOR             reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    STRING          reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    INTEGER         reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    FLOAT           reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    BOOLEAN         reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    BREAK           reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    CONTINUE        reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    PASS            reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    $end            reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    RKEY            reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    SEMICOLON       reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    RETURN          reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    CASE            reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    DEFAULT         reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    LKEY            reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! MINUS           [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! DIVIDE          [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! TIMES           [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! MODULE          [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LESS            [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! GREATER         [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 118 (arithmetic_operation -> usable_value MODULE usable_value .) ]


state 111

    (119) comparation_operation -> usable_value EQUALEQUAL usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FUNC            reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    IDENTIFIER      reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    INPUT           reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    IF              reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    VAR             reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    CONST           reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    SWITCH          reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FOR             reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    STRING          reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    INTEGER         reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FLOAT           reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    BOOLEAN         reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    BREAK           reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    CONTINUE        reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    PASS            reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    $end            reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    RKEY            reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    SEMICOLON       reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    RETURN          reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    CASE            reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    DEFAULT         reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LESS            [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 119 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]


state 112

    (120) comparation_operation -> usable_value NOT_EQUAL usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FUNC            reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    IDENTIFIER      reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    INPUT           reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    IF              reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    VAR             reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    CONST           reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    SWITCH          reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FOR             reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    STRING          reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    INTEGER         reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FLOAT           reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    BOOLEAN         reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    BREAK           reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    CONTINUE        reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    PASS            reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    $end            reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    RKEY            reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    SEMICOLON       reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    RETURN          reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    CASE            reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    DEFAULT         reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LESS            [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 120 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]


state 113

    (121) comparation_operation -> usable_value LESS_EQUAL usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FUNC            reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    IDENTIFIER      reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    INPUT           reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    IF              reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    VAR             reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    CONST           reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    SWITCH          reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FOR             reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    STRING          reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    INTEGER         reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FLOAT           reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    BOOLEAN         reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    BREAK           reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    CONTINUE        reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    PASS            reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    $end            reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    RKEY            reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    SEMICOLON       reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    RETURN          reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    CASE            reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    DEFAULT         reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LESS            [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 121 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]


state 114

    (122) comparation_operation -> usable_value GREATER_EQUAL usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FUNC            reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    IDENTIFIER      reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    INPUT           reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    IF              reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    VAR             reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    CONST           reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    SWITCH          reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FOR             reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    STRING          reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    INTEGER         reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FLOAT           reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    BOOLEAN         reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    BREAK           reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    CONTINUE        reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    PASS            reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    $end            reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    RKEY            reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    SEMICOLON       reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    RETURN          reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    CASE            reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    DEFAULT         reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LESS            [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 122 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]


state 115

    (123) comparation_operation -> usable_value LESS usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    FMT_LIBRARY     reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    FUNC            reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    IDENTIFIER      reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    INPUT           reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    IF              reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    VAR             reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    CONST           reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    SWITCH          reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    FOR             reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    STRING          reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    INTEGER         reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    FLOAT           reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    BOOLEAN         reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    BREAK           reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    CONTINUE        reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    PASS            reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    $end            reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    RKEY            reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    SEMICOLON       reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    RETURN          reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    CASE            reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    DEFAULT         reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! MINUS           [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! DIVIDE          [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! TIMES           [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! MODULE          [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LESS            [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! GREATER         [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 123 (comparation_operation -> usable_value LESS usable_value .) ]


state 116

    (124) comparation_operation -> usable_value GREATER usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    FMT_LIBRARY     reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    FUNC            reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    IDENTIFIER      reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    INPUT           reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    IF              reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    VAR             reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    CONST           reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    SWITCH          reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    FOR             reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    STRING          reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    INTEGER         reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    FLOAT           reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    BOOLEAN         reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    BREAK           reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    CONTINUE        reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    PASS            reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    $end            reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    RKEY            reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    SEMICOLON       reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    RETURN          reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    CASE            reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    DEFAULT         reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! MINUS           [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! DIVIDE          [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! TIMES           [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! MODULE          [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LESS            [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! GREATER         [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 124 (comparation_operation -> usable_value GREATER usable_value .) ]


state 117

    (125) comparation_operation -> usable_value LOGICAL_AND usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FMT_LIBRARY     reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FUNC            reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    IDENTIFIER      reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    INPUT           reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    IF              reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    VAR             reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    CONST           reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    SWITCH          reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FOR             reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    STRING          reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    INTEGER         reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FLOAT           reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    BOOLEAN         reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    BREAK           reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    CONTINUE        reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    PASS            reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    $end            reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    RKEY            reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    SEMICOLON       reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    RETURN          reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    CASE            reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    DEFAULT         reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! MINUS           [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! DIVIDE          [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! TIMES           [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! MODULE          [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LESS            [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! GREATER         [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 125 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]


state 118

    (126) comparation_operation -> usable_value LOGICAL_OR usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FMT_LIBRARY     reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FUNC            reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    IDENTIFIER      reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    INPUT           reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    IF              reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    VAR             reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    CONST           reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    SWITCH          reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FOR             reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    STRING          reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    INTEGER         reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FLOAT           reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    BOOLEAN         reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    BREAK           reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    CONTINUE        reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    PASS            reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    $end            reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    RKEY            reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    SEMICOLON       reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    RETURN          reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    CASE            reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    DEFAULT         reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70

  ! PLUS            [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! MINUS           [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! DIVIDE          [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! TIMES           [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! MODULE          [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LESS            [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! GREATER         [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 126 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]


state 119

    (37) if_statement -> IF comparation_operation LKEY . program RKEY
    (38) if_statement -> IF comparation_operation LKEY . program RKEY conditions_elseif
    (39) if_statement -> IF comparation_operation LKEY . program RKEY ELSE LKEY program RKEY
    (40) if_statement -> IF comparation_operation LKEY . program RKEY conditions_elseif ELSE LKEY program RKEY
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    program                        shift and go to state 157
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 120

    (143) call_function -> IDENTIFIER LPAREN . values RPAREN
    (147) values -> . value
    (148) values -> . values COMMA value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    values                         shift and go to state 158
    value                          shift and go to state 89

state 121

    (89) assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE . EQUAL INTEGER

    EQUAL           shift and go to state 159


state 122

    (91) assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE . EQUAL FLOAT

    EQUAL           shift and go to state 160


state 123

    (93) assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE . EQUAL STRING

    EQUAL           shift and go to state 161


state 124

    (95) assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE . EQUAL BOOLEAN

    EQUAL           shift and go to state 162


state 125

    (90) assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE . EQUAL INTEGER

    EQUAL           shift and go to state 163


state 126

    (92) assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE . EQUAL FLOAT

    EQUAL           shift and go to state 164


state 127

    (94) assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE . EQUAL STRING

    EQUAL           shift and go to state 165


state 128

    (96) assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE . EQUAL BOOLEAN

    EQUAL           shift and go to state 166


state 129

    (44) switch_statement -> SWITCH expression LKEY . case_clauses RKEY
    (45) switch_statement -> SWITCH expression LKEY . case_clauses DEFAULT COLON statements RKEY
    (46) case_clauses -> . case_clause case_clauses
    (47) case_clauses -> .
    (48) case_clause -> . CASE value COLON statements

    RKEY            reduce using rule 47 (case_clauses -> .)
    DEFAULT         reduce using rule 47 (case_clauses -> .)
    CASE            shift and go to state 169

    case_clauses                   shift and go to state 167
    case_clause                    shift and go to state 168

state 130

    (65) expression -> expression PLUS . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 170
    value                          shift and go to state 79

state 131

    (66) expression -> expression MINUS . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 171
    value                          shift and go to state 79

state 132

    (67) expression -> expression TIMES . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 172
    value                          shift and go to state 79

state 133

    (68) expression -> expression DIVIDE . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 173
    value                          shift and go to state 79

state 134

    (69) expression -> expression ENTERE_DIVIDE . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 174
    value                          shift and go to state 79

state 135

    (70) expression -> expression MODULE . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 175
    value                          shift and go to state 79

state 136

    (71) expression -> expression EQUALEQUAL . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 176
    value                          shift and go to state 79

state 137

    (72) expression -> expression NOT_EQUAL . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 177
    value                          shift and go to state 79

state 138

    (73) expression -> expression LESS_EQUAL . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 178
    value                          shift and go to state 79

state 139

    (74) expression -> expression GREATER_EQUAL . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 179
    value                          shift and go to state 79

state 140

    (75) expression -> expression LESS . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 180
    value                          shift and go to state 79

state 141

    (76) expression -> expression GREATER . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 181
    value                          shift and go to state 79

state 142

    (77) expression -> expression LOGICAL_AND . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 182
    value                          shift and go to state 79

state 143

    (78) expression -> expression LOGICAL_OR . expression
    (64) expression -> . value
    (65) expression -> . expression PLUS expression
    (66) expression -> . expression MINUS expression
    (67) expression -> . expression TIMES expression
    (68) expression -> . expression DIVIDE expression
    (69) expression -> . expression ENTERE_DIVIDE expression
    (70) expression -> . expression MODULE expression
    (71) expression -> . expression EQUALEQUAL expression
    (72) expression -> . expression NOT_EQUAL expression
    (73) expression -> . expression LESS_EQUAL expression
    (74) expression -> . expression GREATER_EQUAL expression
    (75) expression -> . expression LESS expression
    (76) expression -> . expression GREATER expression
    (77) expression -> . expression LOGICAL_AND expression
    (78) expression -> . expression LOGICAL_OR expression
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    expression                     shift and go to state 183
    value                          shift and go to state 79

state 144

    (31) for -> FOR LKEY loop_program . RKEY
    (3) loop_program -> loop_program . program
    (4) loop_program -> loop_program . loop_reserved
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (15) loop_reserved -> . BREAK
    (16) loop_reserved -> . CONTINUE
    (17) loop_reserved -> . PASS
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 184
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PASS            shift and go to state 8
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    program                        shift and go to state 38
    loop_reserved                  shift and go to state 39
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 145

    (32) for -> FOR comparation_operation LKEY . loop_program RKEY
    (1) loop_program -> . program
    (2) loop_program -> . loop_reserved
    (3) loop_program -> . loop_program program
    (4) loop_program -> . loop_program loop_reserved
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (15) loop_reserved -> . BREAK
    (16) loop_reserved -> . CONTINUE
    (17) loop_reserved -> . PASS
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PASS            shift and go to state 8
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    loop_program                   shift and go to state 185
    program                        shift and go to state 2
    loop_reserved                  shift and go to state 3
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 146

    (33) for -> FOR short_assignment SEMICOLON . comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 186
    usable_value                   shift and go to state 72
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75

state 147

    (79) print -> FMT_LIBRARY DOT PRINTLN LPAREN . data RPAREN
    (87) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN . RPAREN
    (83) data -> . value
    (84) data -> . IDENTIFIER
    (85) data -> . data COMMA value
    (86) data -> . data COMMA IDENTIFIER
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    RPAREN          shift and go to state 188
    IDENTIFIER      shift and go to state 190
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    data                           shift and go to state 187
    value                          shift and go to state 189

state 148

    (80) print -> FMT_LIBRARY DOT PRINTF LPAREN . STRING RPAREN
    (81) print -> FMT_LIBRARY DOT PRINTF LPAREN . STRING COMMA RPAREN
    (82) print -> FMT_LIBRARY DOT PRINTF LPAREN . STRING COMMA data RPAREN
    (88) print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN . RPAREN

    STRING          shift and go to state 191
    RPAREN          shift and go to state 192


state 149

    (146) parameter -> IDENTIFIER . data_type
    (154) data_type -> . INTEGER_DATA_TYPE
    (155) data_type -> . FLOAT_DATA_TYPE
    (156) data_type -> . BOOLEAN_DATA_TYPE
    (157) data_type -> . STRING_DATA_TYPE

    INTEGER_DATA_TYPE shift and go to state 194
    FLOAT_DATA_TYPE shift and go to state 195
    BOOLEAN_DATA_TYPE shift and go to state 196
    STRING_DATA_TYPE shift and go to state 197

    data_type                      shift and go to state 193

state 150

    (141) def_function -> FUNC IDENTIFIER LPAREN parameters . RPAREN LKEY func_program RKEY
    (142) def_function -> FUNC IDENTIFIER LPAREN parameters . RPAREN data_type LKEY func_program RKEY
    (145) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 198
    COMMA           shift and go to state 199


state 151

    (144) parameters -> parameter .

    RPAREN          reduce using rule 144 (parameters -> parameter .)
    COMMA           reduce using rule 144 (parameters -> parameter .)


state 152

    (143) call_function -> IDENTIFIER LPAREN values RPAREN .
    (36) function_call -> IDENTIFIER LPAREN values RPAREN .

  ! reduce/reduce conflict for FMT_LIBRARY resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for INPUT resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for VAR resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for CONST resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for SWITCH resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for STRING resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for INTEGER resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FLOAT resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for PASS resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for RKEY resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for RETURN resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for CASE resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PLUS            reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MINUS           reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    DIVIDE          reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    TIMES           reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    ENTERE_DIVIDE   reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MODULE          reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    EQUALEQUAL      reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    NOT_EQUAL       reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS_EQUAL      reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER_EQUAL   reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS            reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER         reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_AND     reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_OR      reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FMT_LIBRARY     reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FUNC            reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INPUT           reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    SWITCH          reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING          reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER         reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FLOAT           reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN         reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BREAK           reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONTINUE        reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PASS            reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    $end            reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RKEY            reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RETURN          reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CASE            reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DEFAULT         reduce using rule 36 (function_call -> IDENTIFIER LPAREN values RPAREN .)

  ! FMT_LIBRARY     [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FUNC            [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! IDENTIFIER      [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! INPUT           [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! IF              [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! VAR             [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! CONST           [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! SWITCH          [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FOR             [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! STRING          [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! INTEGER         [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FLOAT           [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! BOOLEAN         [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! BREAK           [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! CONTINUE        [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! PASS            [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! $end            [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! RKEY            [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! RETURN          [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! CASE            [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! DEFAULT         [ reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]


state 153

    (148) values -> values COMMA . value
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 200

state 154

    (159) input -> INPUT LPAREN value RPAREN .

    FMT_LIBRARY     reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    FUNC            reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    IDENTIFIER      reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    INPUT           reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    IF              reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    VAR             reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    CONST           reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    SWITCH          reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    FOR             reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    STRING          reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    INTEGER         reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    FLOAT           reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    BOOLEAN         reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    BREAK           reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    CONTINUE        reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    PASS            reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    $end            reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    RKEY            reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    RETURN          reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    CASE            reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)
    DEFAULT         reduce using rule 159 (input -> INPUT LPAREN value RPAREN .)


state 155

    (160) input -> INPUT LPAREN identifiers RPAREN .

    FMT_LIBRARY     reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    FUNC            reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    IDENTIFIER      reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    INPUT           reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    IF              reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    VAR             reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    CONST           reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    SWITCH          reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    FOR             reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    STRING          reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    INTEGER         reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    FLOAT           reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    BOOLEAN         reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    BREAK           reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    CONTINUE        reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    PASS            reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    $end            reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    RKEY            reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    RETURN          reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    CASE            reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)
    DEFAULT         reduce using rule 160 (input -> INPUT LPAREN identifiers RPAREN .)


state 156

    (128) identifiers -> identifiers COMMA . identifiers
    (127) identifiers -> . IDENTIFIER
    (128) identifiers -> . identifiers COMMA identifiers

    IDENTIFIER      shift and go to state 202

    identifiers                    shift and go to state 201

state 157

    (37) if_statement -> IF comparation_operation LKEY program . RKEY
    (38) if_statement -> IF comparation_operation LKEY program . RKEY conditions_elseif
    (39) if_statement -> IF comparation_operation LKEY program . RKEY ELSE LKEY program RKEY
    (40) if_statement -> IF comparation_operation LKEY program . RKEY conditions_elseif ELSE LKEY program RKEY
    (13) program -> program . sentencia
    (14) program -> program . loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 203
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    sentencia                      shift and go to state 40
    loop                           shift and go to state 41
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 158

    (143) call_function -> IDENTIFIER LPAREN values . RPAREN
    (148) values -> values . COMMA value

    RPAREN          shift and go to state 204
    COMMA           shift and go to state 153


state 159

    (89) assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL . INTEGER

    INTEGER         shift and go to state 205


state 160

    (91) assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL . FLOAT

    FLOAT           shift and go to state 206


state 161

    (93) assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL . STRING

    STRING          shift and go to state 207


state 162

    (95) assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL . BOOLEAN

    BOOLEAN         shift and go to state 208


state 163

    (90) assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL . INTEGER

    INTEGER         shift and go to state 209


state 164

    (92) assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL . FLOAT

    FLOAT           shift and go to state 210


state 165

    (94) assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL . STRING

    STRING          shift and go to state 211


state 166

    (96) assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL . BOOLEAN

    BOOLEAN         shift and go to state 212


state 167

    (44) switch_statement -> SWITCH expression LKEY case_clauses . RKEY
    (45) switch_statement -> SWITCH expression LKEY case_clauses . DEFAULT COLON statements RKEY

    RKEY            shift and go to state 213
    DEFAULT         shift and go to state 214


state 168

    (46) case_clauses -> case_clause . case_clauses
    (46) case_clauses -> . case_clause case_clauses
    (47) case_clauses -> .
    (48) case_clause -> . CASE value COLON statements

    RKEY            reduce using rule 47 (case_clauses -> .)
    DEFAULT         reduce using rule 47 (case_clauses -> .)
    CASE            shift and go to state 169

    case_clause                    shift and go to state 168
    case_clauses                   shift and go to state 215

state 169

    (48) case_clause -> CASE . value COLON statements
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 80

    value                          shift and go to state 216

state 170

    (65) expression -> expression PLUS expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 65 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! MODULE          [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! EQUALEQUAL      [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! NOT_EQUAL       [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! LESS_EQUAL      [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! LESS            [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! GREATER         [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 65 (expression -> expression PLUS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 65 (expression -> expression PLUS expression .) ]


state 171

    (66) expression -> expression MINUS expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 66 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! MODULE          [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! EQUALEQUAL      [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! NOT_EQUAL       [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! LESS_EQUAL      [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! LESS            [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! GREATER         [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 66 (expression -> expression MINUS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 66 (expression -> expression MINUS expression .) ]


state 172

    (67) expression -> expression TIMES expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 67 (expression -> expression TIMES expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! TIMES           [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! MODULE          [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! EQUALEQUAL      [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! NOT_EQUAL       [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! LESS_EQUAL      [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! LESS            [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! GREATER         [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! LOGICAL_AND     [ reduce using rule 67 (expression -> expression TIMES expression .) ]
  ! LOGICAL_OR      [ reduce using rule 67 (expression -> expression TIMES expression .) ]


state 173

    (68) expression -> expression DIVIDE expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 68 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! MODULE          [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! EQUALEQUAL      [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! NOT_EQUAL       [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! LESS_EQUAL      [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! LESS            [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! GREATER         [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! LOGICAL_AND     [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]
  ! LOGICAL_OR      [ reduce using rule 68 (expression -> expression DIVIDE expression .) ]


state 174

    (69) expression -> expression ENTERE_DIVIDE expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! MODULE          [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! EQUALEQUAL      [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! NOT_EQUAL       [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! LESS_EQUAL      [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! LESS            [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! GREATER         [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! LOGICAL_AND     [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! LOGICAL_OR      [ reduce using rule 69 (expression -> expression ENTERE_DIVIDE expression .) ]


state 175

    (70) expression -> expression MODULE expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 70 (expression -> expression MODULE expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! MINUS           [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! TIMES           [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! DIVIDE          [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! MODULE          [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! EQUALEQUAL      [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! NOT_EQUAL       [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! LESS_EQUAL      [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! LESS            [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! GREATER         [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! LOGICAL_AND     [ reduce using rule 70 (expression -> expression MODULE expression .) ]
  ! LOGICAL_OR      [ reduce using rule 70 (expression -> expression MODULE expression .) ]


state 176

    (71) expression -> expression EQUALEQUAL expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 71 (expression -> expression EQUALEQUAL expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! MINUS           [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! TIMES           [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! MODULE          [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! EQUALEQUAL      [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! LESS            [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! GREATER         [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! LOGICAL_AND     [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]
  ! LOGICAL_OR      [ reduce using rule 71 (expression -> expression EQUALEQUAL expression .) ]


state 177

    (72) expression -> expression NOT_EQUAL expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 72 (expression -> expression NOT_EQUAL expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! EQUALEQUAL      [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! LESS            [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! LOGICAL_AND     [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]
  ! LOGICAL_OR      [ reduce using rule 72 (expression -> expression NOT_EQUAL expression .) ]


state 178

    (73) expression -> expression LESS_EQUAL expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 73 (expression -> expression LESS_EQUAL expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! EQUALEQUAL      [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! LESS            [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! LOGICAL_AND     [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]
  ! LOGICAL_OR      [ reduce using rule 73 (expression -> expression LESS_EQUAL expression .) ]


state 179

    (74) expression -> expression GREATER_EQUAL expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 74 (expression -> expression GREATER_EQUAL expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! EQUALEQUAL      [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! LESS            [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! LOGICAL_AND     [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]
  ! LOGICAL_OR      [ reduce using rule 74 (expression -> expression GREATER_EQUAL expression .) ]


state 180

    (75) expression -> expression LESS expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 75 (expression -> expression LESS expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! MINUS           [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! TIMES           [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! DIVIDE          [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! MODULE          [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! EQUALEQUAL      [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! NOT_EQUAL       [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! LESS_EQUAL      [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! LESS            [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! GREATER         [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 75 (expression -> expression LESS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 75 (expression -> expression LESS expression .) ]


state 181

    (76) expression -> expression GREATER expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 76 (expression -> expression GREATER expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! MINUS           [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! TIMES           [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! DIVIDE          [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! MODULE          [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! EQUALEQUAL      [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! NOT_EQUAL       [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! LESS_EQUAL      [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! LESS            [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! GREATER         [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! LOGICAL_AND     [ reduce using rule 76 (expression -> expression GREATER expression .) ]
  ! LOGICAL_OR      [ reduce using rule 76 (expression -> expression GREATER expression .) ]


state 182

    (77) expression -> expression LOGICAL_AND expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 77 (expression -> expression LOGICAL_AND expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! MINUS           [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! TIMES           [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! DIVIDE          [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! MODULE          [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! EQUALEQUAL      [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! NOT_EQUAL       [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! LESS_EQUAL      [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! LESS            [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! GREATER         [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! LOGICAL_AND     [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]
  ! LOGICAL_OR      [ reduce using rule 77 (expression -> expression LOGICAL_AND expression .) ]


state 183

    (78) expression -> expression LOGICAL_OR expression .
    (65) expression -> expression . PLUS expression
    (66) expression -> expression . MINUS expression
    (67) expression -> expression . TIMES expression
    (68) expression -> expression . DIVIDE expression
    (69) expression -> expression . ENTERE_DIVIDE expression
    (70) expression -> expression . MODULE expression
    (71) expression -> expression . EQUALEQUAL expression
    (72) expression -> expression . NOT_EQUAL expression
    (73) expression -> expression . LESS_EQUAL expression
    (74) expression -> expression . GREATER_EQUAL expression
    (75) expression -> expression . LESS expression
    (76) expression -> expression . GREATER expression
    (77) expression -> expression . LOGICAL_AND expression
    (78) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 78 (expression -> expression LOGICAL_OR expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 131
    TIMES           shift and go to state 132
    DIVIDE          shift and go to state 133
    ENTERE_DIVIDE   shift and go to state 134
    MODULE          shift and go to state 135
    EQUALEQUAL      shift and go to state 136
    NOT_EQUAL       shift and go to state 137
    LESS_EQUAL      shift and go to state 138
    GREATER_EQUAL   shift and go to state 139
    LESS            shift and go to state 140
    GREATER         shift and go to state 141
    LOGICAL_AND     shift and go to state 142
    LOGICAL_OR      shift and go to state 143

  ! PLUS            [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! MINUS           [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! TIMES           [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! DIVIDE          [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! MODULE          [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! EQUALEQUAL      [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! NOT_EQUAL       [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! LESS_EQUAL      [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! LESS            [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! GREATER         [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! LOGICAL_AND     [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]
  ! LOGICAL_OR      [ reduce using rule 78 (expression -> expression LOGICAL_OR expression .) ]


state 184

    (31) for -> FOR LKEY loop_program RKEY .

    FMT_LIBRARY     reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    FUNC            reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    IDENTIFIER      reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    INPUT           reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    IF              reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    VAR             reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    CONST           reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    SWITCH          reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    FOR             reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    STRING          reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    INTEGER         reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    FLOAT           reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    BOOLEAN         reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    BREAK           reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    CONTINUE        reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    PASS            reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    $end            reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    RKEY            reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)
    RETURN          reduce using rule 31 (for -> FOR LKEY loop_program RKEY .)


state 185

    (32) for -> FOR comparation_operation LKEY loop_program . RKEY
    (3) loop_program -> loop_program . program
    (4) loop_program -> loop_program . loop_reserved
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (15) loop_reserved -> . BREAK
    (16) loop_reserved -> . CONTINUE
    (17) loop_reserved -> . PASS
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 217
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PASS            shift and go to state 8
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    program                        shift and go to state 38
    loop_reserved                  shift and go to state 39
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 186

    (33) for -> FOR short_assignment SEMICOLON comparation_operation . SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (102) usable_value -> comparation_operation .

    SEMICOLON       shift and go to state 218
    EQUALEQUAL      reduce using rule 102 (usable_value -> comparation_operation .)
    NOT_EQUAL       reduce using rule 102 (usable_value -> comparation_operation .)
    LESS_EQUAL      reduce using rule 102 (usable_value -> comparation_operation .)
    GREATER_EQUAL   reduce using rule 102 (usable_value -> comparation_operation .)
    LESS            reduce using rule 102 (usable_value -> comparation_operation .)
    GREATER         reduce using rule 102 (usable_value -> comparation_operation .)
    LOGICAL_AND     reduce using rule 102 (usable_value -> comparation_operation .)
    LOGICAL_OR      reduce using rule 102 (usable_value -> comparation_operation .)
    PLUS            reduce using rule 102 (usable_value -> comparation_operation .)
    MINUS           reduce using rule 102 (usable_value -> comparation_operation .)
    DIVIDE          reduce using rule 102 (usable_value -> comparation_operation .)
    TIMES           reduce using rule 102 (usable_value -> comparation_operation .)
    ENTERE_DIVIDE   reduce using rule 102 (usable_value -> comparation_operation .)
    MODULE          reduce using rule 102 (usable_value -> comparation_operation .)


state 187

    (79) print -> FMT_LIBRARY DOT PRINTLN LPAREN data . RPAREN
    (85) data -> data . COMMA value
    (86) data -> data . COMMA IDENTIFIER

    RPAREN          shift and go to state 219
    COMMA           shift and go to state 220


state 188

    (87) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .

    FMT_LIBRARY     reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FUNC            reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    INPUT           reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    IF              reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    VAR             reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    CONST           reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    SWITCH          reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FOR             reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    STRING          reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    INTEGER         reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FLOAT           reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    BOOLEAN         reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    BREAK           reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    CONTINUE        reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    PASS            reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    $end            reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    RKEY            reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    RETURN          reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    CASE            reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    DEFAULT         reduce using rule 87 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)


state 189

    (83) data -> value .

    RPAREN          reduce using rule 83 (data -> value .)
    COMMA           reduce using rule 83 (data -> value .)


state 190

    (84) data -> IDENTIFIER .
    (153) value -> IDENTIFIER .

  ! reduce/reduce conflict for RPAREN resolved using rule 84 (data -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 84 (data -> IDENTIFIER .)
    RPAREN          reduce using rule 84 (data -> IDENTIFIER .)
    COMMA           reduce using rule 84 (data -> IDENTIFIER .)

  ! RPAREN          [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 153 (value -> IDENTIFIER .) ]


state 191

    (80) print -> FMT_LIBRARY DOT PRINTF LPAREN STRING . RPAREN
    (81) print -> FMT_LIBRARY DOT PRINTF LPAREN STRING . COMMA RPAREN
    (82) print -> FMT_LIBRARY DOT PRINTF LPAREN STRING . COMMA data RPAREN

    RPAREN          shift and go to state 221
    COMMA           shift and go to state 222


state 192

    (88) print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .

    FMT_LIBRARY     reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FUNC            reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    INPUT           reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    IF              reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    VAR             reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    CONST           reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    SWITCH          reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FOR             reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    STRING          reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    INTEGER         reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FLOAT           reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    BOOLEAN         reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    BREAK           reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    CONTINUE        reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    PASS            reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    $end            reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    RKEY            reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    RETURN          reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    CASE            reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    DEFAULT         reduce using rule 88 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)


state 193

    (146) parameter -> IDENTIFIER data_type .

    RPAREN          reduce using rule 146 (parameter -> IDENTIFIER data_type .)
    COMMA           reduce using rule 146 (parameter -> IDENTIFIER data_type .)


state 194

    (154) data_type -> INTEGER_DATA_TYPE .

    RPAREN          reduce using rule 154 (data_type -> INTEGER_DATA_TYPE .)
    COMMA           reduce using rule 154 (data_type -> INTEGER_DATA_TYPE .)
    LKEY            reduce using rule 154 (data_type -> INTEGER_DATA_TYPE .)


state 195

    (155) data_type -> FLOAT_DATA_TYPE .

    RPAREN          reduce using rule 155 (data_type -> FLOAT_DATA_TYPE .)
    COMMA           reduce using rule 155 (data_type -> FLOAT_DATA_TYPE .)
    LKEY            reduce using rule 155 (data_type -> FLOAT_DATA_TYPE .)


state 196

    (156) data_type -> BOOLEAN_DATA_TYPE .

    RPAREN          reduce using rule 156 (data_type -> BOOLEAN_DATA_TYPE .)
    COMMA           reduce using rule 156 (data_type -> BOOLEAN_DATA_TYPE .)
    LKEY            reduce using rule 156 (data_type -> BOOLEAN_DATA_TYPE .)


state 197

    (157) data_type -> STRING_DATA_TYPE .

    RPAREN          reduce using rule 157 (data_type -> STRING_DATA_TYPE .)
    COMMA           reduce using rule 157 (data_type -> STRING_DATA_TYPE .)
    LKEY            reduce using rule 157 (data_type -> STRING_DATA_TYPE .)


state 198

    (141) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN . LKEY func_program RKEY
    (142) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN . data_type LKEY func_program RKEY
    (154) data_type -> . INTEGER_DATA_TYPE
    (155) data_type -> . FLOAT_DATA_TYPE
    (156) data_type -> . BOOLEAN_DATA_TYPE
    (157) data_type -> . STRING_DATA_TYPE

    LKEY            shift and go to state 223
    INTEGER_DATA_TYPE shift and go to state 194
    FLOAT_DATA_TYPE shift and go to state 195
    BOOLEAN_DATA_TYPE shift and go to state 196
    STRING_DATA_TYPE shift and go to state 197

    data_type                      shift and go to state 224

state 199

    (145) parameters -> parameters COMMA . parameter
    (146) parameter -> . IDENTIFIER data_type

    IDENTIFIER      shift and go to state 149

    parameter                      shift and go to state 225

state 200

    (148) values -> values COMMA value .

    RPAREN          reduce using rule 148 (values -> values COMMA value .)
    COMMA           reduce using rule 148 (values -> values COMMA value .)


state 201

    (128) identifiers -> identifiers COMMA identifiers .
    (128) identifiers -> identifiers . COMMA identifiers

  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 128 (identifiers -> identifiers COMMA identifiers .)
    COMMA           shift and go to state 156

  ! COMMA           [ reduce using rule 128 (identifiers -> identifiers COMMA identifiers .) ]


state 202

    (127) identifiers -> IDENTIFIER .

    COMMA           reduce using rule 127 (identifiers -> IDENTIFIER .)
    RPAREN          reduce using rule 127 (identifiers -> IDENTIFIER .)


state 203

    (37) if_statement -> IF comparation_operation LKEY program RKEY .
    (38) if_statement -> IF comparation_operation LKEY program RKEY . conditions_elseif
    (39) if_statement -> IF comparation_operation LKEY program RKEY . ELSE LKEY program RKEY
    (40) if_statement -> IF comparation_operation LKEY program RKEY . conditions_elseif ELSE LKEY program RKEY
    (41) conditions_elseif -> . else_if
    (42) conditions_elseif -> . conditions_elseif else_if
    (43) else_if -> . ELSE IF comparation_operation LKEY program RKEY

    FMT_LIBRARY     reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    FUNC            reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    IDENTIFIER      reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    INPUT           reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    IF              reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    VAR             reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    CONST           reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    SWITCH          reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    FOR             reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    STRING          reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    INTEGER         reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    FLOAT           reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    BOOLEAN         reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    BREAK           reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    CONTINUE        reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    PASS            reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    $end            reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    RKEY            reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    RETURN          reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    CASE            reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    DEFAULT         reduce using rule 37 (if_statement -> IF comparation_operation LKEY program RKEY .)
    ELSE            shift and go to state 227

    conditions_elseif              shift and go to state 226
    else_if                        shift and go to state 228

state 204

    (143) call_function -> IDENTIFIER LPAREN values RPAREN .

    EQUALEQUAL      reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    NOT_EQUAL       reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS_EQUAL      reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER_EQUAL   reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS            reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER         reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_AND     reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_OR      reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    PLUS            reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MINUS           reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    DIVIDE          reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    TIMES           reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    ENTERE_DIVIDE   reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MODULE          reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FMT_LIBRARY     reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FUNC            reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    INPUT           reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    SWITCH          reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    STRING          reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER         reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FLOAT           reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN         reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    BREAK           reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    CONTINUE        reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    PASS            reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    $end            reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    RKEY            reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    SEMICOLON       reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    RETURN          reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    CASE            reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    DEFAULT         reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LKEY            reduce using rule 143 (call_function -> IDENTIFIER LPAREN values RPAREN .)


state 205

    (89) assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .

    FMT_LIBRARY     reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    FUNC            reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    IDENTIFIER      reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    INPUT           reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    IF              reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    VAR             reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    CONST           reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    SWITCH          reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    FOR             reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    STRING          reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    INTEGER         reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    FLOAT           reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    BOOLEAN         reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    BREAK           reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    CONTINUE        reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    PASS            reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    $end            reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    RKEY            reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    RETURN          reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    CASE            reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    DEFAULT         reduce using rule 89 (assignment_semantic -> VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)


state 206

    (91) assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .

    FMT_LIBRARY     reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    FUNC            reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    IDENTIFIER      reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    INPUT           reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    IF              reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    VAR             reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    CONST           reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    SWITCH          reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    FOR             reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    STRING          reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    INTEGER         reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    FLOAT           reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    BOOLEAN         reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    BREAK           reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    CONTINUE        reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    PASS            reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    $end            reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    RKEY            reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    RETURN          reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    CASE            reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    DEFAULT         reduce using rule 91 (assignment_semantic -> VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)


state 207

    (93) assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .

    FMT_LIBRARY     reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    FUNC            reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    IDENTIFIER      reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    INPUT           reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    IF              reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    VAR             reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    CONST           reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    SWITCH          reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    FOR             reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    STRING          reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    INTEGER         reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    FLOAT           reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    BOOLEAN         reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    BREAK           reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    CONTINUE        reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    PASS            reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    $end            reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    RKEY            reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    RETURN          reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    CASE            reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    DEFAULT         reduce using rule 93 (assignment_semantic -> VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)


state 208

    (95) assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .

    FMT_LIBRARY     reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    FUNC            reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    IDENTIFIER      reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    INPUT           reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    IF              reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    VAR             reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    CONST           reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    SWITCH          reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    FOR             reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    STRING          reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    INTEGER         reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    FLOAT           reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    BOOLEAN         reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    BREAK           reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    CONTINUE        reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    PASS            reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    $end            reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    RKEY            reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    RETURN          reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    CASE            reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    DEFAULT         reduce using rule 95 (assignment_semantic -> VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)


state 209

    (90) assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .

    FMT_LIBRARY     reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    FUNC            reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    IDENTIFIER      reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    INPUT           reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    IF              reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    VAR             reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    CONST           reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    SWITCH          reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    FOR             reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    STRING          reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    INTEGER         reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    FLOAT           reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    BOOLEAN         reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    BREAK           reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    CONTINUE        reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    PASS            reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    $end            reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    RKEY            reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    RETURN          reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    CASE            reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)
    DEFAULT         reduce using rule 90 (assignment_semantic -> CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER .)


state 210

    (92) assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .

    FMT_LIBRARY     reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    FUNC            reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    IDENTIFIER      reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    INPUT           reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    IF              reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    VAR             reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    CONST           reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    SWITCH          reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    FOR             reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    STRING          reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    INTEGER         reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    FLOAT           reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    BOOLEAN         reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    BREAK           reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    CONTINUE        reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    PASS            reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    $end            reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    RKEY            reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    RETURN          reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    CASE            reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)
    DEFAULT         reduce using rule 92 (assignment_semantic -> CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT .)


state 211

    (94) assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .

    FMT_LIBRARY     reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    FUNC            reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    IDENTIFIER      reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    INPUT           reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    IF              reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    VAR             reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    CONST           reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    SWITCH          reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    FOR             reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    STRING          reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    INTEGER         reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    FLOAT           reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    BOOLEAN         reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    BREAK           reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    CONTINUE        reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    PASS            reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    $end            reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    RKEY            reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    RETURN          reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    CASE            reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)
    DEFAULT         reduce using rule 94 (assignment_semantic -> CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING .)


state 212

    (96) assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .

    FMT_LIBRARY     reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    FUNC            reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    IDENTIFIER      reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    INPUT           reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    IF              reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    VAR             reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    CONST           reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    SWITCH          reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    FOR             reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    STRING          reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    INTEGER         reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    FLOAT           reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    BOOLEAN         reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    BREAK           reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    CONTINUE        reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    PASS            reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    $end            reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    RKEY            reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    RETURN          reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    CASE            reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)
    DEFAULT         reduce using rule 96 (assignment_semantic -> CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN .)


state 213

    (44) switch_statement -> SWITCH expression LKEY case_clauses RKEY .

    FMT_LIBRARY     reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    FUNC            reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    IDENTIFIER      reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    INPUT           reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    IF              reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    VAR             reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    CONST           reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    SWITCH          reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    FOR             reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    STRING          reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    INTEGER         reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    FLOAT           reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    BOOLEAN         reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    BREAK           reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    CONTINUE        reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    PASS            reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    $end            reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    RKEY            reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    RETURN          reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    CASE            reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    DEFAULT         reduce using rule 44 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)


state 214

    (45) switch_statement -> SWITCH expression LKEY case_clauses DEFAULT . COLON statements RKEY

    COLON           shift and go to state 229


state 215

    (46) case_clauses -> case_clause case_clauses .

    RKEY            reduce using rule 46 (case_clauses -> case_clause case_clauses .)
    DEFAULT         reduce using rule 46 (case_clauses -> case_clause case_clauses .)


state 216

    (48) case_clause -> CASE value . COLON statements

    COLON           shift and go to state 230


state 217

    (32) for -> FOR comparation_operation LKEY loop_program RKEY .

    FMT_LIBRARY     reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FUNC            reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    IDENTIFIER      reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    INPUT           reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    IF              reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    VAR             reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    CONST           reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    SWITCH          reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FOR             reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    STRING          reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    INTEGER         reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FLOAT           reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    BOOLEAN         reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    BREAK           reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    CONTINUE        reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    PASS            reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    $end            reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    RKEY            reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    RETURN          reduce using rule 32 (for -> FOR comparation_operation LKEY loop_program RKEY .)


state 218

    (33) for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON . IDENTIFIER operator_for LKEY loop_program RKEY

    IDENTIFIER      shift and go to state 231


state 219

    (79) print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .

    FMT_LIBRARY     reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FUNC            reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    IDENTIFIER      reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    INPUT           reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    IF              reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    VAR             reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    CONST           reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    SWITCH          reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FOR             reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    STRING          reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    INTEGER         reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FLOAT           reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    BOOLEAN         reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    BREAK           reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    CONTINUE        reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    PASS            reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    $end            reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    RKEY            reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    RETURN          reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    CASE            reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    DEFAULT         reduce using rule 79 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)


state 220

    (85) data -> data COMMA . value
    (86) data -> data COMMA . IDENTIFIER
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    IDENTIFIER      shift and go to state 233
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    value                          shift and go to state 232

state 221

    (80) print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .

    FMT_LIBRARY     reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    FUNC            reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    IDENTIFIER      reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    INPUT           reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    IF              reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    VAR             reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    CONST           reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    SWITCH          reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    FOR             reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    STRING          reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    INTEGER         reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    FLOAT           reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    BOOLEAN         reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    BREAK           reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    CONTINUE        reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    PASS            reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    $end            reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    RKEY            reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    RETURN          reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    CASE            reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)
    DEFAULT         reduce using rule 80 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN .)


state 222

    (81) print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA . RPAREN
    (82) print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA . data RPAREN
    (83) data -> . value
    (84) data -> . IDENTIFIER
    (85) data -> . data COMMA value
    (86) data -> . data COMMA IDENTIFIER
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER

    RPAREN          shift and go to state 234
    IDENTIFIER      shift and go to state 190
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    data                           shift and go to state 235
    value                          shift and go to state 189

state 223

    (141) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY . func_program RKEY
    (5) func_program -> . program
    (6) func_program -> . RETURN
    (7) func_program -> . RETURN usable_value
    (8) func_program -> . func_program program
    (9) func_program -> . func_program RETURN
    (10) func_program -> . func_program RETURN usable_value
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RETURN          shift and go to state 238
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    func_program                   shift and go to state 236
    program                        shift and go to state 237
    usable_value                   shift and go to state 28
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    comparation_operation          shift and go to state 30

state 224

    (142) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type . LKEY func_program RKEY

    LKEY            shift and go to state 239


state 225

    (145) parameters -> parameters COMMA parameter .

    RPAREN          reduce using rule 145 (parameters -> parameters COMMA parameter .)
    COMMA           reduce using rule 145 (parameters -> parameters COMMA parameter .)


state 226

    (38) if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .
    (40) if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif . ELSE LKEY program RKEY
    (42) conditions_elseif -> conditions_elseif . else_if
    (43) else_if -> . ELSE IF comparation_operation LKEY program RKEY

    FMT_LIBRARY     reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    FUNC            reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    IDENTIFIER      reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    INPUT           reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    IF              reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    VAR             reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    CONST           reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    SWITCH          reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    FOR             reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    STRING          reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    INTEGER         reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    FLOAT           reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    BOOLEAN         reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    BREAK           reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    CONTINUE        reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    PASS            reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    $end            reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    RKEY            reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    RETURN          reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    CASE            reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    DEFAULT         reduce using rule 38 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif .)
    ELSE            shift and go to state 240

    else_if                        shift and go to state 241

state 227

    (39) if_statement -> IF comparation_operation LKEY program RKEY ELSE . LKEY program RKEY
    (43) else_if -> ELSE . IF comparation_operation LKEY program RKEY

    LKEY            shift and go to state 243
    IF              shift and go to state 242


state 228

    (41) conditions_elseif -> else_if .

    ELSE            reduce using rule 41 (conditions_elseif -> else_if .)
    FMT_LIBRARY     reduce using rule 41 (conditions_elseif -> else_if .)
    FUNC            reduce using rule 41 (conditions_elseif -> else_if .)
    IDENTIFIER      reduce using rule 41 (conditions_elseif -> else_if .)
    INPUT           reduce using rule 41 (conditions_elseif -> else_if .)
    IF              reduce using rule 41 (conditions_elseif -> else_if .)
    VAR             reduce using rule 41 (conditions_elseif -> else_if .)
    CONST           reduce using rule 41 (conditions_elseif -> else_if .)
    SWITCH          reduce using rule 41 (conditions_elseif -> else_if .)
    FOR             reduce using rule 41 (conditions_elseif -> else_if .)
    STRING          reduce using rule 41 (conditions_elseif -> else_if .)
    INTEGER         reduce using rule 41 (conditions_elseif -> else_if .)
    FLOAT           reduce using rule 41 (conditions_elseif -> else_if .)
    BOOLEAN         reduce using rule 41 (conditions_elseif -> else_if .)
    BREAK           reduce using rule 41 (conditions_elseif -> else_if .)
    CONTINUE        reduce using rule 41 (conditions_elseif -> else_if .)
    PASS            reduce using rule 41 (conditions_elseif -> else_if .)
    $end            reduce using rule 41 (conditions_elseif -> else_if .)
    RKEY            reduce using rule 41 (conditions_elseif -> else_if .)
    RETURN          reduce using rule 41 (conditions_elseif -> else_if .)
    CASE            reduce using rule 41 (conditions_elseif -> else_if .)
    DEFAULT         reduce using rule 41 (conditions_elseif -> else_if .)


state 229

    (45) switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON . statements RKEY
    (49) statements -> . statement statements
    (50) statements -> .
    (51) statement -> . print
    (52) statement -> . print_withoutvalue
    (53) statement -> . def_function
    (54) statement -> . call_function
    (55) statement -> . input
    (56) statement -> . short_assignment
    (57) statement -> . arithmetic_operation
    (58) statement -> . direct_arithmetic_operation
    (59) statement -> . if_statement
    (60) statement -> . function_call
    (61) statement -> . switch_statement
    (62) statement -> . assignment_semantic
    (63) statement -> . statement
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            reduce using rule 50 (statements -> .)
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    SWITCH          shift and go to state 36
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    statements                     shift and go to state 244
    statement                      shift and go to state 245
    print                          shift and go to state 246
    print_withoutvalue             shift and go to state 247
    def_function                   shift and go to state 248
    call_function                  shift and go to state 249
    input                          shift and go to state 250
    short_assignment               shift and go to state 251
    arithmetic_operation           shift and go to state 252
    direct_arithmetic_operation    shift and go to state 253
    if_statement                   shift and go to state 254
    function_call                  shift and go to state 255
    switch_statement               shift and go to state 256
    assignment_semantic            shift and go to state 257
    value                          shift and go to state 27
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 230

    (48) case_clause -> CASE value COLON . statements
    (49) statements -> . statement statements
    (50) statements -> .
    (51) statement -> . print
    (52) statement -> . print_withoutvalue
    (53) statement -> . def_function
    (54) statement -> . call_function
    (55) statement -> . input
    (56) statement -> . short_assignment
    (57) statement -> . arithmetic_operation
    (58) statement -> . direct_arithmetic_operation
    (59) statement -> . if_statement
    (60) statement -> . function_call
    (61) statement -> . switch_statement
    (62) statement -> . assignment_semantic
    (63) statement -> . statement
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    CASE            reduce using rule 50 (statements -> .)
    RKEY            reduce using rule 50 (statements -> .)
    DEFAULT         reduce using rule 50 (statements -> .)
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    SWITCH          shift and go to state 36
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    value                          shift and go to state 27
    statements                     shift and go to state 258
    statement                      shift and go to state 245
    print                          shift and go to state 246
    print_withoutvalue             shift and go to state 247
    def_function                   shift and go to state 248
    call_function                  shift and go to state 249
    input                          shift and go to state 250
    short_assignment               shift and go to state 251
    arithmetic_operation           shift and go to state 252
    direct_arithmetic_operation    shift and go to state 253
    if_statement                   shift and go to state 254
    function_call                  shift and go to state 255
    switch_statement               shift and go to state 256
    assignment_semantic            shift and go to state 257
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 231

    (33) for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER . operator_for LKEY loop_program RKEY
    (34) operator_for -> . INCREASE
    (35) operator_for -> . DECREASE

    INCREASE        shift and go to state 260
    DECREASE        shift and go to state 261

    operator_for                   shift and go to state 259

state 232

    (85) data -> data COMMA value .

    RPAREN          reduce using rule 85 (data -> data COMMA value .)
    COMMA           reduce using rule 85 (data -> data COMMA value .)


state 233

    (86) data -> data COMMA IDENTIFIER .
    (153) value -> IDENTIFIER .

  ! reduce/reduce conflict for RPAREN resolved using rule 86 (data -> data COMMA IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 86 (data -> data COMMA IDENTIFIER .)
    RPAREN          reduce using rule 86 (data -> data COMMA IDENTIFIER .)
    COMMA           reduce using rule 86 (data -> data COMMA IDENTIFIER .)

  ! RPAREN          [ reduce using rule 153 (value -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 153 (value -> IDENTIFIER .) ]


state 234

    (81) print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .

    FMT_LIBRARY     reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    FUNC            reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    IDENTIFIER      reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    INPUT           reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    IF              reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    VAR             reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    CONST           reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    SWITCH          reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    FOR             reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    STRING          reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    INTEGER         reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    FLOAT           reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    BOOLEAN         reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    BREAK           reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    CONTINUE        reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    PASS            reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    $end            reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    RKEY            reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    RETURN          reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    CASE            reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)
    DEFAULT         reduce using rule 81 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN .)


state 235

    (82) print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data . RPAREN
    (85) data -> data . COMMA value
    (86) data -> data . COMMA IDENTIFIER

    RPAREN          shift and go to state 262
    COMMA           shift and go to state 220


state 236

    (141) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program . RKEY
    (8) func_program -> func_program . program
    (9) func_program -> func_program . RETURN
    (10) func_program -> func_program . RETURN usable_value
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 263
    RETURN          shift and go to state 265
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    program                        shift and go to state 264
    usable_value                   shift and go to state 28
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    comparation_operation          shift and go to state 30

state 237

    (5) func_program -> program .
    (13) program -> program . sentencia
    (14) program -> program . loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! shift/reduce conflict for FMT_LIBRARY resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RKEY            reduce using rule 5 (func_program -> program .)
    RETURN          reduce using rule 5 (func_program -> program .)
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

  ! FMT_LIBRARY     [ reduce using rule 5 (func_program -> program .) ]
  ! FUNC            [ reduce using rule 5 (func_program -> program .) ]
  ! IDENTIFIER      [ reduce using rule 5 (func_program -> program .) ]
  ! INPUT           [ reduce using rule 5 (func_program -> program .) ]
  ! IF              [ reduce using rule 5 (func_program -> program .) ]
  ! VAR             [ reduce using rule 5 (func_program -> program .) ]
  ! CONST           [ reduce using rule 5 (func_program -> program .) ]
  ! SWITCH          [ reduce using rule 5 (func_program -> program .) ]
  ! FOR             [ reduce using rule 5 (func_program -> program .) ]
  ! STRING          [ reduce using rule 5 (func_program -> program .) ]
  ! INTEGER         [ reduce using rule 5 (func_program -> program .) ]
  ! FLOAT           [ reduce using rule 5 (func_program -> program .) ]
  ! BOOLEAN         [ reduce using rule 5 (func_program -> program .) ]

    sentencia                      shift and go to state 40
    loop                           shift and go to state 41
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 238

    (6) func_program -> RETURN .
    (7) func_program -> RETURN . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RKEY            reduce using rule 6 (func_program -> RETURN .)
    RETURN          reduce using rule 6 (func_program -> RETURN .)
    FMT_LIBRARY     reduce using rule 6 (func_program -> RETURN .)
    FUNC            reduce using rule 6 (func_program -> RETURN .)
    INPUT           reduce using rule 6 (func_program -> RETURN .)
    IF              reduce using rule 6 (func_program -> RETURN .)
    VAR             reduce using rule 6 (func_program -> RETURN .)
    CONST           reduce using rule 6 (func_program -> RETURN .)
    SWITCH          reduce using rule 6 (func_program -> RETURN .)
    FOR             reduce using rule 6 (func_program -> RETURN .)
    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

  ! IDENTIFIER      [ reduce using rule 6 (func_program -> RETURN .) ]
  ! STRING          [ reduce using rule 6 (func_program -> RETURN .) ]
  ! INTEGER         [ reduce using rule 6 (func_program -> RETURN .) ]
  ! FLOAT           [ reduce using rule 6 (func_program -> RETURN .) ]
  ! BOOLEAN         [ reduce using rule 6 (func_program -> RETURN .) ]

    usable_value                   shift and go to state 266
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 239

    (142) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY . func_program RKEY
    (5) func_program -> . program
    (6) func_program -> . RETURN
    (7) func_program -> . RETURN usable_value
    (8) func_program -> . func_program program
    (9) func_program -> . func_program RETURN
    (10) func_program -> . func_program RETURN usable_value
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RETURN          shift and go to state 238
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    func_program                   shift and go to state 267
    program                        shift and go to state 237
    usable_value                   shift and go to state 28
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    comparation_operation          shift and go to state 30

state 240

    (40) if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE . LKEY program RKEY
    (43) else_if -> ELSE . IF comparation_operation LKEY program RKEY

    LKEY            shift and go to state 268
    IF              shift and go to state 242


state 241

    (42) conditions_elseif -> conditions_elseif else_if .

    ELSE            reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    FMT_LIBRARY     reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    FUNC            reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    IDENTIFIER      reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    INPUT           reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    IF              reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    VAR             reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    CONST           reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    SWITCH          reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    FOR             reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    STRING          reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    INTEGER         reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    FLOAT           reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    BOOLEAN         reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    BREAK           reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    CONTINUE        reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    PASS            reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    $end            reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    RKEY            reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    RETURN          reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    CASE            reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)
    DEFAULT         reduce using rule 42 (conditions_elseif -> conditions_elseif else_if .)


state 242

    (43) else_if -> ELSE IF . comparation_operation LKEY program RKEY
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value

    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 269
    usable_value                   shift and go to state 72
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75

state 243

    (39) if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY . program RKEY
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    program                        shift and go to state 270
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 244

    (45) switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements . RKEY

    RKEY            shift and go to state 271


state 245

    (49) statements -> statement . statements
    (63) statement -> statement .
    (49) statements -> . statement statements
    (50) statements -> .
    (51) statement -> . print
    (52) statement -> . print_withoutvalue
    (53) statement -> . def_function
    (54) statement -> . call_function
    (55) statement -> . input
    (56) statement -> . short_assignment
    (57) statement -> . arithmetic_operation
    (58) statement -> . direct_arithmetic_operation
    (59) statement -> . if_statement
    (60) statement -> . function_call
    (61) statement -> . switch_statement
    (62) statement -> . assignment_semantic
    (63) statement -> . statement
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! reduce/reduce conflict for RKEY resolved using rule 50 (statements -> .)
  ! reduce/reduce conflict for CASE resolved using rule 50 (statements -> .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 50 (statements -> .)
  ! shift/reduce conflict for FMT_LIBRARY resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RKEY            reduce using rule 50 (statements -> .)
    CASE            reduce using rule 50 (statements -> .)
    DEFAULT         reduce using rule 50 (statements -> .)
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    SWITCH          shift and go to state 36
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

  ! FMT_LIBRARY     [ reduce using rule 63 (statement -> statement .) ]
  ! FUNC            [ reduce using rule 63 (statement -> statement .) ]
  ! IDENTIFIER      [ reduce using rule 63 (statement -> statement .) ]
  ! INPUT           [ reduce using rule 63 (statement -> statement .) ]
  ! IF              [ reduce using rule 63 (statement -> statement .) ]
  ! SWITCH          [ reduce using rule 63 (statement -> statement .) ]
  ! VAR             [ reduce using rule 63 (statement -> statement .) ]
  ! CONST           [ reduce using rule 63 (statement -> statement .) ]
  ! STRING          [ reduce using rule 63 (statement -> statement .) ]
  ! INTEGER         [ reduce using rule 63 (statement -> statement .) ]
  ! FLOAT           [ reduce using rule 63 (statement -> statement .) ]
  ! BOOLEAN         [ reduce using rule 63 (statement -> statement .) ]
  ! RKEY            [ reduce using rule 63 (statement -> statement .) ]
  ! CASE            [ reduce using rule 63 (statement -> statement .) ]
  ! DEFAULT         [ reduce using rule 63 (statement -> statement .) ]

    statement                      shift and go to state 245
    statements                     shift and go to state 272
    print                          shift and go to state 246
    print_withoutvalue             shift and go to state 247
    def_function                   shift and go to state 248
    call_function                  shift and go to state 249
    input                          shift and go to state 250
    short_assignment               shift and go to state 251
    arithmetic_operation           shift and go to state 252
    direct_arithmetic_operation    shift and go to state 253
    if_statement                   shift and go to state 254
    function_call                  shift and go to state 255
    switch_statement               shift and go to state 256
    assignment_semantic            shift and go to state 257
    value                          shift and go to state 27
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 246

    (51) statement -> print .

    FMT_LIBRARY     reduce using rule 51 (statement -> print .)
    FUNC            reduce using rule 51 (statement -> print .)
    IDENTIFIER      reduce using rule 51 (statement -> print .)
    INPUT           reduce using rule 51 (statement -> print .)
    IF              reduce using rule 51 (statement -> print .)
    SWITCH          reduce using rule 51 (statement -> print .)
    VAR             reduce using rule 51 (statement -> print .)
    CONST           reduce using rule 51 (statement -> print .)
    STRING          reduce using rule 51 (statement -> print .)
    INTEGER         reduce using rule 51 (statement -> print .)
    FLOAT           reduce using rule 51 (statement -> print .)
    BOOLEAN         reduce using rule 51 (statement -> print .)
    RKEY            reduce using rule 51 (statement -> print .)
    CASE            reduce using rule 51 (statement -> print .)
    DEFAULT         reduce using rule 51 (statement -> print .)


state 247

    (52) statement -> print_withoutvalue .

    FMT_LIBRARY     reduce using rule 52 (statement -> print_withoutvalue .)
    FUNC            reduce using rule 52 (statement -> print_withoutvalue .)
    IDENTIFIER      reduce using rule 52 (statement -> print_withoutvalue .)
    INPUT           reduce using rule 52 (statement -> print_withoutvalue .)
    IF              reduce using rule 52 (statement -> print_withoutvalue .)
    SWITCH          reduce using rule 52 (statement -> print_withoutvalue .)
    VAR             reduce using rule 52 (statement -> print_withoutvalue .)
    CONST           reduce using rule 52 (statement -> print_withoutvalue .)
    STRING          reduce using rule 52 (statement -> print_withoutvalue .)
    INTEGER         reduce using rule 52 (statement -> print_withoutvalue .)
    FLOAT           reduce using rule 52 (statement -> print_withoutvalue .)
    BOOLEAN         reduce using rule 52 (statement -> print_withoutvalue .)
    RKEY            reduce using rule 52 (statement -> print_withoutvalue .)
    CASE            reduce using rule 52 (statement -> print_withoutvalue .)
    DEFAULT         reduce using rule 52 (statement -> print_withoutvalue .)


state 248

    (53) statement -> def_function .

    FMT_LIBRARY     reduce using rule 53 (statement -> def_function .)
    FUNC            reduce using rule 53 (statement -> def_function .)
    IDENTIFIER      reduce using rule 53 (statement -> def_function .)
    INPUT           reduce using rule 53 (statement -> def_function .)
    IF              reduce using rule 53 (statement -> def_function .)
    SWITCH          reduce using rule 53 (statement -> def_function .)
    VAR             reduce using rule 53 (statement -> def_function .)
    CONST           reduce using rule 53 (statement -> def_function .)
    STRING          reduce using rule 53 (statement -> def_function .)
    INTEGER         reduce using rule 53 (statement -> def_function .)
    FLOAT           reduce using rule 53 (statement -> def_function .)
    BOOLEAN         reduce using rule 53 (statement -> def_function .)
    RKEY            reduce using rule 53 (statement -> def_function .)
    CASE            reduce using rule 53 (statement -> def_function .)
    DEFAULT         reduce using rule 53 (statement -> def_function .)


state 249

    (54) statement -> call_function .
    (99) usable_value -> call_function .

    FMT_LIBRARY     reduce using rule 54 (statement -> call_function .)
    FUNC            reduce using rule 54 (statement -> call_function .)
    IDENTIFIER      reduce using rule 54 (statement -> call_function .)
    INPUT           reduce using rule 54 (statement -> call_function .)
    IF              reduce using rule 54 (statement -> call_function .)
    SWITCH          reduce using rule 54 (statement -> call_function .)
    VAR             reduce using rule 54 (statement -> call_function .)
    CONST           reduce using rule 54 (statement -> call_function .)
    STRING          reduce using rule 54 (statement -> call_function .)
    INTEGER         reduce using rule 54 (statement -> call_function .)
    FLOAT           reduce using rule 54 (statement -> call_function .)
    BOOLEAN         reduce using rule 54 (statement -> call_function .)
    RKEY            reduce using rule 54 (statement -> call_function .)
    CASE            reduce using rule 54 (statement -> call_function .)
    DEFAULT         reduce using rule 54 (statement -> call_function .)
    PLUS            reduce using rule 99 (usable_value -> call_function .)
    MINUS           reduce using rule 99 (usable_value -> call_function .)
    DIVIDE          reduce using rule 99 (usable_value -> call_function .)
    TIMES           reduce using rule 99 (usable_value -> call_function .)
    ENTERE_DIVIDE   reduce using rule 99 (usable_value -> call_function .)
    MODULE          reduce using rule 99 (usable_value -> call_function .)
    EQUALEQUAL      reduce using rule 99 (usable_value -> call_function .)
    NOT_EQUAL       reduce using rule 99 (usable_value -> call_function .)
    LESS_EQUAL      reduce using rule 99 (usable_value -> call_function .)
    GREATER_EQUAL   reduce using rule 99 (usable_value -> call_function .)
    LESS            reduce using rule 99 (usable_value -> call_function .)
    GREATER         reduce using rule 99 (usable_value -> call_function .)
    LOGICAL_AND     reduce using rule 99 (usable_value -> call_function .)
    LOGICAL_OR      reduce using rule 99 (usable_value -> call_function .)


state 250

    (55) statement -> input .

    FMT_LIBRARY     reduce using rule 55 (statement -> input .)
    FUNC            reduce using rule 55 (statement -> input .)
    IDENTIFIER      reduce using rule 55 (statement -> input .)
    INPUT           reduce using rule 55 (statement -> input .)
    IF              reduce using rule 55 (statement -> input .)
    SWITCH          reduce using rule 55 (statement -> input .)
    VAR             reduce using rule 55 (statement -> input .)
    CONST           reduce using rule 55 (statement -> input .)
    STRING          reduce using rule 55 (statement -> input .)
    INTEGER         reduce using rule 55 (statement -> input .)
    FLOAT           reduce using rule 55 (statement -> input .)
    BOOLEAN         reduce using rule 55 (statement -> input .)
    RKEY            reduce using rule 55 (statement -> input .)
    CASE            reduce using rule 55 (statement -> input .)
    DEFAULT         reduce using rule 55 (statement -> input .)


state 251

    (56) statement -> short_assignment .

    FMT_LIBRARY     reduce using rule 56 (statement -> short_assignment .)
    FUNC            reduce using rule 56 (statement -> short_assignment .)
    IDENTIFIER      reduce using rule 56 (statement -> short_assignment .)
    INPUT           reduce using rule 56 (statement -> short_assignment .)
    IF              reduce using rule 56 (statement -> short_assignment .)
    SWITCH          reduce using rule 56 (statement -> short_assignment .)
    VAR             reduce using rule 56 (statement -> short_assignment .)
    CONST           reduce using rule 56 (statement -> short_assignment .)
    STRING          reduce using rule 56 (statement -> short_assignment .)
    INTEGER         reduce using rule 56 (statement -> short_assignment .)
    FLOAT           reduce using rule 56 (statement -> short_assignment .)
    BOOLEAN         reduce using rule 56 (statement -> short_assignment .)
    RKEY            reduce using rule 56 (statement -> short_assignment .)
    CASE            reduce using rule 56 (statement -> short_assignment .)
    DEFAULT         reduce using rule 56 (statement -> short_assignment .)


state 252

    (57) statement -> arithmetic_operation .
    (101) usable_value -> arithmetic_operation .

    FMT_LIBRARY     reduce using rule 57 (statement -> arithmetic_operation .)
    FUNC            reduce using rule 57 (statement -> arithmetic_operation .)
    IDENTIFIER      reduce using rule 57 (statement -> arithmetic_operation .)
    INPUT           reduce using rule 57 (statement -> arithmetic_operation .)
    IF              reduce using rule 57 (statement -> arithmetic_operation .)
    SWITCH          reduce using rule 57 (statement -> arithmetic_operation .)
    VAR             reduce using rule 57 (statement -> arithmetic_operation .)
    CONST           reduce using rule 57 (statement -> arithmetic_operation .)
    STRING          reduce using rule 57 (statement -> arithmetic_operation .)
    INTEGER         reduce using rule 57 (statement -> arithmetic_operation .)
    FLOAT           reduce using rule 57 (statement -> arithmetic_operation .)
    BOOLEAN         reduce using rule 57 (statement -> arithmetic_operation .)
    RKEY            reduce using rule 57 (statement -> arithmetic_operation .)
    CASE            reduce using rule 57 (statement -> arithmetic_operation .)
    DEFAULT         reduce using rule 57 (statement -> arithmetic_operation .)
    PLUS            reduce using rule 101 (usable_value -> arithmetic_operation .)
    MINUS           reduce using rule 101 (usable_value -> arithmetic_operation .)
    DIVIDE          reduce using rule 101 (usable_value -> arithmetic_operation .)
    TIMES           reduce using rule 101 (usable_value -> arithmetic_operation .)
    ENTERE_DIVIDE   reduce using rule 101 (usable_value -> arithmetic_operation .)
    MODULE          reduce using rule 101 (usable_value -> arithmetic_operation .)
    EQUALEQUAL      reduce using rule 101 (usable_value -> arithmetic_operation .)
    NOT_EQUAL       reduce using rule 101 (usable_value -> arithmetic_operation .)
    LESS_EQUAL      reduce using rule 101 (usable_value -> arithmetic_operation .)
    GREATER_EQUAL   reduce using rule 101 (usable_value -> arithmetic_operation .)
    LESS            reduce using rule 101 (usable_value -> arithmetic_operation .)
    GREATER         reduce using rule 101 (usable_value -> arithmetic_operation .)
    LOGICAL_AND     reduce using rule 101 (usable_value -> arithmetic_operation .)
    LOGICAL_OR      reduce using rule 101 (usable_value -> arithmetic_operation .)


state 253

    (58) statement -> direct_arithmetic_operation .

    FMT_LIBRARY     reduce using rule 58 (statement -> direct_arithmetic_operation .)
    FUNC            reduce using rule 58 (statement -> direct_arithmetic_operation .)
    IDENTIFIER      reduce using rule 58 (statement -> direct_arithmetic_operation .)
    INPUT           reduce using rule 58 (statement -> direct_arithmetic_operation .)
    IF              reduce using rule 58 (statement -> direct_arithmetic_operation .)
    SWITCH          reduce using rule 58 (statement -> direct_arithmetic_operation .)
    VAR             reduce using rule 58 (statement -> direct_arithmetic_operation .)
    CONST           reduce using rule 58 (statement -> direct_arithmetic_operation .)
    STRING          reduce using rule 58 (statement -> direct_arithmetic_operation .)
    INTEGER         reduce using rule 58 (statement -> direct_arithmetic_operation .)
    FLOAT           reduce using rule 58 (statement -> direct_arithmetic_operation .)
    BOOLEAN         reduce using rule 58 (statement -> direct_arithmetic_operation .)
    RKEY            reduce using rule 58 (statement -> direct_arithmetic_operation .)
    CASE            reduce using rule 58 (statement -> direct_arithmetic_operation .)
    DEFAULT         reduce using rule 58 (statement -> direct_arithmetic_operation .)


state 254

    (59) statement -> if_statement .

    FMT_LIBRARY     reduce using rule 59 (statement -> if_statement .)
    FUNC            reduce using rule 59 (statement -> if_statement .)
    IDENTIFIER      reduce using rule 59 (statement -> if_statement .)
    INPUT           reduce using rule 59 (statement -> if_statement .)
    IF              reduce using rule 59 (statement -> if_statement .)
    SWITCH          reduce using rule 59 (statement -> if_statement .)
    VAR             reduce using rule 59 (statement -> if_statement .)
    CONST           reduce using rule 59 (statement -> if_statement .)
    STRING          reduce using rule 59 (statement -> if_statement .)
    INTEGER         reduce using rule 59 (statement -> if_statement .)
    FLOAT           reduce using rule 59 (statement -> if_statement .)
    BOOLEAN         reduce using rule 59 (statement -> if_statement .)
    RKEY            reduce using rule 59 (statement -> if_statement .)
    CASE            reduce using rule 59 (statement -> if_statement .)
    DEFAULT         reduce using rule 59 (statement -> if_statement .)


state 255

    (60) statement -> function_call .

    FMT_LIBRARY     reduce using rule 60 (statement -> function_call .)
    FUNC            reduce using rule 60 (statement -> function_call .)
    IDENTIFIER      reduce using rule 60 (statement -> function_call .)
    INPUT           reduce using rule 60 (statement -> function_call .)
    IF              reduce using rule 60 (statement -> function_call .)
    SWITCH          reduce using rule 60 (statement -> function_call .)
    VAR             reduce using rule 60 (statement -> function_call .)
    CONST           reduce using rule 60 (statement -> function_call .)
    STRING          reduce using rule 60 (statement -> function_call .)
    INTEGER         reduce using rule 60 (statement -> function_call .)
    FLOAT           reduce using rule 60 (statement -> function_call .)
    BOOLEAN         reduce using rule 60 (statement -> function_call .)
    RKEY            reduce using rule 60 (statement -> function_call .)
    CASE            reduce using rule 60 (statement -> function_call .)
    DEFAULT         reduce using rule 60 (statement -> function_call .)


state 256

    (61) statement -> switch_statement .

    FMT_LIBRARY     reduce using rule 61 (statement -> switch_statement .)
    FUNC            reduce using rule 61 (statement -> switch_statement .)
    IDENTIFIER      reduce using rule 61 (statement -> switch_statement .)
    INPUT           reduce using rule 61 (statement -> switch_statement .)
    IF              reduce using rule 61 (statement -> switch_statement .)
    SWITCH          reduce using rule 61 (statement -> switch_statement .)
    VAR             reduce using rule 61 (statement -> switch_statement .)
    CONST           reduce using rule 61 (statement -> switch_statement .)
    STRING          reduce using rule 61 (statement -> switch_statement .)
    INTEGER         reduce using rule 61 (statement -> switch_statement .)
    FLOAT           reduce using rule 61 (statement -> switch_statement .)
    BOOLEAN         reduce using rule 61 (statement -> switch_statement .)
    RKEY            reduce using rule 61 (statement -> switch_statement .)
    CASE            reduce using rule 61 (statement -> switch_statement .)
    DEFAULT         reduce using rule 61 (statement -> switch_statement .)


state 257

    (62) statement -> assignment_semantic .

    FMT_LIBRARY     reduce using rule 62 (statement -> assignment_semantic .)
    FUNC            reduce using rule 62 (statement -> assignment_semantic .)
    IDENTIFIER      reduce using rule 62 (statement -> assignment_semantic .)
    INPUT           reduce using rule 62 (statement -> assignment_semantic .)
    IF              reduce using rule 62 (statement -> assignment_semantic .)
    SWITCH          reduce using rule 62 (statement -> assignment_semantic .)
    VAR             reduce using rule 62 (statement -> assignment_semantic .)
    CONST           reduce using rule 62 (statement -> assignment_semantic .)
    STRING          reduce using rule 62 (statement -> assignment_semantic .)
    INTEGER         reduce using rule 62 (statement -> assignment_semantic .)
    FLOAT           reduce using rule 62 (statement -> assignment_semantic .)
    BOOLEAN         reduce using rule 62 (statement -> assignment_semantic .)
    RKEY            reduce using rule 62 (statement -> assignment_semantic .)
    CASE            reduce using rule 62 (statement -> assignment_semantic .)
    DEFAULT         reduce using rule 62 (statement -> assignment_semantic .)


state 258

    (48) case_clause -> CASE value COLON statements .

    CASE            reduce using rule 48 (case_clause -> CASE value COLON statements .)
    RKEY            reduce using rule 48 (case_clause -> CASE value COLON statements .)
    DEFAULT         reduce using rule 48 (case_clause -> CASE value COLON statements .)


state 259

    (33) for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for . LKEY loop_program RKEY

    LKEY            shift and go to state 273


state 260

    (34) operator_for -> INCREASE .

    LKEY            reduce using rule 34 (operator_for -> INCREASE .)


state 261

    (35) operator_for -> DECREASE .

    LKEY            reduce using rule 35 (operator_for -> DECREASE .)


state 262

    (82) print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .

    FMT_LIBRARY     reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    FUNC            reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    IDENTIFIER      reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    INPUT           reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    IF              reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    VAR             reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    CONST           reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    SWITCH          reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    FOR             reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    STRING          reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    INTEGER         reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    FLOAT           reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    BOOLEAN         reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    BREAK           reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    CONTINUE        reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    PASS            reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    $end            reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    RKEY            reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    RETURN          reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    CASE            reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)
    DEFAULT         reduce using rule 82 (print -> FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN .)


state 263

    (141) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .

    FMT_LIBRARY     reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    FUNC            reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    IDENTIFIER      reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    INPUT           reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    IF              reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    VAR             reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    CONST           reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    SWITCH          reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    FOR             reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    STRING          reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    INTEGER         reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    FLOAT           reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    BOOLEAN         reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    BREAK           reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    CONTINUE        reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    PASS            reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    $end            reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    RKEY            reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    RETURN          reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    CASE            reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)
    DEFAULT         reduce using rule 141 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY .)


state 264

    (8) func_program -> func_program program .
    (13) program -> program . sentencia
    (14) program -> program . loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! shift/reduce conflict for FMT_LIBRARY resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RKEY            reduce using rule 8 (func_program -> func_program program .)
    RETURN          reduce using rule 8 (func_program -> func_program program .)
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

  ! FMT_LIBRARY     [ reduce using rule 8 (func_program -> func_program program .) ]
  ! FUNC            [ reduce using rule 8 (func_program -> func_program program .) ]
  ! IDENTIFIER      [ reduce using rule 8 (func_program -> func_program program .) ]
  ! INPUT           [ reduce using rule 8 (func_program -> func_program program .) ]
  ! IF              [ reduce using rule 8 (func_program -> func_program program .) ]
  ! VAR             [ reduce using rule 8 (func_program -> func_program program .) ]
  ! CONST           [ reduce using rule 8 (func_program -> func_program program .) ]
  ! SWITCH          [ reduce using rule 8 (func_program -> func_program program .) ]
  ! FOR             [ reduce using rule 8 (func_program -> func_program program .) ]
  ! STRING          [ reduce using rule 8 (func_program -> func_program program .) ]
  ! INTEGER         [ reduce using rule 8 (func_program -> func_program program .) ]
  ! FLOAT           [ reduce using rule 8 (func_program -> func_program program .) ]
  ! BOOLEAN         [ reduce using rule 8 (func_program -> func_program program .) ]

    sentencia                      shift and go to state 40
    loop                           shift and go to state 41
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28
    comparation_operation          shift and go to state 30

state 265

    (9) func_program -> func_program RETURN .
    (10) func_program -> func_program RETURN . usable_value
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RKEY            reduce using rule 9 (func_program -> func_program RETURN .)
    RETURN          reduce using rule 9 (func_program -> func_program RETURN .)
    FMT_LIBRARY     reduce using rule 9 (func_program -> func_program RETURN .)
    FUNC            reduce using rule 9 (func_program -> func_program RETURN .)
    INPUT           reduce using rule 9 (func_program -> func_program RETURN .)
    IF              reduce using rule 9 (func_program -> func_program RETURN .)
    VAR             reduce using rule 9 (func_program -> func_program RETURN .)
    CONST           reduce using rule 9 (func_program -> func_program RETURN .)
    SWITCH          reduce using rule 9 (func_program -> func_program RETURN .)
    FOR             reduce using rule 9 (func_program -> func_program RETURN .)
    IDENTIFIER      shift and go to state 74
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

  ! IDENTIFIER      [ reduce using rule 9 (func_program -> func_program RETURN .) ]
  ! STRING          [ reduce using rule 9 (func_program -> func_program RETURN .) ]
  ! INTEGER         [ reduce using rule 9 (func_program -> func_program RETURN .) ]
  ! FLOAT           [ reduce using rule 9 (func_program -> func_program RETURN .) ]
  ! BOOLEAN         [ reduce using rule 9 (func_program -> func_program RETURN .) ]

    usable_value                   shift and go to state 274
    value                          shift and go to state 27
    call_function                  shift and go to state 73
    arithmetic_operation           shift and go to state 75
    comparation_operation          shift and go to state 30

state 266

    (7) func_program -> RETURN usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

    RKEY            reduce using rule 7 (func_program -> RETURN usable_value .)
    RETURN          reduce using rule 7 (func_program -> RETURN usable_value .)
    FMT_LIBRARY     reduce using rule 7 (func_program -> RETURN usable_value .)
    FUNC            reduce using rule 7 (func_program -> RETURN usable_value .)
    IDENTIFIER      reduce using rule 7 (func_program -> RETURN usable_value .)
    INPUT           reduce using rule 7 (func_program -> RETURN usable_value .)
    IF              reduce using rule 7 (func_program -> RETURN usable_value .)
    VAR             reduce using rule 7 (func_program -> RETURN usable_value .)
    CONST           reduce using rule 7 (func_program -> RETURN usable_value .)
    SWITCH          reduce using rule 7 (func_program -> RETURN usable_value .)
    FOR             reduce using rule 7 (func_program -> RETURN usable_value .)
    STRING          reduce using rule 7 (func_program -> RETURN usable_value .)
    INTEGER         reduce using rule 7 (func_program -> RETURN usable_value .)
    FLOAT           reduce using rule 7 (func_program -> RETURN usable_value .)
    BOOLEAN         reduce using rule 7 (func_program -> RETURN usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70


state 267

    (142) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program . RKEY
    (8) func_program -> func_program . program
    (9) func_program -> func_program . RETURN
    (10) func_program -> func_program . RETURN usable_value
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 275
    RETURN          shift and go to state 265
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    program                        shift and go to state 264
    usable_value                   shift and go to state 28
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    comparation_operation          shift and go to state 30

state 268

    (40) if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY . program RKEY
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    program                        shift and go to state 276
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 269

    (43) else_if -> ELSE IF comparation_operation . LKEY program RKEY
    (102) usable_value -> comparation_operation .

    LKEY            shift and go to state 277
    EQUALEQUAL      reduce using rule 102 (usable_value -> comparation_operation .)
    NOT_EQUAL       reduce using rule 102 (usable_value -> comparation_operation .)
    LESS_EQUAL      reduce using rule 102 (usable_value -> comparation_operation .)
    GREATER_EQUAL   reduce using rule 102 (usable_value -> comparation_operation .)
    LESS            reduce using rule 102 (usable_value -> comparation_operation .)
    GREATER         reduce using rule 102 (usable_value -> comparation_operation .)
    LOGICAL_AND     reduce using rule 102 (usable_value -> comparation_operation .)
    LOGICAL_OR      reduce using rule 102 (usable_value -> comparation_operation .)
    PLUS            reduce using rule 102 (usable_value -> comparation_operation .)
    MINUS           reduce using rule 102 (usable_value -> comparation_operation .)
    DIVIDE          reduce using rule 102 (usable_value -> comparation_operation .)
    TIMES           reduce using rule 102 (usable_value -> comparation_operation .)
    ENTERE_DIVIDE   reduce using rule 102 (usable_value -> comparation_operation .)
    MODULE          reduce using rule 102 (usable_value -> comparation_operation .)


state 270

    (39) if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program . RKEY
    (13) program -> program . sentencia
    (14) program -> program . loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 278
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    sentencia                      shift and go to state 40
    loop                           shift and go to state 41
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 271

    (45) switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .

    FMT_LIBRARY     reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    FUNC            reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    IDENTIFIER      reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    INPUT           reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    IF              reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    VAR             reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    CONST           reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    SWITCH          reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    FOR             reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    STRING          reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    INTEGER         reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    FLOAT           reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    BOOLEAN         reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    BREAK           reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    CONTINUE        reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    PASS            reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    $end            reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    RKEY            reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    RETURN          reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    CASE            reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    DEFAULT         reduce using rule 45 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)


state 272

    (49) statements -> statement statements .

    RKEY            reduce using rule 49 (statements -> statement statements .)
    CASE            reduce using rule 49 (statements -> statement statements .)
    DEFAULT         reduce using rule 49 (statements -> statement statements .)


state 273

    (33) for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY . loop_program RKEY
    (1) loop_program -> . program
    (2) loop_program -> . loop_reserved
    (3) loop_program -> . loop_program program
    (4) loop_program -> . loop_program loop_reserved
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (15) loop_reserved -> . BREAK
    (16) loop_reserved -> . CONTINUE
    (17) loop_reserved -> . PASS
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PASS            shift and go to state 8
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    short_assignment               shift and go to state 14
    comparation_operation          shift and go to state 30
    loop_program                   shift and go to state 279
    program                        shift and go to state 2
    loop_reserved                  shift and go to state 3
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 274

    (10) func_program -> func_program RETURN usable_value .
    (113) arithmetic_operation -> usable_value . PLUS usable_value
    (114) arithmetic_operation -> usable_value . MINUS usable_value
    (115) arithmetic_operation -> usable_value . DIVIDE usable_value
    (116) arithmetic_operation -> usable_value . TIMES usable_value
    (117) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> usable_value . MODULE usable_value
    (119) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (120) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (121) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (122) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (123) comparation_operation -> usable_value . LESS usable_value
    (124) comparation_operation -> usable_value . GREATER usable_value
    (125) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (126) comparation_operation -> usable_value . LOGICAL_OR usable_value

    RKEY            reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    RETURN          reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    FMT_LIBRARY     reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    FUNC            reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    IDENTIFIER      reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    INPUT           reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    IF              reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    VAR             reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    CONST           reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    SWITCH          reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    FOR             reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    STRING          reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    INTEGER         reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    FLOAT           reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    BOOLEAN         reduce using rule 10 (func_program -> func_program RETURN usable_value .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    DIVIDE          shift and go to state 59
    TIMES           shift and go to state 60
    ENTERE_DIVIDE   shift and go to state 61
    MODULE          shift and go to state 62
    EQUALEQUAL      shift and go to state 63
    NOT_EQUAL       shift and go to state 64
    LESS_EQUAL      shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS            shift and go to state 67
    GREATER         shift and go to state 68
    LOGICAL_AND     shift and go to state 69
    LOGICAL_OR      shift and go to state 70


state 275

    (142) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .

    FMT_LIBRARY     reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    FUNC            reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    IDENTIFIER      reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    INPUT           reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    IF              reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    VAR             reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    CONST           reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    SWITCH          reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    FOR             reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    STRING          reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    INTEGER         reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    FLOAT           reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    BOOLEAN         reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    BREAK           reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    CONTINUE        reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    PASS            reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    $end            reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    RKEY            reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    RETURN          reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    CASE            reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)
    DEFAULT         reduce using rule 142 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY .)


state 276

    (40) if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program . RKEY
    (13) program -> program . sentencia
    (14) program -> program . loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 280
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    sentencia                      shift and go to state 40
    loop                           shift and go to state 41
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 277

    (43) else_if -> ELSE IF comparation_operation LKEY . program RKEY
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    program                        shift and go to state 281
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 278

    (39) if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .

    FMT_LIBRARY     reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    FUNC            reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    IDENTIFIER      reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    INPUT           reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    IF              reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    VAR             reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    CONST           reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    SWITCH          reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    FOR             reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    STRING          reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    INTEGER         reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    FLOAT           reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    BOOLEAN         reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    BREAK           reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    CONTINUE        reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    PASS            reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    $end            reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    RKEY            reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    RETURN          reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    CASE            reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)
    DEFAULT         reduce using rule 39 (if_statement -> IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY .)


state 279

    (33) for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program . RKEY
    (3) loop_program -> loop_program . program
    (4) loop_program -> loop_program . loop_reserved
    (11) program -> . sentencia
    (12) program -> . loop
    (13) program -> . program sentencia
    (14) program -> . program loop
    (15) loop_reserved -> . BREAK
    (16) loop_reserved -> . CONTINUE
    (17) loop_reserved -> . PASS
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 282
    BREAK           shift and go to state 6
    CONTINUE        shift and go to state 7
    PASS            shift and go to state 8
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    short_assignment               shift and go to state 14
    comparation_operation          shift and go to state 30
    program                        shift and go to state 38
    loop_reserved                  shift and go to state 39
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 280

    (40) if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .

    FMT_LIBRARY     reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    FUNC            reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    IDENTIFIER      reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    INPUT           reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    IF              reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    VAR             reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    CONST           reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    SWITCH          reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    FOR             reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    STRING          reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    INTEGER         reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    FLOAT           reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    BOOLEAN         reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    BREAK           reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    CONTINUE        reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    PASS            reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    $end            reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    RKEY            reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    RETURN          reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    CASE            reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)
    DEFAULT         reduce using rule 40 (if_statement -> IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY .)


state 281

    (43) else_if -> ELSE IF comparation_operation LKEY program . RKEY
    (13) program -> program . sentencia
    (14) program -> program . loop
    (19) sentencia -> . print
    (20) sentencia -> . print_withoutvalue
    (21) sentencia -> . def_function
    (22) sentencia -> . call_function
    (23) sentencia -> . input
    (24) sentencia -> . short_assignment
    (25) sentencia -> . arithmetic_operation
    (26) sentencia -> . direct_arithmetic_operation
    (27) sentencia -> . if_statement
    (28) sentencia -> . function_call
    (29) sentencia -> . assignment_semantic
    (30) sentencia -> . switch_statement
    (18) loop -> . for
    (79) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (80) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING RPAREN
    (81) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA RPAREN
    (82) print -> . FMT_LIBRARY DOT PRINTF LPAREN STRING COMMA data RPAREN
    (87) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (88) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (141) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY func_program RKEY
    (142) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN data_type LKEY func_program RKEY
    (143) call_function -> . IDENTIFIER LPAREN values RPAREN
    (158) input -> . INPUT LPAREN RPAREN
    (159) input -> . INPUT LPAREN value RPAREN
    (160) input -> . INPUT LPAREN identifiers RPAREN
    (97) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (113) arithmetic_operation -> . usable_value PLUS usable_value
    (114) arithmetic_operation -> . usable_value MINUS usable_value
    (115) arithmetic_operation -> . usable_value DIVIDE usable_value
    (116) arithmetic_operation -> . usable_value TIMES usable_value
    (117) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (118) arithmetic_operation -> . usable_value MODULE usable_value
    (103) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (104) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (105) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (106) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (107) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (108) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (109) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (110) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (111) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (112) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (37) if_statement -> . IF comparation_operation LKEY program RKEY
    (38) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif
    (39) if_statement -> . IF comparation_operation LKEY program RKEY ELSE LKEY program RKEY
    (40) if_statement -> . IF comparation_operation LKEY program RKEY conditions_elseif ELSE LKEY program RKEY
    (36) function_call -> . IDENTIFIER LPAREN values RPAREN
    (89) assignment_semantic -> . VAR IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (90) assignment_semantic -> . CONST IDENTIFIER INTEGER_DATA_TYPE EQUAL INTEGER
    (91) assignment_semantic -> . VAR IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (92) assignment_semantic -> . CONST IDENTIFIER FLOAT_DATA_TYPE EQUAL FLOAT
    (93) assignment_semantic -> . VAR IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (94) assignment_semantic -> . CONST IDENTIFIER STRING_DATA_TYPE EQUAL STRING
    (95) assignment_semantic -> . VAR IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (96) assignment_semantic -> . CONST IDENTIFIER BOOLEAN_DATA_TYPE EQUAL BOOLEAN
    (44) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (45) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (31) for -> . FOR LKEY loop_program RKEY
    (32) for -> . FOR comparation_operation LKEY loop_program RKEY
    (33) for -> . FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY
    (98) usable_value -> . value
    (99) usable_value -> . call_function
    (100) usable_value -> . IDENTIFIER
    (101) usable_value -> . arithmetic_operation
    (102) usable_value -> . comparation_operation
    (149) value -> . STRING
    (150) value -> . INTEGER
    (151) value -> . FLOAT
    (152) value -> . BOOLEAN
    (153) value -> . IDENTIFIER
    (119) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (120) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (121) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (122) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (123) comparation_operation -> . usable_value LESS usable_value
    (124) comparation_operation -> . usable_value GREATER usable_value
    (125) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (126) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 283
    FMT_LIBRARY     shift and go to state 22
    FUNC            shift and go to state 24
    IDENTIFIER      shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 29
    VAR             shift and go to state 31
    CONST           shift and go to state 33
    SWITCH          shift and go to state 36
    FOR             shift and go to state 37
    STRING          shift and go to state 23
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    sentencia                      shift and go to state 40
    loop                           shift and go to state 41
    print                          shift and go to state 9
    print_withoutvalue             shift and go to state 10
    def_function                   shift and go to state 11
    call_function                  shift and go to state 12
    input                          shift and go to state 13
    short_assignment               shift and go to state 14
    arithmetic_operation           shift and go to state 15
    direct_arithmetic_operation    shift and go to state 16
    if_statement                   shift and go to state 17
    function_call                  shift and go to state 18
    assignment_semantic            shift and go to state 19
    switch_statement               shift and go to state 20
    for                            shift and go to state 21
    value                          shift and go to state 27
    usable_value                   shift and go to state 28

state 282

    (33) for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .

    FMT_LIBRARY     reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    FUNC            reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    IDENTIFIER      reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    INPUT           reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    IF              reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    VAR             reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    CONST           reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    SWITCH          reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    FOR             reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    STRING          reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    INTEGER         reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    FLOAT           reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    BOOLEAN         reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    BREAK           reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    CONTINUE        reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    PASS            reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    $end            reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    RKEY            reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)
    RETURN          reduce using rule 33 (for -> FOR short_assignment SEMICOLON comparation_operation SEMICOLON IDENTIFIER operator_for LKEY loop_program RKEY .)


state 283

    (43) else_if -> ELSE IF comparation_operation LKEY program RKEY .

    ELSE            reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    FMT_LIBRARY     reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    FUNC            reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    IDENTIFIER      reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    INPUT           reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    IF              reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    VAR             reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    CONST           reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    SWITCH          reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    FOR             reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    STRING          reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    INTEGER         reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    FLOAT           reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    BOOLEAN         reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    BREAK           reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    CONTINUE        reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    PASS            reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    $end            reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    RKEY            reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    RETURN          reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    CASE            reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)
    DEFAULT         reduce using rule 43 (else_if -> ELSE IF comparation_operation LKEY program RKEY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FMT_LIBRARY in state 2 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 2 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 2 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for CONST in state 2 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for STRING in state 2 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 2 resolved as shift
WARNING: shift/reduce conflict for FMT_LIBRARY in state 38 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 38 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 38 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 38 resolved as shift
WARNING: shift/reduce conflict for IF in state 38 resolved as shift
WARNING: shift/reduce conflict for VAR in state 38 resolved as shift
WARNING: shift/reduce conflict for CONST in state 38 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 38 resolved as shift
WARNING: shift/reduce conflict for FOR in state 38 resolved as shift
WARNING: shift/reduce conflict for STRING in state 38 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 38 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 38 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 38 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 105 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for LESS in state 105 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 105 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 105 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 106 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 106 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 107 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 107 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 107 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 107 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 107 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 107 resolved as shift
WARNING: shift/reduce conflict for LESS in state 107 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 107 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 107 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 107 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 108 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 108 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 108 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 108 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 108 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 108 resolved as shift
WARNING: shift/reduce conflict for LESS in state 108 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 109 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 110 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 110 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for LESS in state 110 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 110 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 110 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 111 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 111 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 111 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 111 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 111 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 111 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for LESS in state 111 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 111 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 111 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 111 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 112 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 112 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 112 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for LESS in state 112 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 112 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 112 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 112 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 113 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 113 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for LESS in state 113 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 113 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 113 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 114 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 114 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for LESS in state 114 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 114 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 114 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 114 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 115 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 115 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for LESS in state 115 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 115 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 115 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 115 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 116 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 116 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for LESS in state 116 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 116 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 116 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 117 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 117 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 117 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 117 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 117 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 117 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 118 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 118 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 118 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 118 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for LESS in state 118 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 118 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 118 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 118 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 170 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 170 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 170 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 170 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 170 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 170 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 170 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 170 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 170 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 170 resolved as shift
WARNING: shift/reduce conflict for LESS in state 170 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 170 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 170 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 170 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 171 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 171 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 171 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 171 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 171 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 171 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for LESS in state 171 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 171 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 171 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 171 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 172 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 172 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 172 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 172 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 172 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 172 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 172 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 172 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 172 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 172 resolved as shift
WARNING: shift/reduce conflict for LESS in state 172 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 172 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 172 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 172 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 173 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 173 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 173 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 173 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 173 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 173 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for LESS in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 173 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 173 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 173 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 174 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 174 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 174 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 174 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 174 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 174 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 174 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 174 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 174 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 174 resolved as shift
WARNING: shift/reduce conflict for LESS in state 174 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 174 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 174 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 174 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 175 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 175 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 175 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 175 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 175 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 175 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for LESS in state 175 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 175 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 175 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 175 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 176 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 176 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 176 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 176 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 176 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 176 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 176 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 176 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 176 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 176 resolved as shift
WARNING: shift/reduce conflict for LESS in state 176 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 176 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 176 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 176 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 177 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 177 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 177 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 177 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 177 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 177 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for LESS in state 177 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 177 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 177 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 177 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 178 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 178 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 178 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 178 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 178 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 178 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 178 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 178 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 178 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 178 resolved as shift
WARNING: shift/reduce conflict for LESS in state 178 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 178 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 178 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 178 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 179 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 179 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 179 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 179 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 179 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 179 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 179 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 179 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 179 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 179 resolved as shift
WARNING: shift/reduce conflict for LESS in state 179 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 179 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 179 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 179 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 180 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 180 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 180 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 180 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 180 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 180 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for LESS in state 180 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 180 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 180 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 180 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 181 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 181 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 181 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 181 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 181 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 181 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 181 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 181 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 181 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 181 resolved as shift
WARNING: shift/reduce conflict for LESS in state 181 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 181 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 181 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 181 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 182 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 182 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 182 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 182 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 182 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 182 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 182 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 182 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 182 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 182 resolved as shift
WARNING: shift/reduce conflict for LESS in state 182 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 182 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 182 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 182 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 183 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 183 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 183 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 183 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 183 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 183 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for LESS in state 183 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 183 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 183 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 183 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 201 resolved as shift
WARNING: shift/reduce conflict for FMT_LIBRARY in state 237 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 237 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 237 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 237 resolved as shift
WARNING: shift/reduce conflict for IF in state 237 resolved as shift
WARNING: shift/reduce conflict for VAR in state 237 resolved as shift
WARNING: shift/reduce conflict for CONST in state 237 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 237 resolved as shift
WARNING: shift/reduce conflict for FOR in state 237 resolved as shift
WARNING: shift/reduce conflict for STRING in state 237 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 237 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 237 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 237 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 238 resolved as shift
WARNING: shift/reduce conflict for STRING in state 238 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 238 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 238 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 238 resolved as shift
WARNING: shift/reduce conflict for FMT_LIBRARY in state 245 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 245 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 245 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 245 resolved as shift
WARNING: shift/reduce conflict for IF in state 245 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 245 resolved as shift
WARNING: shift/reduce conflict for VAR in state 245 resolved as shift
WARNING: shift/reduce conflict for CONST in state 245 resolved as shift
WARNING: shift/reduce conflict for STRING in state 245 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 245 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 245 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 245 resolved as shift
WARNING: shift/reduce conflict for FMT_LIBRARY in state 264 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 264 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 264 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 264 resolved as shift
WARNING: shift/reduce conflict for IF in state 264 resolved as shift
WARNING: shift/reduce conflict for VAR in state 264 resolved as shift
WARNING: shift/reduce conflict for CONST in state 264 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 264 resolved as shift
WARNING: shift/reduce conflict for FOR in state 264 resolved as shift
WARNING: shift/reduce conflict for STRING in state 264 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 264 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 264 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 264 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 265 resolved as shift
WARNING: shift/reduce conflict for STRING in state 265 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 265 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 265 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 265 resolved as shift
WARNING: reduce/reduce conflict in state 25 resolved using rule (usable_value -> IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 25
WARNING: reduce/reduce conflict in state 74 resolved using rule (usable_value -> IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 74
WARNING: reduce/reduce conflict in state 84 resolved using rule (usable_value -> IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 84
WARNING: reduce/reduce conflict in state 104 resolved using rule (identifiers -> IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 104
WARNING: reduce/reduce conflict in state 152 resolved using rule (function_call -> IDENTIFIER LPAREN values RPAREN)
WARNING: rejected rule (call_function -> IDENTIFIER LPAREN values RPAREN) in state 152
WARNING: reduce/reduce conflict in state 190 resolved using rule (data -> IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 190
WARNING: reduce/reduce conflict in state 233 resolved using rule (data -> data COMMA IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 233
WARNING: reduce/reduce conflict in state 245 resolved using rule (statements -> <empty>)
WARNING: rejected rule (statement -> statement) in state 245
WARNING: Rule (statement -> statement) is never reduced
