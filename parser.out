Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AND
    ARROW_FUNCTION_TYPE
    ARROW_SEND_RECEIVE
    AS
    ASSERT
    BITWISE_XOR
    BITWISE_XOR_ASSIGN
    CLASS
    COLON
    COMMENT
    COMMENT_MULTI
    CONTINUE
    DEL
    ELIF
    ELLIPSIS
    EXCEPT
    FALSE
    FAT_ARROW
    FINALLY
    FROM
    GLOBAL
    GREATER_THAN
    HEX_NUMBER
    IMPORT
    IN
    IS
    LAMBDA
    LBRACKET
    LESS_THAN
    NONE
    NONLOCAL
    NOT
    NULL
    OR
    PASS
    PIPE
    RAISE
    RBRACKET
    RETURN
    RULE_COMPARATION
    SCIENTIFIC_NOTATION
    TRUE
    TRY
    WITH
    YIELD

Grammar

Rule 0     S' -> loop_program
Rule 1     loop_program -> program
Rule 2     loop_program -> BREAK
Rule 3     loop_program -> loop_program program
Rule 4     loop_program -> loop_program BREAK
Rule 5     program -> sentencia
Rule 6     program -> loop
Rule 7     program -> program sentencia
Rule 8     program -> program loop
Rule 9     loop -> for
Rule 10    sentencia -> print
Rule 11    sentencia -> print_withoutvalue
Rule 12    sentencia -> def_function
Rule 13    sentencia -> call_function
Rule 14    sentencia -> input
Rule 15    sentencia -> assignment
Rule 16    sentencia -> short_assignment
Rule 17    sentencia -> arithmetic_operation
Rule 18    sentencia -> direct_arithmetic_operation
Rule 19    sentencia -> if_statement
Rule 20    sentencia -> function_call
Rule 21    for -> FOR LKEY loop_program RKEY
Rule 22    for -> FOR comparation_operation LKEY loop_program RKEY
Rule 23    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 24    if_statement -> IF rule_comparation LKEY program RKEY
Rule 25    if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
Rule 26    if_statement -> IF value LKEY program RKEY
Rule 27    if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY
Rule 28    print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
Rule 29    print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
Rule 30    print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
Rule 31    print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
Rule 32    data -> value
Rule 33    data -> IDENTIFIER
Rule 34    data -> data COMMA value
Rule 35    data -> data COMMA IDENTIFIER
Rule 36    print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
Rule 37    print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN
Rule 38    assignment -> VAR IDENTIFIER data_type EQUAL usable_value
Rule 39    assignment -> CONST IDENTIFIER data_type EQUAL usable_value
Rule 40    short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value
Rule 41    usable_value -> value
Rule 42    usable_value -> call_function
Rule 43    usable_value -> IDENTIFIER
Rule 44    usable_value -> arithmetic_operation
Rule 45    usable_value -> comparation_operation
Rule 46    direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value
Rule 47    direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value
Rule 48    direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value
Rule 49    direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value
Rule 50    direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value
Rule 51    direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value
Rule 52    direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value
Rule 53    direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value
Rule 54    direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value
Rule 55    direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value
Rule 56    arithmetic_operation -> usable_value PLUS usable_value
Rule 57    arithmetic_operation -> usable_value MINUS usable_value
Rule 58    arithmetic_operation -> usable_value DIVIDE usable_value
Rule 59    arithmetic_operation -> usable_value TIMES usable_value
Rule 60    arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value
Rule 61    arithmetic_operation -> usable_value MODULE usable_value
Rule 62    comparation_operation -> usable_value EQUALEQUAL usable_value
Rule 63    comparation_operation -> usable_value NOT_EQUAL usable_value
Rule 64    comparation_operation -> usable_value LESS_EQUAL usable_value
Rule 65    comparation_operation -> usable_value GREATER_EQUAL usable_value
Rule 66    comparation_operation -> usable_value LESS usable_value
Rule 67    comparation_operation -> usable_value GREATER usable_value
Rule 68    comparation_operation -> usable_value LOGICAL_AND usable_value
Rule 69    comparation_operation -> usable_value LOGICAL_OR usable_value
Rule 70    identifiers -> IDENTIFIER
Rule 71    identifiers -> identifiers COMMA identifiers
Rule 72    rule_comparation -> IDENTIFIER EQUALEQUAL value
Rule 73    rule_comparation -> IDENTIFIER NOT_EQUAL value
Rule 74    rule_comparation -> IDENTIFIER LESS_EQUAL value
Rule 75    rule_comparation -> IDENTIFIER GREATER_EQUAL value
Rule 76    rule_comparation -> IDENTIFIER LESS value
Rule 77    rule_comparation -> IDENTIFIER GREATER value
Rule 78    rule_comparation -> IDENTIFIER LOGICAL_AND value
Rule 79    rule_comparation -> IDENTIFIER LOGICAL_OR value
Rule 80    condition -> value comparation_operation value
Rule 81    condition -> condition LOGICAL_AND condition
Rule 82    condition -> condition LOGICAL_OR condition
Rule 83    condition -> LOGICAL_NOT condition
Rule 84    def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
Rule 85    call_function -> IDENTIFIER LPAREN values RPAREN
Rule 86    parameters -> parameter
Rule 87    parameters -> parameters COMMA parameter
Rule 88    parameter -> IDENTIFIER data_type
Rule 89    values -> value
Rule 90    values -> values COMMA value
Rule 91    value -> STRING
Rule 92    value -> INTEGER
Rule 93    value -> FLOAT32
Rule 94    value -> FLOAT64
Rule 95    value -> BOOLEAN
Rule 96    data_type -> INTEGER_DATA_TYPE
Rule 97    data_type -> FLOAT32_DATA_TYPE
Rule 98    data_type -> FLOAT64_DATA_TYPE
Rule 99    data_type -> BOOLEAN_DATA_TYPE
Rule 100   data_type -> STRING_DATA_TYPE
Rule 101   input -> INPUT LPAREN RPAREN
Rule 102   input -> INPUT LPAREN value RPAREN
Rule 103   input -> INPUT LPAREN identifiers RPAREN

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 
ARROW_FUNCTION_TYPE  : 
ARROW_SEND_RECEIVE   : 
AS                   : 
ASSERT               : 
BITWISE_AND_EQ       : 51
BITWISE_OR_EQ        : 52
BITWISE_XOR          : 
BITWISE_XOR_ASSIGN   : 
BITWISE_XOR_EQ       : 53
BOOLEAN              : 95
BOOLEAN_DATA_TYPE    : 99
BREAK                : 2 4
CLASS                : 
COLON                : 
COMMA                : 30 31 34 35 71 87 90
COMMENT              : 
COMMENT_MULTI        : 
CONST                : 39
CONTINUE             : 
DEL                  : 
DIVIDE               : 58
DIVIDE_EQ            : 49
DOT                  : 28 29 30 31 36 37
ELIF                 : 
ELLIPSIS             : 
ELSE                 : 25 27
ENTERE_DIVIDE        : 60
EQUAL                : 38 39
EQUALEQUAL           : 62 72
EXCEPT               : 
FALSE                : 
FAT_ARROW            : 
FINALLY              : 
FLOAT32              : 93
FLOAT32_DATA_TYPE    : 97
FLOAT64              : 94
FLOAT64_DATA_TYPE    : 98
FMT_LIBRARY          : 28 29 30 31 36 37
FOR                  : 21 22
FROM                 : 
FUNC                 : 84
GLOBAL               : 
GREATER              : 67 77
GREATER_EQUAL        : 65 75
GREATER_THAN         : 
HEX_NUMBER           : 
IDENTIFIER           : 23 33 35 38 39 40 43 46 47 48 49 50 51 52 53 54 55 70 72 73 74 75 76 77 78 79 84 85 88
IF                   : 24 25 26 27
IMPORT               : 
IN                   : 
INPUT                : 101 102 103
INTEGER              : 92
INTEGER_DATA_TYPE    : 96
IS                   : 
LAMBDA               : 
LBRACKET             : 
LEFT_SHIFT_EQ        : 54
LESS                 : 66 76
LESS_EQUAL           : 64 74
LESS_THAN            : 
LKEY                 : 21 22 24 25 25 26 27 27 84
LOGICAL_AND          : 68 78 81
LOGICAL_NOT          : 83
LOGICAL_OR           : 69 79 82
LPAREN               : 23 28 29 30 31 36 37 84 85 101 102 103
MINUS                : 57
MINUS_EQ             : 47
MODULE               : 61
MODULO_EQ            : 50
NONE                 : 
NONLOCAL             : 
NOT                  : 
NOT_EQUAL            : 63 73
NULL                 : 
OR                   : 
PASS                 : 
PIPE                 : 
PLUS                 : 56
PLUS_EQ              : 46
PRINTF               : 29 30 31 37
PRINTLN              : 28 36
RAISE                : 
RBRACKET             : 
RETURN               : 
RIGHT_SHIFT_EQ       : 55
RKEY                 : 21 22 24 25 25 26 27 27 84
RPAREN               : 23 28 29 30 31 36 37 84 85 101 102 103
RULE_COMPARATION     : 
SCIENTIFIC_NOTATION  : 
SHORT_VAR_DECL       : 40
STRING               : 91
STRING_DATA_TYPE     : 100
TIMES                : 59
TIMES_EQ             : 48
TRUE                 : 
TRY                  : 
VAR                  : 38
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arithmetic_operation : 17 44
assignment           : 15
call_function        : 13 42
comparation_operation : 22 45 80
condition            : 81 81 82 82 83
data                 : 28 31 34 35
data_type            : 38 39 88
def_function         : 12
direct_arithmetic_operation : 18
for                  : 9
function_call        : 20
identifiers          : 71 71 103
if_statement         : 19
input                : 14
loop                 : 6 8
loop_program         : 3 4 21 22 0
parameter            : 86 87
parameters           : 84 87
print                : 10
print_withoutvalue   : 11
program              : 1 3 7 8 24 25 25 26 27 27 84
rule_comparation     : 24 25
sentencia            : 5 7
short_assignment     : 16
usable_value         : 38 39 40 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69
value                : 26 27 29 30 31 32 34 41 46 47 48 49 50 51 52 53 54 55 72 73 74 75 76 77 78 79 80 80 89 90 102
values               : 23 85 90

Parsing method: LALR

state 0

    (0) S' -> . loop_program
    (1) loop_program -> . program
    (2) loop_program -> . BREAK
    (3) loop_program -> . loop_program program
    (4) loop_program -> . loop_program BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 3
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    loop_program                   shift and go to state 1
    program                        shift and go to state 2
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 1

    (0) S' -> loop_program .
    (3) loop_program -> loop_program . program
    (4) loop_program -> loop_program . BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 35
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    program                        shift and go to state 34
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 2

    (1) loop_program -> program .
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! shift/reduce conflict for FMT_LIBRARY resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT32 resolved as shift
  ! shift/reduce conflict for FLOAT64 resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    BREAK           reduce using rule 1 (loop_program -> program .)
    $end            reduce using rule 1 (loop_program -> program .)
    RKEY            reduce using rule 1 (loop_program -> program .)
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

  ! FMT_LIBRARY     [ reduce using rule 1 (loop_program -> program .) ]
  ! FUNC            [ reduce using rule 1 (loop_program -> program .) ]
  ! IDENTIFIER      [ reduce using rule 1 (loop_program -> program .) ]
  ! INPUT           [ reduce using rule 1 (loop_program -> program .) ]
  ! VAR             [ reduce using rule 1 (loop_program -> program .) ]
  ! CONST           [ reduce using rule 1 (loop_program -> program .) ]
  ! IF              [ reduce using rule 1 (loop_program -> program .) ]
  ! FOR             [ reduce using rule 1 (loop_program -> program .) ]
  ! STRING          [ reduce using rule 1 (loop_program -> program .) ]
  ! INTEGER         [ reduce using rule 1 (loop_program -> program .) ]
  ! FLOAT32         [ reduce using rule 1 (loop_program -> program .) ]
  ! FLOAT64         [ reduce using rule 1 (loop_program -> program .) ]
  ! BOOLEAN         [ reduce using rule 1 (loop_program -> program .) ]

    sentencia                      shift and go to state 36
    loop                           shift and go to state 37
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 3

    (2) loop_program -> BREAK .

    BREAK           reduce using rule 2 (loop_program -> BREAK .)
    FMT_LIBRARY     reduce using rule 2 (loop_program -> BREAK .)
    FUNC            reduce using rule 2 (loop_program -> BREAK .)
    IDENTIFIER      reduce using rule 2 (loop_program -> BREAK .)
    INPUT           reduce using rule 2 (loop_program -> BREAK .)
    VAR             reduce using rule 2 (loop_program -> BREAK .)
    CONST           reduce using rule 2 (loop_program -> BREAK .)
    IF              reduce using rule 2 (loop_program -> BREAK .)
    FOR             reduce using rule 2 (loop_program -> BREAK .)
    STRING          reduce using rule 2 (loop_program -> BREAK .)
    INTEGER         reduce using rule 2 (loop_program -> BREAK .)
    FLOAT32         reduce using rule 2 (loop_program -> BREAK .)
    FLOAT64         reduce using rule 2 (loop_program -> BREAK .)
    BOOLEAN         reduce using rule 2 (loop_program -> BREAK .)
    $end            reduce using rule 2 (loop_program -> BREAK .)
    RKEY            reduce using rule 2 (loop_program -> BREAK .)


state 4

    (5) program -> sentencia .

    FMT_LIBRARY     reduce using rule 5 (program -> sentencia .)
    FUNC            reduce using rule 5 (program -> sentencia .)
    IDENTIFIER      reduce using rule 5 (program -> sentencia .)
    INPUT           reduce using rule 5 (program -> sentencia .)
    VAR             reduce using rule 5 (program -> sentencia .)
    CONST           reduce using rule 5 (program -> sentencia .)
    IF              reduce using rule 5 (program -> sentencia .)
    FOR             reduce using rule 5 (program -> sentencia .)
    STRING          reduce using rule 5 (program -> sentencia .)
    INTEGER         reduce using rule 5 (program -> sentencia .)
    FLOAT32         reduce using rule 5 (program -> sentencia .)
    FLOAT64         reduce using rule 5 (program -> sentencia .)
    BOOLEAN         reduce using rule 5 (program -> sentencia .)
    BREAK           reduce using rule 5 (program -> sentencia .)
    $end            reduce using rule 5 (program -> sentencia .)
    RKEY            reduce using rule 5 (program -> sentencia .)


state 5

    (6) program -> loop .

    FMT_LIBRARY     reduce using rule 6 (program -> loop .)
    FUNC            reduce using rule 6 (program -> loop .)
    IDENTIFIER      reduce using rule 6 (program -> loop .)
    INPUT           reduce using rule 6 (program -> loop .)
    VAR             reduce using rule 6 (program -> loop .)
    CONST           reduce using rule 6 (program -> loop .)
    IF              reduce using rule 6 (program -> loop .)
    FOR             reduce using rule 6 (program -> loop .)
    STRING          reduce using rule 6 (program -> loop .)
    INTEGER         reduce using rule 6 (program -> loop .)
    FLOAT32         reduce using rule 6 (program -> loop .)
    FLOAT64         reduce using rule 6 (program -> loop .)
    BOOLEAN         reduce using rule 6 (program -> loop .)
    BREAK           reduce using rule 6 (program -> loop .)
    $end            reduce using rule 6 (program -> loop .)
    RKEY            reduce using rule 6 (program -> loop .)


state 6

    (10) sentencia -> print .

    FMT_LIBRARY     reduce using rule 10 (sentencia -> print .)
    FUNC            reduce using rule 10 (sentencia -> print .)
    IDENTIFIER      reduce using rule 10 (sentencia -> print .)
    INPUT           reduce using rule 10 (sentencia -> print .)
    VAR             reduce using rule 10 (sentencia -> print .)
    CONST           reduce using rule 10 (sentencia -> print .)
    IF              reduce using rule 10 (sentencia -> print .)
    FOR             reduce using rule 10 (sentencia -> print .)
    STRING          reduce using rule 10 (sentencia -> print .)
    INTEGER         reduce using rule 10 (sentencia -> print .)
    FLOAT32         reduce using rule 10 (sentencia -> print .)
    FLOAT64         reduce using rule 10 (sentencia -> print .)
    BOOLEAN         reduce using rule 10 (sentencia -> print .)
    BREAK           reduce using rule 10 (sentencia -> print .)
    $end            reduce using rule 10 (sentencia -> print .)
    RKEY            reduce using rule 10 (sentencia -> print .)


state 7

    (11) sentencia -> print_withoutvalue .

    FMT_LIBRARY     reduce using rule 11 (sentencia -> print_withoutvalue .)
    FUNC            reduce using rule 11 (sentencia -> print_withoutvalue .)
    IDENTIFIER      reduce using rule 11 (sentencia -> print_withoutvalue .)
    INPUT           reduce using rule 11 (sentencia -> print_withoutvalue .)
    VAR             reduce using rule 11 (sentencia -> print_withoutvalue .)
    CONST           reduce using rule 11 (sentencia -> print_withoutvalue .)
    IF              reduce using rule 11 (sentencia -> print_withoutvalue .)
    FOR             reduce using rule 11 (sentencia -> print_withoutvalue .)
    STRING          reduce using rule 11 (sentencia -> print_withoutvalue .)
    INTEGER         reduce using rule 11 (sentencia -> print_withoutvalue .)
    FLOAT32         reduce using rule 11 (sentencia -> print_withoutvalue .)
    FLOAT64         reduce using rule 11 (sentencia -> print_withoutvalue .)
    BOOLEAN         reduce using rule 11 (sentencia -> print_withoutvalue .)
    BREAK           reduce using rule 11 (sentencia -> print_withoutvalue .)
    $end            reduce using rule 11 (sentencia -> print_withoutvalue .)
    RKEY            reduce using rule 11 (sentencia -> print_withoutvalue .)


state 8

    (12) sentencia -> def_function .

    FMT_LIBRARY     reduce using rule 12 (sentencia -> def_function .)
    FUNC            reduce using rule 12 (sentencia -> def_function .)
    IDENTIFIER      reduce using rule 12 (sentencia -> def_function .)
    INPUT           reduce using rule 12 (sentencia -> def_function .)
    VAR             reduce using rule 12 (sentencia -> def_function .)
    CONST           reduce using rule 12 (sentencia -> def_function .)
    IF              reduce using rule 12 (sentencia -> def_function .)
    FOR             reduce using rule 12 (sentencia -> def_function .)
    STRING          reduce using rule 12 (sentencia -> def_function .)
    INTEGER         reduce using rule 12 (sentencia -> def_function .)
    FLOAT32         reduce using rule 12 (sentencia -> def_function .)
    FLOAT64         reduce using rule 12 (sentencia -> def_function .)
    BOOLEAN         reduce using rule 12 (sentencia -> def_function .)
    BREAK           reduce using rule 12 (sentencia -> def_function .)
    $end            reduce using rule 12 (sentencia -> def_function .)
    RKEY            reduce using rule 12 (sentencia -> def_function .)


state 9

    (13) sentencia -> call_function .
    (42) usable_value -> call_function .

    FMT_LIBRARY     reduce using rule 13 (sentencia -> call_function .)
    FUNC            reduce using rule 13 (sentencia -> call_function .)
    IDENTIFIER      reduce using rule 13 (sentencia -> call_function .)
    INPUT           reduce using rule 13 (sentencia -> call_function .)
    VAR             reduce using rule 13 (sentencia -> call_function .)
    CONST           reduce using rule 13 (sentencia -> call_function .)
    IF              reduce using rule 13 (sentencia -> call_function .)
    FOR             reduce using rule 13 (sentencia -> call_function .)
    STRING          reduce using rule 13 (sentencia -> call_function .)
    INTEGER         reduce using rule 13 (sentencia -> call_function .)
    FLOAT32         reduce using rule 13 (sentencia -> call_function .)
    FLOAT64         reduce using rule 13 (sentencia -> call_function .)
    BOOLEAN         reduce using rule 13 (sentencia -> call_function .)
    BREAK           reduce using rule 13 (sentencia -> call_function .)
    $end            reduce using rule 13 (sentencia -> call_function .)
    RKEY            reduce using rule 13 (sentencia -> call_function .)
    PLUS            reduce using rule 42 (usable_value -> call_function .)
    MINUS           reduce using rule 42 (usable_value -> call_function .)
    DIVIDE          reduce using rule 42 (usable_value -> call_function .)
    TIMES           reduce using rule 42 (usable_value -> call_function .)
    ENTERE_DIVIDE   reduce using rule 42 (usable_value -> call_function .)
    MODULE          reduce using rule 42 (usable_value -> call_function .)
    EQUALEQUAL      reduce using rule 42 (usable_value -> call_function .)
    NOT_EQUAL       reduce using rule 42 (usable_value -> call_function .)
    LESS_EQUAL      reduce using rule 42 (usable_value -> call_function .)
    GREATER_EQUAL   reduce using rule 42 (usable_value -> call_function .)
    LESS            reduce using rule 42 (usable_value -> call_function .)
    GREATER         reduce using rule 42 (usable_value -> call_function .)
    LOGICAL_AND     reduce using rule 42 (usable_value -> call_function .)
    LOGICAL_OR      reduce using rule 42 (usable_value -> call_function .)


state 10

    (14) sentencia -> input .

    FMT_LIBRARY     reduce using rule 14 (sentencia -> input .)
    FUNC            reduce using rule 14 (sentencia -> input .)
    IDENTIFIER      reduce using rule 14 (sentencia -> input .)
    INPUT           reduce using rule 14 (sentencia -> input .)
    VAR             reduce using rule 14 (sentencia -> input .)
    CONST           reduce using rule 14 (sentencia -> input .)
    IF              reduce using rule 14 (sentencia -> input .)
    FOR             reduce using rule 14 (sentencia -> input .)
    STRING          reduce using rule 14 (sentencia -> input .)
    INTEGER         reduce using rule 14 (sentencia -> input .)
    FLOAT32         reduce using rule 14 (sentencia -> input .)
    FLOAT64         reduce using rule 14 (sentencia -> input .)
    BOOLEAN         reduce using rule 14 (sentencia -> input .)
    BREAK           reduce using rule 14 (sentencia -> input .)
    $end            reduce using rule 14 (sentencia -> input .)
    RKEY            reduce using rule 14 (sentencia -> input .)


state 11

    (15) sentencia -> assignment .

    FMT_LIBRARY     reduce using rule 15 (sentencia -> assignment .)
    FUNC            reduce using rule 15 (sentencia -> assignment .)
    IDENTIFIER      reduce using rule 15 (sentencia -> assignment .)
    INPUT           reduce using rule 15 (sentencia -> assignment .)
    VAR             reduce using rule 15 (sentencia -> assignment .)
    CONST           reduce using rule 15 (sentencia -> assignment .)
    IF              reduce using rule 15 (sentencia -> assignment .)
    FOR             reduce using rule 15 (sentencia -> assignment .)
    STRING          reduce using rule 15 (sentencia -> assignment .)
    INTEGER         reduce using rule 15 (sentencia -> assignment .)
    FLOAT32         reduce using rule 15 (sentencia -> assignment .)
    FLOAT64         reduce using rule 15 (sentencia -> assignment .)
    BOOLEAN         reduce using rule 15 (sentencia -> assignment .)
    BREAK           reduce using rule 15 (sentencia -> assignment .)
    $end            reduce using rule 15 (sentencia -> assignment .)
    RKEY            reduce using rule 15 (sentencia -> assignment .)


state 12

    (16) sentencia -> short_assignment .

    FMT_LIBRARY     reduce using rule 16 (sentencia -> short_assignment .)
    FUNC            reduce using rule 16 (sentencia -> short_assignment .)
    IDENTIFIER      reduce using rule 16 (sentencia -> short_assignment .)
    INPUT           reduce using rule 16 (sentencia -> short_assignment .)
    VAR             reduce using rule 16 (sentencia -> short_assignment .)
    CONST           reduce using rule 16 (sentencia -> short_assignment .)
    IF              reduce using rule 16 (sentencia -> short_assignment .)
    FOR             reduce using rule 16 (sentencia -> short_assignment .)
    STRING          reduce using rule 16 (sentencia -> short_assignment .)
    INTEGER         reduce using rule 16 (sentencia -> short_assignment .)
    FLOAT32         reduce using rule 16 (sentencia -> short_assignment .)
    FLOAT64         reduce using rule 16 (sentencia -> short_assignment .)
    BOOLEAN         reduce using rule 16 (sentencia -> short_assignment .)
    BREAK           reduce using rule 16 (sentencia -> short_assignment .)
    $end            reduce using rule 16 (sentencia -> short_assignment .)
    RKEY            reduce using rule 16 (sentencia -> short_assignment .)


state 13

    (17) sentencia -> arithmetic_operation .
    (44) usable_value -> arithmetic_operation .

    FMT_LIBRARY     reduce using rule 17 (sentencia -> arithmetic_operation .)
    FUNC            reduce using rule 17 (sentencia -> arithmetic_operation .)
    IDENTIFIER      reduce using rule 17 (sentencia -> arithmetic_operation .)
    INPUT           reduce using rule 17 (sentencia -> arithmetic_operation .)
    VAR             reduce using rule 17 (sentencia -> arithmetic_operation .)
    CONST           reduce using rule 17 (sentencia -> arithmetic_operation .)
    IF              reduce using rule 17 (sentencia -> arithmetic_operation .)
    FOR             reduce using rule 17 (sentencia -> arithmetic_operation .)
    STRING          reduce using rule 17 (sentencia -> arithmetic_operation .)
    INTEGER         reduce using rule 17 (sentencia -> arithmetic_operation .)
    FLOAT32         reduce using rule 17 (sentencia -> arithmetic_operation .)
    FLOAT64         reduce using rule 17 (sentencia -> arithmetic_operation .)
    BOOLEAN         reduce using rule 17 (sentencia -> arithmetic_operation .)
    BREAK           reduce using rule 17 (sentencia -> arithmetic_operation .)
    $end            reduce using rule 17 (sentencia -> arithmetic_operation .)
    RKEY            reduce using rule 17 (sentencia -> arithmetic_operation .)
    PLUS            reduce using rule 44 (usable_value -> arithmetic_operation .)
    MINUS           reduce using rule 44 (usable_value -> arithmetic_operation .)
    DIVIDE          reduce using rule 44 (usable_value -> arithmetic_operation .)
    TIMES           reduce using rule 44 (usable_value -> arithmetic_operation .)
    ENTERE_DIVIDE   reduce using rule 44 (usable_value -> arithmetic_operation .)
    MODULE          reduce using rule 44 (usable_value -> arithmetic_operation .)
    EQUALEQUAL      reduce using rule 44 (usable_value -> arithmetic_operation .)
    NOT_EQUAL       reduce using rule 44 (usable_value -> arithmetic_operation .)
    LESS_EQUAL      reduce using rule 44 (usable_value -> arithmetic_operation .)
    GREATER_EQUAL   reduce using rule 44 (usable_value -> arithmetic_operation .)
    LESS            reduce using rule 44 (usable_value -> arithmetic_operation .)
    GREATER         reduce using rule 44 (usable_value -> arithmetic_operation .)
    LOGICAL_AND     reduce using rule 44 (usable_value -> arithmetic_operation .)
    LOGICAL_OR      reduce using rule 44 (usable_value -> arithmetic_operation .)


state 14

    (18) sentencia -> direct_arithmetic_operation .

    FMT_LIBRARY     reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    FUNC            reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    IDENTIFIER      reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    INPUT           reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    VAR             reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    CONST           reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    IF              reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    FOR             reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    STRING          reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    INTEGER         reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    FLOAT32         reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    FLOAT64         reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    BOOLEAN         reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    BREAK           reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    $end            reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    RKEY            reduce using rule 18 (sentencia -> direct_arithmetic_operation .)


state 15

    (19) sentencia -> if_statement .

    FMT_LIBRARY     reduce using rule 19 (sentencia -> if_statement .)
    FUNC            reduce using rule 19 (sentencia -> if_statement .)
    IDENTIFIER      reduce using rule 19 (sentencia -> if_statement .)
    INPUT           reduce using rule 19 (sentencia -> if_statement .)
    VAR             reduce using rule 19 (sentencia -> if_statement .)
    CONST           reduce using rule 19 (sentencia -> if_statement .)
    IF              reduce using rule 19 (sentencia -> if_statement .)
    FOR             reduce using rule 19 (sentencia -> if_statement .)
    STRING          reduce using rule 19 (sentencia -> if_statement .)
    INTEGER         reduce using rule 19 (sentencia -> if_statement .)
    FLOAT32         reduce using rule 19 (sentencia -> if_statement .)
    FLOAT64         reduce using rule 19 (sentencia -> if_statement .)
    BOOLEAN         reduce using rule 19 (sentencia -> if_statement .)
    BREAK           reduce using rule 19 (sentencia -> if_statement .)
    $end            reduce using rule 19 (sentencia -> if_statement .)
    RKEY            reduce using rule 19 (sentencia -> if_statement .)


state 16

    (20) sentencia -> function_call .

    FMT_LIBRARY     reduce using rule 20 (sentencia -> function_call .)
    FUNC            reduce using rule 20 (sentencia -> function_call .)
    IDENTIFIER      reduce using rule 20 (sentencia -> function_call .)
    INPUT           reduce using rule 20 (sentencia -> function_call .)
    VAR             reduce using rule 20 (sentencia -> function_call .)
    CONST           reduce using rule 20 (sentencia -> function_call .)
    IF              reduce using rule 20 (sentencia -> function_call .)
    FOR             reduce using rule 20 (sentencia -> function_call .)
    STRING          reduce using rule 20 (sentencia -> function_call .)
    INTEGER         reduce using rule 20 (sentencia -> function_call .)
    FLOAT32         reduce using rule 20 (sentencia -> function_call .)
    FLOAT64         reduce using rule 20 (sentencia -> function_call .)
    BOOLEAN         reduce using rule 20 (sentencia -> function_call .)
    BREAK           reduce using rule 20 (sentencia -> function_call .)
    $end            reduce using rule 20 (sentencia -> function_call .)
    RKEY            reduce using rule 20 (sentencia -> function_call .)


state 17

    (9) loop -> for .

    FMT_LIBRARY     reduce using rule 9 (loop -> for .)
    FUNC            reduce using rule 9 (loop -> for .)
    IDENTIFIER      reduce using rule 9 (loop -> for .)
    INPUT           reduce using rule 9 (loop -> for .)
    VAR             reduce using rule 9 (loop -> for .)
    CONST           reduce using rule 9 (loop -> for .)
    IF              reduce using rule 9 (loop -> for .)
    FOR             reduce using rule 9 (loop -> for .)
    STRING          reduce using rule 9 (loop -> for .)
    INTEGER         reduce using rule 9 (loop -> for .)
    FLOAT32         reduce using rule 9 (loop -> for .)
    FLOAT64         reduce using rule 9 (loop -> for .)
    BOOLEAN         reduce using rule 9 (loop -> for .)
    BREAK           reduce using rule 9 (loop -> for .)
    $end            reduce using rule 9 (loop -> for .)
    RKEY            reduce using rule 9 (loop -> for .)


state 18

    (28) print -> FMT_LIBRARY . DOT PRINTLN LPAREN data RPAREN
    (29) print -> FMT_LIBRARY . DOT PRINTF LPAREN value RPAREN
    (30) print -> FMT_LIBRARY . DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> FMT_LIBRARY . DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> FMT_LIBRARY . DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> FMT_LIBRARY . DOT PRINTF LPAREN RPAREN

    DOT             shift and go to state 38


state 19

    (41) usable_value -> value .

    PLUS            reduce using rule 41 (usable_value -> value .)
    MINUS           reduce using rule 41 (usable_value -> value .)
    DIVIDE          reduce using rule 41 (usable_value -> value .)
    TIMES           reduce using rule 41 (usable_value -> value .)
    ENTERE_DIVIDE   reduce using rule 41 (usable_value -> value .)
    MODULE          reduce using rule 41 (usable_value -> value .)
    EQUALEQUAL      reduce using rule 41 (usable_value -> value .)
    NOT_EQUAL       reduce using rule 41 (usable_value -> value .)
    LESS_EQUAL      reduce using rule 41 (usable_value -> value .)
    GREATER_EQUAL   reduce using rule 41 (usable_value -> value .)
    LESS            reduce using rule 41 (usable_value -> value .)
    GREATER         reduce using rule 41 (usable_value -> value .)
    LOGICAL_AND     reduce using rule 41 (usable_value -> value .)
    LOGICAL_OR      reduce using rule 41 (usable_value -> value .)
    FMT_LIBRARY     reduce using rule 41 (usable_value -> value .)
    FUNC            reduce using rule 41 (usable_value -> value .)
    IDENTIFIER      reduce using rule 41 (usable_value -> value .)
    INPUT           reduce using rule 41 (usable_value -> value .)
    VAR             reduce using rule 41 (usable_value -> value .)
    CONST           reduce using rule 41 (usable_value -> value .)
    IF              reduce using rule 41 (usable_value -> value .)
    FOR             reduce using rule 41 (usable_value -> value .)
    STRING          reduce using rule 41 (usable_value -> value .)
    INTEGER         reduce using rule 41 (usable_value -> value .)
    FLOAT32         reduce using rule 41 (usable_value -> value .)
    FLOAT64         reduce using rule 41 (usable_value -> value .)
    BOOLEAN         reduce using rule 41 (usable_value -> value .)
    BREAK           reduce using rule 41 (usable_value -> value .)
    $end            reduce using rule 41 (usable_value -> value .)
    RKEY            reduce using rule 41 (usable_value -> value .)
    LKEY            reduce using rule 41 (usable_value -> value .)


state 20

    (84) def_function -> FUNC . IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY

    IDENTIFIER      shift and go to state 39


state 21

    (85) call_function -> IDENTIFIER . LPAREN values RPAREN
    (40) short_assignment -> IDENTIFIER . SHORT_VAR_DECL usable_value
    (46) direct_arithmetic_operation -> IDENTIFIER . PLUS_EQ value
    (47) direct_arithmetic_operation -> IDENTIFIER . MINUS_EQ value
    (48) direct_arithmetic_operation -> IDENTIFIER . TIMES_EQ value
    (49) direct_arithmetic_operation -> IDENTIFIER . DIVIDE_EQ value
    (50) direct_arithmetic_operation -> IDENTIFIER . MODULO_EQ value
    (51) direct_arithmetic_operation -> IDENTIFIER . BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> IDENTIFIER . BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> IDENTIFIER . BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> IDENTIFIER . LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> IDENTIFIER . RIGHT_SHIFT_EQ value
    (23) function_call -> IDENTIFIER . LPAREN values RPAREN
    (43) usable_value -> IDENTIFIER .

    LPAREN          shift and go to state 40
    SHORT_VAR_DECL  shift and go to state 41
    PLUS_EQ         shift and go to state 42
    MINUS_EQ        shift and go to state 43
    TIMES_EQ        shift and go to state 44
    DIVIDE_EQ       shift and go to state 45
    MODULO_EQ       shift and go to state 46
    BITWISE_AND_EQ  shift and go to state 47
    BITWISE_OR_EQ   shift and go to state 48
    BITWISE_XOR_EQ  shift and go to state 49
    LEFT_SHIFT_EQ   shift and go to state 50
    RIGHT_SHIFT_EQ  shift and go to state 51
    PLUS            reduce using rule 43 (usable_value -> IDENTIFIER .)
    MINUS           reduce using rule 43 (usable_value -> IDENTIFIER .)
    DIVIDE          reduce using rule 43 (usable_value -> IDENTIFIER .)
    TIMES           reduce using rule 43 (usable_value -> IDENTIFIER .)
    ENTERE_DIVIDE   reduce using rule 43 (usable_value -> IDENTIFIER .)
    MODULE          reduce using rule 43 (usable_value -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 43 (usable_value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 43 (usable_value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 43 (usable_value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 43 (usable_value -> IDENTIFIER .)
    LESS            reduce using rule 43 (usable_value -> IDENTIFIER .)
    GREATER         reduce using rule 43 (usable_value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 43 (usable_value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 43 (usable_value -> IDENTIFIER .)


state 22

    (101) input -> INPUT . LPAREN RPAREN
    (102) input -> INPUT . LPAREN value RPAREN
    (103) input -> INPUT . LPAREN identifiers RPAREN

    LPAREN          shift and go to state 52


state 23

    (38) assignment -> VAR . IDENTIFIER data_type EQUAL usable_value

    IDENTIFIER      shift and go to state 53


state 24

    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67


state 25

    (39) assignment -> CONST . IDENTIFIER data_type EQUAL usable_value

    IDENTIFIER      shift and go to state 68


state 26

    (24) if_statement -> IF . rule_comparation LKEY program RKEY
    (25) if_statement -> IF . rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> IF . value LKEY program RKEY
    (27) if_statement -> IF . value LKEY program RKEY ELSE LKEY program RKEY
    (72) rule_comparation -> . IDENTIFIER EQUALEQUAL value
    (73) rule_comparation -> . IDENTIFIER NOT_EQUAL value
    (74) rule_comparation -> . IDENTIFIER LESS_EQUAL value
    (75) rule_comparation -> . IDENTIFIER GREATER_EQUAL value
    (76) rule_comparation -> . IDENTIFIER LESS value
    (77) rule_comparation -> . IDENTIFIER GREATER value
    (78) rule_comparation -> . IDENTIFIER LOGICAL_AND value
    (79) rule_comparation -> . IDENTIFIER LOGICAL_OR value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    IDENTIFIER      shift and go to state 71
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    rule_comparation               shift and go to state 69
    value                          shift and go to state 70

state 27

    (21) for -> FOR . LKEY loop_program RKEY
    (22) for -> FOR . comparation_operation LKEY loop_program RKEY
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value

    LKEY            shift and go to state 72
    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    comparation_operation          shift and go to state 73
    usable_value                   shift and go to state 74
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77

state 28

    (45) usable_value -> comparation_operation .

    PLUS            reduce using rule 45 (usable_value -> comparation_operation .)
    MINUS           reduce using rule 45 (usable_value -> comparation_operation .)
    DIVIDE          reduce using rule 45 (usable_value -> comparation_operation .)
    TIMES           reduce using rule 45 (usable_value -> comparation_operation .)
    ENTERE_DIVIDE   reduce using rule 45 (usable_value -> comparation_operation .)
    MODULE          reduce using rule 45 (usable_value -> comparation_operation .)
    EQUALEQUAL      reduce using rule 45 (usable_value -> comparation_operation .)
    NOT_EQUAL       reduce using rule 45 (usable_value -> comparation_operation .)
    LESS_EQUAL      reduce using rule 45 (usable_value -> comparation_operation .)
    GREATER_EQUAL   reduce using rule 45 (usable_value -> comparation_operation .)
    LESS            reduce using rule 45 (usable_value -> comparation_operation .)
    GREATER         reduce using rule 45 (usable_value -> comparation_operation .)
    LOGICAL_AND     reduce using rule 45 (usable_value -> comparation_operation .)
    LOGICAL_OR      reduce using rule 45 (usable_value -> comparation_operation .)
    FMT_LIBRARY     reduce using rule 45 (usable_value -> comparation_operation .)
    FUNC            reduce using rule 45 (usable_value -> comparation_operation .)
    IDENTIFIER      reduce using rule 45 (usable_value -> comparation_operation .)
    INPUT           reduce using rule 45 (usable_value -> comparation_operation .)
    VAR             reduce using rule 45 (usable_value -> comparation_operation .)
    CONST           reduce using rule 45 (usable_value -> comparation_operation .)
    IF              reduce using rule 45 (usable_value -> comparation_operation .)
    FOR             reduce using rule 45 (usable_value -> comparation_operation .)
    STRING          reduce using rule 45 (usable_value -> comparation_operation .)
    INTEGER         reduce using rule 45 (usable_value -> comparation_operation .)
    FLOAT32         reduce using rule 45 (usable_value -> comparation_operation .)
    FLOAT64         reduce using rule 45 (usable_value -> comparation_operation .)
    BOOLEAN         reduce using rule 45 (usable_value -> comparation_operation .)
    BREAK           reduce using rule 45 (usable_value -> comparation_operation .)
    $end            reduce using rule 45 (usable_value -> comparation_operation .)
    RKEY            reduce using rule 45 (usable_value -> comparation_operation .)
    LKEY            reduce using rule 45 (usable_value -> comparation_operation .)


state 29

    (91) value -> STRING .

    PLUS            reduce using rule 91 (value -> STRING .)
    MINUS           reduce using rule 91 (value -> STRING .)
    DIVIDE          reduce using rule 91 (value -> STRING .)
    TIMES           reduce using rule 91 (value -> STRING .)
    ENTERE_DIVIDE   reduce using rule 91 (value -> STRING .)
    MODULE          reduce using rule 91 (value -> STRING .)
    EQUALEQUAL      reduce using rule 91 (value -> STRING .)
    NOT_EQUAL       reduce using rule 91 (value -> STRING .)
    LESS_EQUAL      reduce using rule 91 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 91 (value -> STRING .)
    LESS            reduce using rule 91 (value -> STRING .)
    GREATER         reduce using rule 91 (value -> STRING .)
    LOGICAL_AND     reduce using rule 91 (value -> STRING .)
    LOGICAL_OR      reduce using rule 91 (value -> STRING .)
    LKEY            reduce using rule 91 (value -> STRING .)
    RPAREN          reduce using rule 91 (value -> STRING .)
    COMMA           reduce using rule 91 (value -> STRING .)
    FMT_LIBRARY     reduce using rule 91 (value -> STRING .)
    FUNC            reduce using rule 91 (value -> STRING .)
    IDENTIFIER      reduce using rule 91 (value -> STRING .)
    INPUT           reduce using rule 91 (value -> STRING .)
    VAR             reduce using rule 91 (value -> STRING .)
    CONST           reduce using rule 91 (value -> STRING .)
    IF              reduce using rule 91 (value -> STRING .)
    FOR             reduce using rule 91 (value -> STRING .)
    STRING          reduce using rule 91 (value -> STRING .)
    INTEGER         reduce using rule 91 (value -> STRING .)
    FLOAT32         reduce using rule 91 (value -> STRING .)
    FLOAT64         reduce using rule 91 (value -> STRING .)
    BOOLEAN         reduce using rule 91 (value -> STRING .)
    BREAK           reduce using rule 91 (value -> STRING .)
    $end            reduce using rule 91 (value -> STRING .)
    RKEY            reduce using rule 91 (value -> STRING .)


state 30

    (92) value -> INTEGER .

    PLUS            reduce using rule 92 (value -> INTEGER .)
    MINUS           reduce using rule 92 (value -> INTEGER .)
    DIVIDE          reduce using rule 92 (value -> INTEGER .)
    TIMES           reduce using rule 92 (value -> INTEGER .)
    ENTERE_DIVIDE   reduce using rule 92 (value -> INTEGER .)
    MODULE          reduce using rule 92 (value -> INTEGER .)
    EQUALEQUAL      reduce using rule 92 (value -> INTEGER .)
    NOT_EQUAL       reduce using rule 92 (value -> INTEGER .)
    LESS_EQUAL      reduce using rule 92 (value -> INTEGER .)
    GREATER_EQUAL   reduce using rule 92 (value -> INTEGER .)
    LESS            reduce using rule 92 (value -> INTEGER .)
    GREATER         reduce using rule 92 (value -> INTEGER .)
    LOGICAL_AND     reduce using rule 92 (value -> INTEGER .)
    LOGICAL_OR      reduce using rule 92 (value -> INTEGER .)
    LKEY            reduce using rule 92 (value -> INTEGER .)
    RPAREN          reduce using rule 92 (value -> INTEGER .)
    COMMA           reduce using rule 92 (value -> INTEGER .)
    FMT_LIBRARY     reduce using rule 92 (value -> INTEGER .)
    FUNC            reduce using rule 92 (value -> INTEGER .)
    IDENTIFIER      reduce using rule 92 (value -> INTEGER .)
    INPUT           reduce using rule 92 (value -> INTEGER .)
    VAR             reduce using rule 92 (value -> INTEGER .)
    CONST           reduce using rule 92 (value -> INTEGER .)
    IF              reduce using rule 92 (value -> INTEGER .)
    FOR             reduce using rule 92 (value -> INTEGER .)
    STRING          reduce using rule 92 (value -> INTEGER .)
    INTEGER         reduce using rule 92 (value -> INTEGER .)
    FLOAT32         reduce using rule 92 (value -> INTEGER .)
    FLOAT64         reduce using rule 92 (value -> INTEGER .)
    BOOLEAN         reduce using rule 92 (value -> INTEGER .)
    BREAK           reduce using rule 92 (value -> INTEGER .)
    $end            reduce using rule 92 (value -> INTEGER .)
    RKEY            reduce using rule 92 (value -> INTEGER .)


state 31

    (93) value -> FLOAT32 .

    PLUS            reduce using rule 93 (value -> FLOAT32 .)
    MINUS           reduce using rule 93 (value -> FLOAT32 .)
    DIVIDE          reduce using rule 93 (value -> FLOAT32 .)
    TIMES           reduce using rule 93 (value -> FLOAT32 .)
    ENTERE_DIVIDE   reduce using rule 93 (value -> FLOAT32 .)
    MODULE          reduce using rule 93 (value -> FLOAT32 .)
    EQUALEQUAL      reduce using rule 93 (value -> FLOAT32 .)
    NOT_EQUAL       reduce using rule 93 (value -> FLOAT32 .)
    LESS_EQUAL      reduce using rule 93 (value -> FLOAT32 .)
    GREATER_EQUAL   reduce using rule 93 (value -> FLOAT32 .)
    LESS            reduce using rule 93 (value -> FLOAT32 .)
    GREATER         reduce using rule 93 (value -> FLOAT32 .)
    LOGICAL_AND     reduce using rule 93 (value -> FLOAT32 .)
    LOGICAL_OR      reduce using rule 93 (value -> FLOAT32 .)
    LKEY            reduce using rule 93 (value -> FLOAT32 .)
    RPAREN          reduce using rule 93 (value -> FLOAT32 .)
    COMMA           reduce using rule 93 (value -> FLOAT32 .)
    FMT_LIBRARY     reduce using rule 93 (value -> FLOAT32 .)
    FUNC            reduce using rule 93 (value -> FLOAT32 .)
    IDENTIFIER      reduce using rule 93 (value -> FLOAT32 .)
    INPUT           reduce using rule 93 (value -> FLOAT32 .)
    VAR             reduce using rule 93 (value -> FLOAT32 .)
    CONST           reduce using rule 93 (value -> FLOAT32 .)
    IF              reduce using rule 93 (value -> FLOAT32 .)
    FOR             reduce using rule 93 (value -> FLOAT32 .)
    STRING          reduce using rule 93 (value -> FLOAT32 .)
    INTEGER         reduce using rule 93 (value -> FLOAT32 .)
    FLOAT32         reduce using rule 93 (value -> FLOAT32 .)
    FLOAT64         reduce using rule 93 (value -> FLOAT32 .)
    BOOLEAN         reduce using rule 93 (value -> FLOAT32 .)
    BREAK           reduce using rule 93 (value -> FLOAT32 .)
    $end            reduce using rule 93 (value -> FLOAT32 .)
    RKEY            reduce using rule 93 (value -> FLOAT32 .)


state 32

    (94) value -> FLOAT64 .

    PLUS            reduce using rule 94 (value -> FLOAT64 .)
    MINUS           reduce using rule 94 (value -> FLOAT64 .)
    DIVIDE          reduce using rule 94 (value -> FLOAT64 .)
    TIMES           reduce using rule 94 (value -> FLOAT64 .)
    ENTERE_DIVIDE   reduce using rule 94 (value -> FLOAT64 .)
    MODULE          reduce using rule 94 (value -> FLOAT64 .)
    EQUALEQUAL      reduce using rule 94 (value -> FLOAT64 .)
    NOT_EQUAL       reduce using rule 94 (value -> FLOAT64 .)
    LESS_EQUAL      reduce using rule 94 (value -> FLOAT64 .)
    GREATER_EQUAL   reduce using rule 94 (value -> FLOAT64 .)
    LESS            reduce using rule 94 (value -> FLOAT64 .)
    GREATER         reduce using rule 94 (value -> FLOAT64 .)
    LOGICAL_AND     reduce using rule 94 (value -> FLOAT64 .)
    LOGICAL_OR      reduce using rule 94 (value -> FLOAT64 .)
    LKEY            reduce using rule 94 (value -> FLOAT64 .)
    RPAREN          reduce using rule 94 (value -> FLOAT64 .)
    COMMA           reduce using rule 94 (value -> FLOAT64 .)
    FMT_LIBRARY     reduce using rule 94 (value -> FLOAT64 .)
    FUNC            reduce using rule 94 (value -> FLOAT64 .)
    IDENTIFIER      reduce using rule 94 (value -> FLOAT64 .)
    INPUT           reduce using rule 94 (value -> FLOAT64 .)
    VAR             reduce using rule 94 (value -> FLOAT64 .)
    CONST           reduce using rule 94 (value -> FLOAT64 .)
    IF              reduce using rule 94 (value -> FLOAT64 .)
    FOR             reduce using rule 94 (value -> FLOAT64 .)
    STRING          reduce using rule 94 (value -> FLOAT64 .)
    INTEGER         reduce using rule 94 (value -> FLOAT64 .)
    FLOAT32         reduce using rule 94 (value -> FLOAT64 .)
    FLOAT64         reduce using rule 94 (value -> FLOAT64 .)
    BOOLEAN         reduce using rule 94 (value -> FLOAT64 .)
    BREAK           reduce using rule 94 (value -> FLOAT64 .)
    $end            reduce using rule 94 (value -> FLOAT64 .)
    RKEY            reduce using rule 94 (value -> FLOAT64 .)


state 33

    (95) value -> BOOLEAN .

    PLUS            reduce using rule 95 (value -> BOOLEAN .)
    MINUS           reduce using rule 95 (value -> BOOLEAN .)
    DIVIDE          reduce using rule 95 (value -> BOOLEAN .)
    TIMES           reduce using rule 95 (value -> BOOLEAN .)
    ENTERE_DIVIDE   reduce using rule 95 (value -> BOOLEAN .)
    MODULE          reduce using rule 95 (value -> BOOLEAN .)
    EQUALEQUAL      reduce using rule 95 (value -> BOOLEAN .)
    NOT_EQUAL       reduce using rule 95 (value -> BOOLEAN .)
    LESS_EQUAL      reduce using rule 95 (value -> BOOLEAN .)
    GREATER_EQUAL   reduce using rule 95 (value -> BOOLEAN .)
    LESS            reduce using rule 95 (value -> BOOLEAN .)
    GREATER         reduce using rule 95 (value -> BOOLEAN .)
    LOGICAL_AND     reduce using rule 95 (value -> BOOLEAN .)
    LOGICAL_OR      reduce using rule 95 (value -> BOOLEAN .)
    LKEY            reduce using rule 95 (value -> BOOLEAN .)
    RPAREN          reduce using rule 95 (value -> BOOLEAN .)
    COMMA           reduce using rule 95 (value -> BOOLEAN .)
    FMT_LIBRARY     reduce using rule 95 (value -> BOOLEAN .)
    FUNC            reduce using rule 95 (value -> BOOLEAN .)
    IDENTIFIER      reduce using rule 95 (value -> BOOLEAN .)
    INPUT           reduce using rule 95 (value -> BOOLEAN .)
    VAR             reduce using rule 95 (value -> BOOLEAN .)
    CONST           reduce using rule 95 (value -> BOOLEAN .)
    IF              reduce using rule 95 (value -> BOOLEAN .)
    FOR             reduce using rule 95 (value -> BOOLEAN .)
    STRING          reduce using rule 95 (value -> BOOLEAN .)
    INTEGER         reduce using rule 95 (value -> BOOLEAN .)
    FLOAT32         reduce using rule 95 (value -> BOOLEAN .)
    FLOAT64         reduce using rule 95 (value -> BOOLEAN .)
    BOOLEAN         reduce using rule 95 (value -> BOOLEAN .)
    BREAK           reduce using rule 95 (value -> BOOLEAN .)
    $end            reduce using rule 95 (value -> BOOLEAN .)
    RKEY            reduce using rule 95 (value -> BOOLEAN .)


state 34

    (3) loop_program -> loop_program program .
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! shift/reduce conflict for FMT_LIBRARY resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT32 resolved as shift
  ! shift/reduce conflict for FLOAT64 resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    BREAK           reduce using rule 3 (loop_program -> loop_program program .)
    $end            reduce using rule 3 (loop_program -> loop_program program .)
    RKEY            reduce using rule 3 (loop_program -> loop_program program .)
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

  ! FMT_LIBRARY     [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FUNC            [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! IDENTIFIER      [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! INPUT           [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! VAR             [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! CONST           [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! IF              [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FOR             [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! STRING          [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! INTEGER         [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FLOAT32         [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FLOAT64         [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! BOOLEAN         [ reduce using rule 3 (loop_program -> loop_program program .) ]

    sentencia                      shift and go to state 36
    loop                           shift and go to state 37
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 35

    (4) loop_program -> loop_program BREAK .

    BREAK           reduce using rule 4 (loop_program -> loop_program BREAK .)
    FMT_LIBRARY     reduce using rule 4 (loop_program -> loop_program BREAK .)
    FUNC            reduce using rule 4 (loop_program -> loop_program BREAK .)
    IDENTIFIER      reduce using rule 4 (loop_program -> loop_program BREAK .)
    INPUT           reduce using rule 4 (loop_program -> loop_program BREAK .)
    VAR             reduce using rule 4 (loop_program -> loop_program BREAK .)
    CONST           reduce using rule 4 (loop_program -> loop_program BREAK .)
    IF              reduce using rule 4 (loop_program -> loop_program BREAK .)
    FOR             reduce using rule 4 (loop_program -> loop_program BREAK .)
    STRING          reduce using rule 4 (loop_program -> loop_program BREAK .)
    INTEGER         reduce using rule 4 (loop_program -> loop_program BREAK .)
    FLOAT32         reduce using rule 4 (loop_program -> loop_program BREAK .)
    FLOAT64         reduce using rule 4 (loop_program -> loop_program BREAK .)
    BOOLEAN         reduce using rule 4 (loop_program -> loop_program BREAK .)
    $end            reduce using rule 4 (loop_program -> loop_program BREAK .)
    RKEY            reduce using rule 4 (loop_program -> loop_program BREAK .)


state 36

    (7) program -> program sentencia .

    FMT_LIBRARY     reduce using rule 7 (program -> program sentencia .)
    FUNC            reduce using rule 7 (program -> program sentencia .)
    IDENTIFIER      reduce using rule 7 (program -> program sentencia .)
    INPUT           reduce using rule 7 (program -> program sentencia .)
    VAR             reduce using rule 7 (program -> program sentencia .)
    CONST           reduce using rule 7 (program -> program sentencia .)
    IF              reduce using rule 7 (program -> program sentencia .)
    FOR             reduce using rule 7 (program -> program sentencia .)
    STRING          reduce using rule 7 (program -> program sentencia .)
    INTEGER         reduce using rule 7 (program -> program sentencia .)
    FLOAT32         reduce using rule 7 (program -> program sentencia .)
    FLOAT64         reduce using rule 7 (program -> program sentencia .)
    BOOLEAN         reduce using rule 7 (program -> program sentencia .)
    BREAK           reduce using rule 7 (program -> program sentencia .)
    $end            reduce using rule 7 (program -> program sentencia .)
    RKEY            reduce using rule 7 (program -> program sentencia .)


state 37

    (8) program -> program loop .

    FMT_LIBRARY     reduce using rule 8 (program -> program loop .)
    FUNC            reduce using rule 8 (program -> program loop .)
    IDENTIFIER      reduce using rule 8 (program -> program loop .)
    INPUT           reduce using rule 8 (program -> program loop .)
    VAR             reduce using rule 8 (program -> program loop .)
    CONST           reduce using rule 8 (program -> program loop .)
    IF              reduce using rule 8 (program -> program loop .)
    FOR             reduce using rule 8 (program -> program loop .)
    STRING          reduce using rule 8 (program -> program loop .)
    INTEGER         reduce using rule 8 (program -> program loop .)
    FLOAT32         reduce using rule 8 (program -> program loop .)
    FLOAT64         reduce using rule 8 (program -> program loop .)
    BOOLEAN         reduce using rule 8 (program -> program loop .)
    BREAK           reduce using rule 8 (program -> program loop .)
    $end            reduce using rule 8 (program -> program loop .)
    RKEY            reduce using rule 8 (program -> program loop .)


state 38

    (28) print -> FMT_LIBRARY DOT . PRINTLN LPAREN data RPAREN
    (29) print -> FMT_LIBRARY DOT . PRINTF LPAREN value RPAREN
    (30) print -> FMT_LIBRARY DOT . PRINTF LPAREN value COMMA RPAREN
    (31) print -> FMT_LIBRARY DOT . PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> FMT_LIBRARY DOT . PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> FMT_LIBRARY DOT . PRINTF LPAREN RPAREN

    PRINTLN         shift and go to state 78
    PRINTF          shift and go to state 79


state 39

    (84) def_function -> FUNC IDENTIFIER . LPAREN parameters RPAREN LKEY program RKEY

    LPAREN          shift and go to state 80


state 40

    (85) call_function -> IDENTIFIER LPAREN . values RPAREN
    (23) function_call -> IDENTIFIER LPAREN . values RPAREN
    (89) values -> . value
    (90) values -> . values COMMA value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    values                         shift and go to state 81
    value                          shift and go to state 82

state 41

    (40) short_assignment -> IDENTIFIER SHORT_VAR_DECL . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 83
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 42

    (46) direct_arithmetic_operation -> IDENTIFIER PLUS_EQ . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 84

state 43

    (47) direct_arithmetic_operation -> IDENTIFIER MINUS_EQ . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 85

state 44

    (48) direct_arithmetic_operation -> IDENTIFIER TIMES_EQ . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 86

state 45

    (49) direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 87

state 46

    (50) direct_arithmetic_operation -> IDENTIFIER MODULO_EQ . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 88

state 47

    (51) direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 89

state 48

    (52) direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 90

state 49

    (53) direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 91

state 50

    (54) direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 92

state 51

    (55) direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 93

state 52

    (101) input -> INPUT LPAREN . RPAREN
    (102) input -> INPUT LPAREN . value RPAREN
    (103) input -> INPUT LPAREN . identifiers RPAREN
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (70) identifiers -> . IDENTIFIER
    (71) identifiers -> . identifiers COMMA identifiers

    RPAREN          shift and go to state 94
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33
    IDENTIFIER      shift and go to state 97

    value                          shift and go to state 95
    identifiers                    shift and go to state 96

state 53

    (38) assignment -> VAR IDENTIFIER . data_type EQUAL usable_value
    (96) data_type -> . INTEGER_DATA_TYPE
    (97) data_type -> . FLOAT32_DATA_TYPE
    (98) data_type -> . FLOAT64_DATA_TYPE
    (99) data_type -> . BOOLEAN_DATA_TYPE
    (100) data_type -> . STRING_DATA_TYPE

    INTEGER_DATA_TYPE shift and go to state 99
    FLOAT32_DATA_TYPE shift and go to state 100
    FLOAT64_DATA_TYPE shift and go to state 101
    BOOLEAN_DATA_TYPE shift and go to state 102
    STRING_DATA_TYPE shift and go to state 103

    data_type                      shift and go to state 98

state 54

    (56) arithmetic_operation -> usable_value PLUS . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 104
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 55

    (57) arithmetic_operation -> usable_value MINUS . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 105
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 56

    (58) arithmetic_operation -> usable_value DIVIDE . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 106
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 57

    (59) arithmetic_operation -> usable_value TIMES . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 107
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 58

    (60) arithmetic_operation -> usable_value ENTERE_DIVIDE . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 108
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 59

    (61) arithmetic_operation -> usable_value MODULE . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 109
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 60

    (62) comparation_operation -> usable_value EQUALEQUAL . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 110
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 61

    (63) comparation_operation -> usable_value NOT_EQUAL . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 111
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 62

    (64) comparation_operation -> usable_value LESS_EQUAL . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 112
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 63

    (65) comparation_operation -> usable_value GREATER_EQUAL . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 113
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 64

    (66) comparation_operation -> usable_value LESS . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 114
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 65

    (67) comparation_operation -> usable_value GREATER . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 115
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 66

    (68) comparation_operation -> usable_value LOGICAL_AND . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 116
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 67

    (69) comparation_operation -> usable_value LOGICAL_OR . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 117
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 68

    (39) assignment -> CONST IDENTIFIER . data_type EQUAL usable_value
    (96) data_type -> . INTEGER_DATA_TYPE
    (97) data_type -> . FLOAT32_DATA_TYPE
    (98) data_type -> . FLOAT64_DATA_TYPE
    (99) data_type -> . BOOLEAN_DATA_TYPE
    (100) data_type -> . STRING_DATA_TYPE

    INTEGER_DATA_TYPE shift and go to state 99
    FLOAT32_DATA_TYPE shift and go to state 100
    FLOAT64_DATA_TYPE shift and go to state 101
    BOOLEAN_DATA_TYPE shift and go to state 102
    STRING_DATA_TYPE shift and go to state 103

    data_type                      shift and go to state 118

state 69

    (24) if_statement -> IF rule_comparation . LKEY program RKEY
    (25) if_statement -> IF rule_comparation . LKEY program RKEY ELSE LKEY program RKEY

    LKEY            shift and go to state 119


state 70

    (26) if_statement -> IF value . LKEY program RKEY
    (27) if_statement -> IF value . LKEY program RKEY ELSE LKEY program RKEY

    LKEY            shift and go to state 120


state 71

    (72) rule_comparation -> IDENTIFIER . EQUALEQUAL value
    (73) rule_comparation -> IDENTIFIER . NOT_EQUAL value
    (74) rule_comparation -> IDENTIFIER . LESS_EQUAL value
    (75) rule_comparation -> IDENTIFIER . GREATER_EQUAL value
    (76) rule_comparation -> IDENTIFIER . LESS value
    (77) rule_comparation -> IDENTIFIER . GREATER value
    (78) rule_comparation -> IDENTIFIER . LOGICAL_AND value
    (79) rule_comparation -> IDENTIFIER . LOGICAL_OR value

    EQUALEQUAL      shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    LESS            shift and go to state 125
    GREATER         shift and go to state 126
    LOGICAL_AND     shift and go to state 127
    LOGICAL_OR      shift and go to state 128


state 72

    (21) for -> FOR LKEY . loop_program RKEY
    (1) loop_program -> . program
    (2) loop_program -> . BREAK
    (3) loop_program -> . loop_program program
    (4) loop_program -> . loop_program BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 3
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    loop_program                   shift and go to state 129
    program                        shift and go to state 2
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 73

    (22) for -> FOR comparation_operation . LKEY loop_program RKEY
    (45) usable_value -> comparation_operation .

    LKEY            shift and go to state 130
    EQUALEQUAL      reduce using rule 45 (usable_value -> comparation_operation .)
    NOT_EQUAL       reduce using rule 45 (usable_value -> comparation_operation .)
    LESS_EQUAL      reduce using rule 45 (usable_value -> comparation_operation .)
    GREATER_EQUAL   reduce using rule 45 (usable_value -> comparation_operation .)
    LESS            reduce using rule 45 (usable_value -> comparation_operation .)
    GREATER         reduce using rule 45 (usable_value -> comparation_operation .)
    LOGICAL_AND     reduce using rule 45 (usable_value -> comparation_operation .)
    LOGICAL_OR      reduce using rule 45 (usable_value -> comparation_operation .)
    PLUS            reduce using rule 45 (usable_value -> comparation_operation .)
    MINUS           reduce using rule 45 (usable_value -> comparation_operation .)
    DIVIDE          reduce using rule 45 (usable_value -> comparation_operation .)
    TIMES           reduce using rule 45 (usable_value -> comparation_operation .)
    ENTERE_DIVIDE   reduce using rule 45 (usable_value -> comparation_operation .)
    MODULE          reduce using rule 45 (usable_value -> comparation_operation .)


state 74

    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value

    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59


state 75

    (42) usable_value -> call_function .

    EQUALEQUAL      reduce using rule 42 (usable_value -> call_function .)
    NOT_EQUAL       reduce using rule 42 (usable_value -> call_function .)
    LESS_EQUAL      reduce using rule 42 (usable_value -> call_function .)
    GREATER_EQUAL   reduce using rule 42 (usable_value -> call_function .)
    LESS            reduce using rule 42 (usable_value -> call_function .)
    GREATER         reduce using rule 42 (usable_value -> call_function .)
    LOGICAL_AND     reduce using rule 42 (usable_value -> call_function .)
    LOGICAL_OR      reduce using rule 42 (usable_value -> call_function .)
    PLUS            reduce using rule 42 (usable_value -> call_function .)
    MINUS           reduce using rule 42 (usable_value -> call_function .)
    DIVIDE          reduce using rule 42 (usable_value -> call_function .)
    TIMES           reduce using rule 42 (usable_value -> call_function .)
    ENTERE_DIVIDE   reduce using rule 42 (usable_value -> call_function .)
    MODULE          reduce using rule 42 (usable_value -> call_function .)
    FMT_LIBRARY     reduce using rule 42 (usable_value -> call_function .)
    FUNC            reduce using rule 42 (usable_value -> call_function .)
    IDENTIFIER      reduce using rule 42 (usable_value -> call_function .)
    INPUT           reduce using rule 42 (usable_value -> call_function .)
    VAR             reduce using rule 42 (usable_value -> call_function .)
    CONST           reduce using rule 42 (usable_value -> call_function .)
    IF              reduce using rule 42 (usable_value -> call_function .)
    FOR             reduce using rule 42 (usable_value -> call_function .)
    STRING          reduce using rule 42 (usable_value -> call_function .)
    INTEGER         reduce using rule 42 (usable_value -> call_function .)
    FLOAT32         reduce using rule 42 (usable_value -> call_function .)
    FLOAT64         reduce using rule 42 (usable_value -> call_function .)
    BOOLEAN         reduce using rule 42 (usable_value -> call_function .)
    BREAK           reduce using rule 42 (usable_value -> call_function .)
    $end            reduce using rule 42 (usable_value -> call_function .)
    RKEY            reduce using rule 42 (usable_value -> call_function .)
    LKEY            reduce using rule 42 (usable_value -> call_function .)


state 76

    (43) usable_value -> IDENTIFIER .
    (85) call_function -> IDENTIFIER . LPAREN values RPAREN

    EQUALEQUAL      reduce using rule 43 (usable_value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 43 (usable_value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 43 (usable_value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 43 (usable_value -> IDENTIFIER .)
    LESS            reduce using rule 43 (usable_value -> IDENTIFIER .)
    GREATER         reduce using rule 43 (usable_value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 43 (usable_value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 43 (usable_value -> IDENTIFIER .)
    PLUS            reduce using rule 43 (usable_value -> IDENTIFIER .)
    MINUS           reduce using rule 43 (usable_value -> IDENTIFIER .)
    DIVIDE          reduce using rule 43 (usable_value -> IDENTIFIER .)
    TIMES           reduce using rule 43 (usable_value -> IDENTIFIER .)
    ENTERE_DIVIDE   reduce using rule 43 (usable_value -> IDENTIFIER .)
    MODULE          reduce using rule 43 (usable_value -> IDENTIFIER .)
    FMT_LIBRARY     reduce using rule 43 (usable_value -> IDENTIFIER .)
    FUNC            reduce using rule 43 (usable_value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 43 (usable_value -> IDENTIFIER .)
    INPUT           reduce using rule 43 (usable_value -> IDENTIFIER .)
    VAR             reduce using rule 43 (usable_value -> IDENTIFIER .)
    CONST           reduce using rule 43 (usable_value -> IDENTIFIER .)
    IF              reduce using rule 43 (usable_value -> IDENTIFIER .)
    FOR             reduce using rule 43 (usable_value -> IDENTIFIER .)
    STRING          reduce using rule 43 (usable_value -> IDENTIFIER .)
    INTEGER         reduce using rule 43 (usable_value -> IDENTIFIER .)
    FLOAT32         reduce using rule 43 (usable_value -> IDENTIFIER .)
    FLOAT64         reduce using rule 43 (usable_value -> IDENTIFIER .)
    BOOLEAN         reduce using rule 43 (usable_value -> IDENTIFIER .)
    BREAK           reduce using rule 43 (usable_value -> IDENTIFIER .)
    $end            reduce using rule 43 (usable_value -> IDENTIFIER .)
    RKEY            reduce using rule 43 (usable_value -> IDENTIFIER .)
    LKEY            reduce using rule 43 (usable_value -> IDENTIFIER .)
    LPAREN          shift and go to state 131


state 77

    (44) usable_value -> arithmetic_operation .

    EQUALEQUAL      reduce using rule 44 (usable_value -> arithmetic_operation .)
    NOT_EQUAL       reduce using rule 44 (usable_value -> arithmetic_operation .)
    LESS_EQUAL      reduce using rule 44 (usable_value -> arithmetic_operation .)
    GREATER_EQUAL   reduce using rule 44 (usable_value -> arithmetic_operation .)
    LESS            reduce using rule 44 (usable_value -> arithmetic_operation .)
    GREATER         reduce using rule 44 (usable_value -> arithmetic_operation .)
    LOGICAL_AND     reduce using rule 44 (usable_value -> arithmetic_operation .)
    LOGICAL_OR      reduce using rule 44 (usable_value -> arithmetic_operation .)
    PLUS            reduce using rule 44 (usable_value -> arithmetic_operation .)
    MINUS           reduce using rule 44 (usable_value -> arithmetic_operation .)
    DIVIDE          reduce using rule 44 (usable_value -> arithmetic_operation .)
    TIMES           reduce using rule 44 (usable_value -> arithmetic_operation .)
    ENTERE_DIVIDE   reduce using rule 44 (usable_value -> arithmetic_operation .)
    MODULE          reduce using rule 44 (usable_value -> arithmetic_operation .)
    FMT_LIBRARY     reduce using rule 44 (usable_value -> arithmetic_operation .)
    FUNC            reduce using rule 44 (usable_value -> arithmetic_operation .)
    IDENTIFIER      reduce using rule 44 (usable_value -> arithmetic_operation .)
    INPUT           reduce using rule 44 (usable_value -> arithmetic_operation .)
    VAR             reduce using rule 44 (usable_value -> arithmetic_operation .)
    CONST           reduce using rule 44 (usable_value -> arithmetic_operation .)
    IF              reduce using rule 44 (usable_value -> arithmetic_operation .)
    FOR             reduce using rule 44 (usable_value -> arithmetic_operation .)
    STRING          reduce using rule 44 (usable_value -> arithmetic_operation .)
    INTEGER         reduce using rule 44 (usable_value -> arithmetic_operation .)
    FLOAT32         reduce using rule 44 (usable_value -> arithmetic_operation .)
    FLOAT64         reduce using rule 44 (usable_value -> arithmetic_operation .)
    BOOLEAN         reduce using rule 44 (usable_value -> arithmetic_operation .)
    BREAK           reduce using rule 44 (usable_value -> arithmetic_operation .)
    $end            reduce using rule 44 (usable_value -> arithmetic_operation .)
    RKEY            reduce using rule 44 (usable_value -> arithmetic_operation .)
    LKEY            reduce using rule 44 (usable_value -> arithmetic_operation .)


state 78

    (28) print -> FMT_LIBRARY DOT PRINTLN . LPAREN data RPAREN
    (36) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN . LPAREN RPAREN

    LPAREN          shift and go to state 132


state 79

    (29) print -> FMT_LIBRARY DOT PRINTF . LPAREN value RPAREN
    (30) print -> FMT_LIBRARY DOT PRINTF . LPAREN value COMMA RPAREN
    (31) print -> FMT_LIBRARY DOT PRINTF . LPAREN value COMMA data RPAREN
    (37) print_withoutvalue -> FMT_LIBRARY DOT PRINTF . LPAREN RPAREN

    LPAREN          shift and go to state 133


state 80

    (84) def_function -> FUNC IDENTIFIER LPAREN . parameters RPAREN LKEY program RKEY
    (86) parameters -> . parameter
    (87) parameters -> . parameters COMMA parameter
    (88) parameter -> . IDENTIFIER data_type

    IDENTIFIER      shift and go to state 134

    parameters                     shift and go to state 135
    parameter                      shift and go to state 136

state 81

    (85) call_function -> IDENTIFIER LPAREN values . RPAREN
    (23) function_call -> IDENTIFIER LPAREN values . RPAREN
    (90) values -> values . COMMA value

    RPAREN          shift and go to state 137
    COMMA           shift and go to state 138


state 82

    (89) values -> value .

    RPAREN          reduce using rule 89 (values -> value .)
    COMMA           reduce using rule 89 (values -> value .)


state 83

    (40) short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

    FMT_LIBRARY     reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FUNC            reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    IDENTIFIER      reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    INPUT           reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    VAR             reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    CONST           reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    IF              reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FOR             reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    STRING          reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    INTEGER         reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FLOAT32         reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FLOAT64         reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    BOOLEAN         reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    BREAK           reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    $end            reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    RKEY            reduce using rule 40 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67


state 84

    (46) direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .

    FMT_LIBRARY     reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FUNC            reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    IDENTIFIER      reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    INPUT           reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    VAR             reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    CONST           reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    IF              reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FOR             reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    STRING          reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    INTEGER         reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FLOAT32         reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FLOAT64         reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    BOOLEAN         reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    BREAK           reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    $end            reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    RKEY            reduce using rule 46 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)


state 85

    (47) direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .

    FMT_LIBRARY     reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FUNC            reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    IDENTIFIER      reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    INPUT           reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    VAR             reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    CONST           reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    IF              reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FOR             reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    STRING          reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    INTEGER         reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FLOAT32         reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FLOAT64         reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    BOOLEAN         reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    BREAK           reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    $end            reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    RKEY            reduce using rule 47 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)


state 86

    (48) direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .

    FMT_LIBRARY     reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FUNC            reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    IDENTIFIER      reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    INPUT           reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    VAR             reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    CONST           reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    IF              reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FOR             reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    STRING          reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    INTEGER         reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FLOAT32         reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FLOAT64         reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    BOOLEAN         reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    BREAK           reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    $end            reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    RKEY            reduce using rule 48 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)


state 87

    (49) direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .

    FMT_LIBRARY     reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FUNC            reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    IDENTIFIER      reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    INPUT           reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    VAR             reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    CONST           reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    IF              reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FOR             reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    STRING          reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    INTEGER         reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FLOAT32         reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FLOAT64         reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    BOOLEAN         reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    BREAK           reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    $end            reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    RKEY            reduce using rule 49 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)


state 88

    (50) direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .

    FMT_LIBRARY     reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FUNC            reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    IDENTIFIER      reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    INPUT           reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    VAR             reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    CONST           reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    IF              reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FOR             reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    STRING          reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    INTEGER         reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FLOAT32         reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FLOAT64         reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    BOOLEAN         reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    BREAK           reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    $end            reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    RKEY            reduce using rule 50 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)


state 89

    (51) direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .

    FMT_LIBRARY     reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FUNC            reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    IDENTIFIER      reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    INPUT           reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    VAR             reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    CONST           reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    IF              reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FOR             reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    STRING          reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    INTEGER         reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FLOAT32         reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FLOAT64         reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    BOOLEAN         reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    BREAK           reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    $end            reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    RKEY            reduce using rule 51 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)


state 90

    (52) direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .

    FMT_LIBRARY     reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FUNC            reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    IDENTIFIER      reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    INPUT           reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    VAR             reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    CONST           reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    IF              reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FOR             reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    STRING          reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    INTEGER         reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FLOAT32         reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FLOAT64         reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    BOOLEAN         reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    BREAK           reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    $end            reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    RKEY            reduce using rule 52 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)


state 91

    (53) direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .

    FMT_LIBRARY     reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FUNC            reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    IDENTIFIER      reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    INPUT           reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    VAR             reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    CONST           reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    IF              reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FOR             reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    STRING          reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    INTEGER         reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FLOAT32         reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FLOAT64         reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    BOOLEAN         reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    BREAK           reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    $end            reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    RKEY            reduce using rule 53 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)


state 92

    (54) direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .

    FMT_LIBRARY     reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FUNC            reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    IDENTIFIER      reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    INPUT           reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    VAR             reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    CONST           reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    IF              reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FOR             reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    STRING          reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    INTEGER         reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FLOAT32         reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FLOAT64         reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    BOOLEAN         reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    BREAK           reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    $end            reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    RKEY            reduce using rule 54 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)


state 93

    (55) direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .

    FMT_LIBRARY     reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FUNC            reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    IDENTIFIER      reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    INPUT           reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    VAR             reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    CONST           reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    IF              reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FOR             reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    STRING          reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    INTEGER         reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FLOAT32         reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FLOAT64         reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    BOOLEAN         reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    BREAK           reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    $end            reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    RKEY            reduce using rule 55 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)


state 94

    (101) input -> INPUT LPAREN RPAREN .

    FMT_LIBRARY     reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    FUNC            reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    CONST           reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    STRING          reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    INTEGER         reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    FLOAT32         reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    FLOAT64         reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    BOOLEAN         reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    BREAK           reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 101 (input -> INPUT LPAREN RPAREN .)
    RKEY            reduce using rule 101 (input -> INPUT LPAREN RPAREN .)


state 95

    (102) input -> INPUT LPAREN value . RPAREN

    RPAREN          shift and go to state 139


state 96

    (103) input -> INPUT LPAREN identifiers . RPAREN
    (71) identifiers -> identifiers . COMMA identifiers

    RPAREN          shift and go to state 140
    COMMA           shift and go to state 141


state 97

    (70) identifiers -> IDENTIFIER .

    RPAREN          reduce using rule 70 (identifiers -> IDENTIFIER .)
    COMMA           reduce using rule 70 (identifiers -> IDENTIFIER .)


state 98

    (38) assignment -> VAR IDENTIFIER data_type . EQUAL usable_value

    EQUAL           shift and go to state 142


state 99

    (96) data_type -> INTEGER_DATA_TYPE .

    EQUAL           reduce using rule 96 (data_type -> INTEGER_DATA_TYPE .)
    RPAREN          reduce using rule 96 (data_type -> INTEGER_DATA_TYPE .)
    COMMA           reduce using rule 96 (data_type -> INTEGER_DATA_TYPE .)


state 100

    (97) data_type -> FLOAT32_DATA_TYPE .

    EQUAL           reduce using rule 97 (data_type -> FLOAT32_DATA_TYPE .)
    RPAREN          reduce using rule 97 (data_type -> FLOAT32_DATA_TYPE .)
    COMMA           reduce using rule 97 (data_type -> FLOAT32_DATA_TYPE .)


state 101

    (98) data_type -> FLOAT64_DATA_TYPE .

    EQUAL           reduce using rule 98 (data_type -> FLOAT64_DATA_TYPE .)
    RPAREN          reduce using rule 98 (data_type -> FLOAT64_DATA_TYPE .)
    COMMA           reduce using rule 98 (data_type -> FLOAT64_DATA_TYPE .)


state 102

    (99) data_type -> BOOLEAN_DATA_TYPE .

    EQUAL           reduce using rule 99 (data_type -> BOOLEAN_DATA_TYPE .)
    RPAREN          reduce using rule 99 (data_type -> BOOLEAN_DATA_TYPE .)
    COMMA           reduce using rule 99 (data_type -> BOOLEAN_DATA_TYPE .)


state 103

    (100) data_type -> STRING_DATA_TYPE .

    EQUAL           reduce using rule 100 (data_type -> STRING_DATA_TYPE .)
    RPAREN          reduce using rule 100 (data_type -> STRING_DATA_TYPE .)
    COMMA           reduce using rule 100 (data_type -> STRING_DATA_TYPE .)


state 104

    (56) arithmetic_operation -> usable_value PLUS usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    FUNC            reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    IDENTIFIER      reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    INPUT           reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    VAR             reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    CONST           reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    IF              reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    FOR             reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    STRING          reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    INTEGER         reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    FLOAT32         reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    FLOAT64         reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    BOOLEAN         reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    BREAK           reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    $end            reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    RKEY            reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    LKEY            reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! MINUS           [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! DIVIDE          [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! TIMES           [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! MODULE          [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LESS            [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! GREATER         [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 56 (arithmetic_operation -> usable_value PLUS usable_value .) ]


state 105

    (57) arithmetic_operation -> usable_value MINUS usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    FUNC            reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    IDENTIFIER      reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    INPUT           reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    VAR             reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    CONST           reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    IF              reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    FOR             reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    STRING          reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    INTEGER         reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    FLOAT32         reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    FLOAT64         reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    BOOLEAN         reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    BREAK           reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    $end            reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    RKEY            reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    LKEY            reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! MINUS           [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! DIVIDE          [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! TIMES           [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! MODULE          [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LESS            [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! GREATER         [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 57 (arithmetic_operation -> usable_value MINUS usable_value .) ]


state 106

    (58) arithmetic_operation -> usable_value DIVIDE usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FUNC            reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    IDENTIFIER      reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    INPUT           reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    VAR             reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    CONST           reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    IF              reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FOR             reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    STRING          reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    INTEGER         reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FLOAT32         reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FLOAT64         reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    BOOLEAN         reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    BREAK           reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    $end            reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    RKEY            reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    LKEY            reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! MINUS           [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! DIVIDE          [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! TIMES           [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! MODULE          [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LESS            [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! GREATER         [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 58 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]


state 107

    (59) arithmetic_operation -> usable_value TIMES usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    FUNC            reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    IDENTIFIER      reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    INPUT           reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    VAR             reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    CONST           reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    IF              reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    FOR             reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    STRING          reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    INTEGER         reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    FLOAT32         reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    FLOAT64         reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    BOOLEAN         reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    BREAK           reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    $end            reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    RKEY            reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    LKEY            reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! MINUS           [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! DIVIDE          [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! TIMES           [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! MODULE          [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LESS            [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! GREATER         [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 59 (arithmetic_operation -> usable_value TIMES usable_value .) ]


state 108

    (60) arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FUNC            reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    IDENTIFIER      reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    INPUT           reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    VAR             reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    CONST           reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    IF              reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FOR             reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    STRING          reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    INTEGER         reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FLOAT32         reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FLOAT64         reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    BOOLEAN         reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    BREAK           reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    $end            reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    RKEY            reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    LKEY            reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! MINUS           [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! DIVIDE          [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! TIMES           [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! MODULE          [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LESS            [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! GREATER         [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 60 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]


state 109

    (61) arithmetic_operation -> usable_value MODULE usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    FUNC            reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    IDENTIFIER      reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    INPUT           reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    VAR             reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    CONST           reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    IF              reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    FOR             reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    STRING          reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    INTEGER         reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    FLOAT32         reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    FLOAT64         reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    BOOLEAN         reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    BREAK           reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    $end            reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    RKEY            reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    LKEY            reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! MINUS           [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! DIVIDE          [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! TIMES           [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! MODULE          [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LESS            [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! GREATER         [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 61 (arithmetic_operation -> usable_value MODULE usable_value .) ]


state 110

    (62) comparation_operation -> usable_value EQUALEQUAL usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FUNC            reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    IDENTIFIER      reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    INPUT           reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    VAR             reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    CONST           reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    IF              reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FOR             reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    STRING          reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    INTEGER         reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FLOAT32         reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FLOAT64         reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    BOOLEAN         reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    BREAK           reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    $end            reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    RKEY            reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LESS            [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 62 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]


state 111

    (63) comparation_operation -> usable_value NOT_EQUAL usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FUNC            reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    IDENTIFIER      reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    INPUT           reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    VAR             reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    CONST           reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    IF              reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FOR             reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    STRING          reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    INTEGER         reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FLOAT32         reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FLOAT64         reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    BOOLEAN         reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    BREAK           reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    $end            reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    RKEY            reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LESS            [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 63 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]


state 112

    (64) comparation_operation -> usable_value LESS_EQUAL usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FUNC            reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    IDENTIFIER      reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    INPUT           reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    VAR             reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    CONST           reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    IF              reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FOR             reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    STRING          reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    INTEGER         reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FLOAT32         reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FLOAT64         reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    BOOLEAN         reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    BREAK           reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    $end            reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    RKEY            reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LESS            [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 64 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]


state 113

    (65) comparation_operation -> usable_value GREATER_EQUAL usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FUNC            reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    IDENTIFIER      reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    INPUT           reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    VAR             reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    CONST           reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    IF              reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FOR             reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    STRING          reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    INTEGER         reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FLOAT32         reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FLOAT64         reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    BOOLEAN         reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    BREAK           reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    $end            reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    RKEY            reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LESS            [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 65 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]


state 114

    (66) comparation_operation -> usable_value LESS usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    FMT_LIBRARY     reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    FUNC            reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    IDENTIFIER      reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    INPUT           reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    VAR             reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    CONST           reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    IF              reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    FOR             reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    STRING          reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    INTEGER         reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    FLOAT32         reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    FLOAT64         reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    BOOLEAN         reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    BREAK           reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    $end            reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    RKEY            reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! MINUS           [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! DIVIDE          [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! TIMES           [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! MODULE          [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LESS            [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! GREATER         [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 66 (comparation_operation -> usable_value LESS usable_value .) ]


state 115

    (67) comparation_operation -> usable_value GREATER usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    FMT_LIBRARY     reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    FUNC            reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    IDENTIFIER      reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    INPUT           reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    VAR             reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    CONST           reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    IF              reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    FOR             reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    STRING          reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    INTEGER         reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    FLOAT32         reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    FLOAT64         reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    BOOLEAN         reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    BREAK           reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    $end            reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    RKEY            reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! MINUS           [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! DIVIDE          [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! TIMES           [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! MODULE          [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LESS            [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! GREATER         [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 67 (comparation_operation -> usable_value GREATER usable_value .) ]


state 116

    (68) comparation_operation -> usable_value LOGICAL_AND usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FMT_LIBRARY     reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FUNC            reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    IDENTIFIER      reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    INPUT           reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    VAR             reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    CONST           reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    IF              reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FOR             reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    STRING          reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    INTEGER         reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FLOAT32         reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FLOAT64         reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    BOOLEAN         reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    BREAK           reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    $end            reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    RKEY            reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! MINUS           [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! DIVIDE          [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! TIMES           [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! MODULE          [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LESS            [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! GREATER         [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 68 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]


state 117

    (69) comparation_operation -> usable_value LOGICAL_OR usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FMT_LIBRARY     reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FUNC            reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    IDENTIFIER      reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    INPUT           reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    VAR             reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    CONST           reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    IF              reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FOR             reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    STRING          reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    INTEGER         reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FLOAT32         reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FLOAT64         reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    BOOLEAN         reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    BREAK           reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    $end            reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    RKEY            reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67

  ! PLUS            [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! MINUS           [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! DIVIDE          [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! TIMES           [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! MODULE          [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LESS            [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! GREATER         [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 69 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]


state 118

    (39) assignment -> CONST IDENTIFIER data_type . EQUAL usable_value

    EQUAL           shift and go to state 143


state 119

    (24) if_statement -> IF rule_comparation LKEY . program RKEY
    (25) if_statement -> IF rule_comparation LKEY . program RKEY ELSE LKEY program RKEY
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    program                        shift and go to state 144
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 120

    (26) if_statement -> IF value LKEY . program RKEY
    (27) if_statement -> IF value LKEY . program RKEY ELSE LKEY program RKEY
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 19
    program                        shift and go to state 145
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 121

    (72) rule_comparation -> IDENTIFIER EQUALEQUAL . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 146

state 122

    (73) rule_comparation -> IDENTIFIER NOT_EQUAL . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 147

state 123

    (74) rule_comparation -> IDENTIFIER LESS_EQUAL . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 148

state 124

    (75) rule_comparation -> IDENTIFIER GREATER_EQUAL . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 149

state 125

    (76) rule_comparation -> IDENTIFIER LESS . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 150

state 126

    (77) rule_comparation -> IDENTIFIER GREATER . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 151

state 127

    (78) rule_comparation -> IDENTIFIER LOGICAL_AND . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 152

state 128

    (79) rule_comparation -> IDENTIFIER LOGICAL_OR . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 153

state 129

    (21) for -> FOR LKEY loop_program . RKEY
    (3) loop_program -> loop_program . program
    (4) loop_program -> loop_program . BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 154
    BREAK           shift and go to state 35
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    program                        shift and go to state 34
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 130

    (22) for -> FOR comparation_operation LKEY . loop_program RKEY
    (1) loop_program -> . program
    (2) loop_program -> . BREAK
    (3) loop_program -> . loop_program program
    (4) loop_program -> . loop_program BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 3
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    comparation_operation          shift and go to state 28
    loop_program                   shift and go to state 155
    program                        shift and go to state 2
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24

state 131

    (85) call_function -> IDENTIFIER LPAREN . values RPAREN
    (89) values -> . value
    (90) values -> . values COMMA value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    values                         shift and go to state 156
    value                          shift and go to state 82

state 132

    (28) print -> FMT_LIBRARY DOT PRINTLN LPAREN . data RPAREN
    (36) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN . RPAREN
    (32) data -> . value
    (33) data -> . IDENTIFIER
    (34) data -> . data COMMA value
    (35) data -> . data COMMA IDENTIFIER
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    RPAREN          shift and go to state 158
    IDENTIFIER      shift and go to state 160
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    data                           shift and go to state 157
    value                          shift and go to state 159

state 133

    (29) print -> FMT_LIBRARY DOT PRINTF LPAREN . value RPAREN
    (30) print -> FMT_LIBRARY DOT PRINTF LPAREN . value COMMA RPAREN
    (31) print -> FMT_LIBRARY DOT PRINTF LPAREN . value COMMA data RPAREN
    (37) print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN . RPAREN
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    RPAREN          shift and go to state 162
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 161

state 134

    (88) parameter -> IDENTIFIER . data_type
    (96) data_type -> . INTEGER_DATA_TYPE
    (97) data_type -> . FLOAT32_DATA_TYPE
    (98) data_type -> . FLOAT64_DATA_TYPE
    (99) data_type -> . BOOLEAN_DATA_TYPE
    (100) data_type -> . STRING_DATA_TYPE

    INTEGER_DATA_TYPE shift and go to state 99
    FLOAT32_DATA_TYPE shift and go to state 100
    FLOAT64_DATA_TYPE shift and go to state 101
    BOOLEAN_DATA_TYPE shift and go to state 102
    STRING_DATA_TYPE shift and go to state 103

    data_type                      shift and go to state 163

state 135

    (84) def_function -> FUNC IDENTIFIER LPAREN parameters . RPAREN LKEY program RKEY
    (87) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 164
    COMMA           shift and go to state 165


state 136

    (86) parameters -> parameter .

    RPAREN          reduce using rule 86 (parameters -> parameter .)
    COMMA           reduce using rule 86 (parameters -> parameter .)


state 137

    (85) call_function -> IDENTIFIER LPAREN values RPAREN .
    (23) function_call -> IDENTIFIER LPAREN values RPAREN .

  ! reduce/reduce conflict for FMT_LIBRARY resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for INPUT resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for VAR resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for CONST resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for STRING resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for INTEGER resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for RKEY resolved using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PLUS            reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MINUS           reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    DIVIDE          reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    TIMES           reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    ENTERE_DIVIDE   reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MODULE          reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    EQUALEQUAL      reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    NOT_EQUAL       reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS_EQUAL      reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER_EQUAL   reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS            reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER         reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_AND     reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_OR      reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FMT_LIBRARY     reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FUNC            reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INPUT           reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING          reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER         reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FLOAT32         reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FLOAT64         reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN         reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BREAK           reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    $end            reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RKEY            reduce using rule 23 (function_call -> IDENTIFIER LPAREN values RPAREN .)

  ! FMT_LIBRARY     [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FUNC            [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! IDENTIFIER      [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! INPUT           [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! VAR             [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! CONST           [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! IF              [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FOR             [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! STRING          [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! INTEGER         [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FLOAT32         [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FLOAT64         [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! BOOLEAN         [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! BREAK           [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! $end            [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! RKEY            [ reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]


state 138

    (90) values -> values COMMA . value
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 166

state 139

    (102) input -> INPUT LPAREN value RPAREN .

    FMT_LIBRARY     reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    FUNC            reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    IDENTIFIER      reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    INPUT           reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    VAR             reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    CONST           reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    IF              reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    FOR             reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    STRING          reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    INTEGER         reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    FLOAT32         reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    FLOAT64         reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    BOOLEAN         reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    BREAK           reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    $end            reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)
    RKEY            reduce using rule 102 (input -> INPUT LPAREN value RPAREN .)


state 140

    (103) input -> INPUT LPAREN identifiers RPAREN .

    FMT_LIBRARY     reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    FUNC            reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    IDENTIFIER      reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    INPUT           reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    VAR             reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    CONST           reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    IF              reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    FOR             reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    STRING          reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    INTEGER         reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    FLOAT32         reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    FLOAT64         reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    BOOLEAN         reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    BREAK           reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    $end            reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)
    RKEY            reduce using rule 103 (input -> INPUT LPAREN identifiers RPAREN .)


state 141

    (71) identifiers -> identifiers COMMA . identifiers
    (70) identifiers -> . IDENTIFIER
    (71) identifiers -> . identifiers COMMA identifiers

    IDENTIFIER      shift and go to state 97

    identifiers                    shift and go to state 167

state 142

    (38) assignment -> VAR IDENTIFIER data_type EQUAL . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 168
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 143

    (39) assignment -> CONST IDENTIFIER data_type EQUAL . usable_value
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 76
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    usable_value                   shift and go to state 169
    value                          shift and go to state 19
    call_function                  shift and go to state 75
    arithmetic_operation           shift and go to state 77
    comparation_operation          shift and go to state 28

state 144

    (24) if_statement -> IF rule_comparation LKEY program . RKEY
    (25) if_statement -> IF rule_comparation LKEY program . RKEY ELSE LKEY program RKEY
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 170
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    sentencia                      shift and go to state 36
    loop                           shift and go to state 37
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 145

    (26) if_statement -> IF value LKEY program . RKEY
    (27) if_statement -> IF value LKEY program . RKEY ELSE LKEY program RKEY
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 171
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 19
    sentencia                      shift and go to state 36
    loop                           shift and go to state 37
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 146

    (72) rule_comparation -> IDENTIFIER EQUALEQUAL value .

    LKEY            reduce using rule 72 (rule_comparation -> IDENTIFIER EQUALEQUAL value .)


state 147

    (73) rule_comparation -> IDENTIFIER NOT_EQUAL value .

    LKEY            reduce using rule 73 (rule_comparation -> IDENTIFIER NOT_EQUAL value .)


state 148

    (74) rule_comparation -> IDENTIFIER LESS_EQUAL value .

    LKEY            reduce using rule 74 (rule_comparation -> IDENTIFIER LESS_EQUAL value .)


state 149

    (75) rule_comparation -> IDENTIFIER GREATER_EQUAL value .

    LKEY            reduce using rule 75 (rule_comparation -> IDENTIFIER GREATER_EQUAL value .)


state 150

    (76) rule_comparation -> IDENTIFIER LESS value .

    LKEY            reduce using rule 76 (rule_comparation -> IDENTIFIER LESS value .)


state 151

    (77) rule_comparation -> IDENTIFIER GREATER value .

    LKEY            reduce using rule 77 (rule_comparation -> IDENTIFIER GREATER value .)


state 152

    (78) rule_comparation -> IDENTIFIER LOGICAL_AND value .

    LKEY            reduce using rule 78 (rule_comparation -> IDENTIFIER LOGICAL_AND value .)


state 153

    (79) rule_comparation -> IDENTIFIER LOGICAL_OR value .

    LKEY            reduce using rule 79 (rule_comparation -> IDENTIFIER LOGICAL_OR value .)


state 154

    (21) for -> FOR LKEY loop_program RKEY .

    FMT_LIBRARY     reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    FUNC            reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    IDENTIFIER      reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    INPUT           reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    VAR             reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    CONST           reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    IF              reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    FOR             reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    STRING          reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    INTEGER         reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    FLOAT32         reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    FLOAT64         reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    BOOLEAN         reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    BREAK           reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    $end            reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)
    RKEY            reduce using rule 21 (for -> FOR LKEY loop_program RKEY .)


state 155

    (22) for -> FOR comparation_operation LKEY loop_program . RKEY
    (3) loop_program -> loop_program . program
    (4) loop_program -> loop_program . BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 172
    BREAK           shift and go to state 35
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    comparation_operation          shift and go to state 28
    program                        shift and go to state 34
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24

state 156

    (85) call_function -> IDENTIFIER LPAREN values . RPAREN
    (90) values -> values . COMMA value

    RPAREN          shift and go to state 173
    COMMA           shift and go to state 138


state 157

    (28) print -> FMT_LIBRARY DOT PRINTLN LPAREN data . RPAREN
    (34) data -> data . COMMA value
    (35) data -> data . COMMA IDENTIFIER

    RPAREN          shift and go to state 174
    COMMA           shift and go to state 175


state 158

    (36) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .

    FMT_LIBRARY     reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FUNC            reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    INPUT           reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    VAR             reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    CONST           reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    IF              reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FOR             reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    STRING          reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    INTEGER         reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FLOAT32         reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FLOAT64         reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    BOOLEAN         reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    BREAK           reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    $end            reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    RKEY            reduce using rule 36 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)


state 159

    (32) data -> value .

    RPAREN          reduce using rule 32 (data -> value .)
    COMMA           reduce using rule 32 (data -> value .)


state 160

    (33) data -> IDENTIFIER .

    RPAREN          reduce using rule 33 (data -> IDENTIFIER .)
    COMMA           reduce using rule 33 (data -> IDENTIFIER .)


state 161

    (29) print -> FMT_LIBRARY DOT PRINTF LPAREN value . RPAREN
    (30) print -> FMT_LIBRARY DOT PRINTF LPAREN value . COMMA RPAREN
    (31) print -> FMT_LIBRARY DOT PRINTF LPAREN value . COMMA data RPAREN

    RPAREN          shift and go to state 176
    COMMA           shift and go to state 177


state 162

    (37) print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .

    FMT_LIBRARY     reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FUNC            reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    INPUT           reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    VAR             reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    CONST           reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    IF              reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FOR             reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    STRING          reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    INTEGER         reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FLOAT32         reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FLOAT64         reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    BOOLEAN         reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    BREAK           reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    $end            reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    RKEY            reduce using rule 37 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)


state 163

    (88) parameter -> IDENTIFIER data_type .

    RPAREN          reduce using rule 88 (parameter -> IDENTIFIER data_type .)
    COMMA           reduce using rule 88 (parameter -> IDENTIFIER data_type .)


state 164

    (84) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN . LKEY program RKEY

    LKEY            shift and go to state 178


state 165

    (87) parameters -> parameters COMMA . parameter
    (88) parameter -> . IDENTIFIER data_type

    IDENTIFIER      shift and go to state 134

    parameter                      shift and go to state 179

state 166

    (90) values -> values COMMA value .

    RPAREN          reduce using rule 90 (values -> values COMMA value .)
    COMMA           reduce using rule 90 (values -> values COMMA value .)


state 167

    (71) identifiers -> identifiers COMMA identifiers .
    (71) identifiers -> identifiers . COMMA identifiers

  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 71 (identifiers -> identifiers COMMA identifiers .)
    COMMA           shift and go to state 141

  ! COMMA           [ reduce using rule 71 (identifiers -> identifiers COMMA identifiers .) ]


state 168

    (38) assignment -> VAR IDENTIFIER data_type EQUAL usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

    FMT_LIBRARY     reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    FUNC            reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    IDENTIFIER      reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    INPUT           reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    VAR             reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    CONST           reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    IF              reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    FOR             reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    STRING          reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    INTEGER         reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    FLOAT32         reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    FLOAT64         reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    BOOLEAN         reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    BREAK           reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    $end            reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    RKEY            reduce using rule 38 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67


state 169

    (39) assignment -> CONST IDENTIFIER data_type EQUAL usable_value .
    (56) arithmetic_operation -> usable_value . PLUS usable_value
    (57) arithmetic_operation -> usable_value . MINUS usable_value
    (58) arithmetic_operation -> usable_value . DIVIDE usable_value
    (59) arithmetic_operation -> usable_value . TIMES usable_value
    (60) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> usable_value . MODULE usable_value
    (62) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (63) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (64) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (65) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (66) comparation_operation -> usable_value . LESS usable_value
    (67) comparation_operation -> usable_value . GREATER usable_value
    (68) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (69) comparation_operation -> usable_value . LOGICAL_OR usable_value

    FMT_LIBRARY     reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    FUNC            reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    IDENTIFIER      reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    INPUT           reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    VAR             reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    CONST           reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    IF              reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    FOR             reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    STRING          reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    INTEGER         reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    FLOAT32         reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    FLOAT64         reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    BOOLEAN         reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    BREAK           reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    $end            reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    RKEY            reduce using rule 39 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    ENTERE_DIVIDE   shift and go to state 58
    MODULE          shift and go to state 59
    EQUALEQUAL      shift and go to state 60
    NOT_EQUAL       shift and go to state 61
    LESS_EQUAL      shift and go to state 62
    GREATER_EQUAL   shift and go to state 63
    LESS            shift and go to state 64
    GREATER         shift and go to state 65
    LOGICAL_AND     shift and go to state 66
    LOGICAL_OR      shift and go to state 67


state 170

    (24) if_statement -> IF rule_comparation LKEY program RKEY .
    (25) if_statement -> IF rule_comparation LKEY program RKEY . ELSE LKEY program RKEY

    FMT_LIBRARY     reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    FUNC            reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    IDENTIFIER      reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    INPUT           reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    VAR             reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    CONST           reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    IF              reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    FOR             reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    STRING          reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    INTEGER         reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    FLOAT32         reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    FLOAT64         reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    BOOLEAN         reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    BREAK           reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    $end            reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    RKEY            reduce using rule 24 (if_statement -> IF rule_comparation LKEY program RKEY .)
    ELSE            shift and go to state 180


state 171

    (26) if_statement -> IF value LKEY program RKEY .
    (27) if_statement -> IF value LKEY program RKEY . ELSE LKEY program RKEY

    FMT_LIBRARY     reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    FUNC            reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    IDENTIFIER      reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    INPUT           reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    VAR             reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    CONST           reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    IF              reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    FOR             reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    STRING          reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    INTEGER         reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    FLOAT32         reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    FLOAT64         reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    BOOLEAN         reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    BREAK           reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    $end            reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    RKEY            reduce using rule 26 (if_statement -> IF value LKEY program RKEY .)
    ELSE            shift and go to state 181


state 172

    (22) for -> FOR comparation_operation LKEY loop_program RKEY .

    FMT_LIBRARY     reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FUNC            reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    IDENTIFIER      reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    INPUT           reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    VAR             reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    CONST           reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    IF              reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FOR             reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    STRING          reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    INTEGER         reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FLOAT32         reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FLOAT64         reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    BOOLEAN         reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    BREAK           reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    $end            reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    RKEY            reduce using rule 22 (for -> FOR comparation_operation LKEY loop_program RKEY .)


state 173

    (85) call_function -> IDENTIFIER LPAREN values RPAREN .

    EQUALEQUAL      reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    NOT_EQUAL       reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS_EQUAL      reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER_EQUAL   reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS            reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER         reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_AND     reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_OR      reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    PLUS            reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MINUS           reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    DIVIDE          reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    TIMES           reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    ENTERE_DIVIDE   reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MODULE          reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FMT_LIBRARY     reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FUNC            reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    INPUT           reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    STRING          reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER         reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FLOAT32         reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FLOAT64         reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN         reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    BREAK           reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    $end            reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    RKEY            reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LKEY            reduce using rule 85 (call_function -> IDENTIFIER LPAREN values RPAREN .)


state 174

    (28) print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .

    FMT_LIBRARY     reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FUNC            reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    IDENTIFIER      reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    INPUT           reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    VAR             reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    CONST           reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    IF              reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FOR             reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    STRING          reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    INTEGER         reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FLOAT32         reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FLOAT64         reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    BOOLEAN         reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    BREAK           reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    $end            reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    RKEY            reduce using rule 28 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)


state 175

    (34) data -> data COMMA . value
    (35) data -> data COMMA . IDENTIFIER
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    IDENTIFIER      shift and go to state 183
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 182

state 176

    (29) print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .

    FMT_LIBRARY     reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    FUNC            reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    IDENTIFIER      reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    INPUT           reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    VAR             reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    CONST           reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    IF              reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    FOR             reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    STRING          reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    INTEGER         reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    FLOAT32         reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    FLOAT64         reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    BOOLEAN         reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    BREAK           reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    $end            reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    RKEY            reduce using rule 29 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)


state 177

    (30) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA . RPAREN
    (31) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA . data RPAREN
    (32) data -> . value
    (33) data -> . IDENTIFIER
    (34) data -> . data COMMA value
    (35) data -> . data COMMA IDENTIFIER
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN

    RPAREN          shift and go to state 184
    IDENTIFIER      shift and go to state 160
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 159
    data                           shift and go to state 185

state 178

    (84) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY . program RKEY
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    program                        shift and go to state 186
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 179

    (87) parameters -> parameters COMMA parameter .

    RPAREN          reduce using rule 87 (parameters -> parameters COMMA parameter .)
    COMMA           reduce using rule 87 (parameters -> parameters COMMA parameter .)


state 180

    (25) if_statement -> IF rule_comparation LKEY program RKEY ELSE . LKEY program RKEY

    LKEY            shift and go to state 187


state 181

    (27) if_statement -> IF value LKEY program RKEY ELSE . LKEY program RKEY

    LKEY            shift and go to state 188


state 182

    (34) data -> data COMMA value .

    RPAREN          reduce using rule 34 (data -> data COMMA value .)
    COMMA           reduce using rule 34 (data -> data COMMA value .)


state 183

    (35) data -> data COMMA IDENTIFIER .

    RPAREN          reduce using rule 35 (data -> data COMMA IDENTIFIER .)
    COMMA           reduce using rule 35 (data -> data COMMA IDENTIFIER .)


state 184

    (30) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .

    FMT_LIBRARY     reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    FUNC            reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    IDENTIFIER      reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    INPUT           reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    VAR             reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    CONST           reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    IF              reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    FOR             reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    STRING          reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    INTEGER         reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    FLOAT32         reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    FLOAT64         reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    BOOLEAN         reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    BREAK           reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    $end            reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    RKEY            reduce using rule 30 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)


state 185

    (31) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data . RPAREN
    (34) data -> data . COMMA value
    (35) data -> data . COMMA IDENTIFIER

    RPAREN          shift and go to state 189
    COMMA           shift and go to state 175


state 186

    (84) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program . RKEY
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 190
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    sentencia                      shift and go to state 36
    loop                           shift and go to state 37
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 187

    (25) if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY . program RKEY
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    program                        shift and go to state 191
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 188

    (27) if_statement -> IF value LKEY program RKEY ELSE LKEY . program RKEY
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 19
    program                        shift and go to state 192
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 189

    (31) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .

    FMT_LIBRARY     reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    FUNC            reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    IDENTIFIER      reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    INPUT           reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    VAR             reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    CONST           reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    IF              reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    FOR             reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    STRING          reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    INTEGER         reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    FLOAT32         reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    FLOAT64         reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    BOOLEAN         reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    BREAK           reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    $end            reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    RKEY            reduce using rule 31 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)


state 190

    (84) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .

    FMT_LIBRARY     reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    FUNC            reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    IDENTIFIER      reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    INPUT           reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    VAR             reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    CONST           reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    IF              reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    FOR             reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    STRING          reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    INTEGER         reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    FLOAT32         reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    FLOAT64         reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    BOOLEAN         reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    BREAK           reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    $end            reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    RKEY            reduce using rule 84 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)


state 191

    (25) if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program . RKEY
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 193
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    sentencia                      shift and go to state 36
    loop                           shift and go to state 37
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    value                          shift and go to state 19
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 192

    (27) if_statement -> IF value LKEY program RKEY ELSE LKEY program . RKEY
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (9) loop -> . for
    (28) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (29) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (30) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (31) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (36) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (37) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (84) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (85) call_function -> . IDENTIFIER LPAREN values RPAREN
    (101) input -> . INPUT LPAREN RPAREN
    (102) input -> . INPUT LPAREN value RPAREN
    (103) input -> . INPUT LPAREN identifiers RPAREN
    (38) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (39) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (40) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (56) arithmetic_operation -> . usable_value PLUS usable_value
    (57) arithmetic_operation -> . usable_value MINUS usable_value
    (58) arithmetic_operation -> . usable_value DIVIDE usable_value
    (59) arithmetic_operation -> . usable_value TIMES usable_value
    (60) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (61) arithmetic_operation -> . usable_value MODULE usable_value
    (46) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (47) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (48) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (49) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (50) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (51) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (52) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (53) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (54) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (55) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (24) if_statement -> . IF rule_comparation LKEY program RKEY
    (25) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (26) if_statement -> . IF value LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (23) function_call -> . IDENTIFIER LPAREN values RPAREN
    (21) for -> . FOR LKEY loop_program RKEY
    (22) for -> . FOR comparation_operation LKEY loop_program RKEY
    (41) usable_value -> . value
    (42) usable_value -> . call_function
    (43) usable_value -> . IDENTIFIER
    (44) usable_value -> . arithmetic_operation
    (45) usable_value -> . comparation_operation
    (91) value -> . STRING
    (92) value -> . INTEGER
    (93) value -> . FLOAT32
    (94) value -> . FLOAT64
    (95) value -> . BOOLEAN
    (62) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (63) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (64) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (65) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (66) comparation_operation -> . usable_value LESS usable_value
    (67) comparation_operation -> . usable_value GREATER usable_value
    (68) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (69) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 194
    FMT_LIBRARY     shift and go to state 18
    FUNC            shift and go to state 20
    IDENTIFIER      shift and go to state 21
    INPUT           shift and go to state 22
    VAR             shift and go to state 23
    CONST           shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    STRING          shift and go to state 29
    INTEGER         shift and go to state 30
    FLOAT32         shift and go to state 31
    FLOAT64         shift and go to state 32
    BOOLEAN         shift and go to state 33

    value                          shift and go to state 19
    sentencia                      shift and go to state 36
    loop                           shift and go to state 37
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    for                            shift and go to state 17
    usable_value                   shift and go to state 24
    comparation_operation          shift and go to state 28

state 193

    (25) if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .

    FMT_LIBRARY     reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    FUNC            reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    IDENTIFIER      reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    INPUT           reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    VAR             reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    CONST           reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    IF              reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    FOR             reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    STRING          reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    INTEGER         reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    FLOAT32         reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    FLOAT64         reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    BOOLEAN         reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    BREAK           reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    $end            reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    RKEY            reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)


state 194

    (27) if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .

    FMT_LIBRARY     reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    FUNC            reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    IDENTIFIER      reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    INPUT           reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    VAR             reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    CONST           reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    IF              reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    FOR             reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    STRING          reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    INTEGER         reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    FLOAT32         reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    FLOAT64         reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    BOOLEAN         reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    BREAK           reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    $end            reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    RKEY            reduce using rule 27 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FMT_LIBRARY in state 2 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 2 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 2 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 2 resolved as shift
WARNING: shift/reduce conflict for VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for CONST in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for STRING in state 2 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT32 in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT64 in state 2 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 2 resolved as shift
WARNING: shift/reduce conflict for FMT_LIBRARY in state 34 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 34 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 34 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 34 resolved as shift
WARNING: shift/reduce conflict for VAR in state 34 resolved as shift
WARNING: shift/reduce conflict for CONST in state 34 resolved as shift
WARNING: shift/reduce conflict for IF in state 34 resolved as shift
WARNING: shift/reduce conflict for FOR in state 34 resolved as shift
WARNING: shift/reduce conflict for STRING in state 34 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 34 resolved as shift
WARNING: shift/reduce conflict for FLOAT32 in state 34 resolved as shift
WARNING: shift/reduce conflict for FLOAT64 in state 34 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 34 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 104 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 104 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 104 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 104 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 104 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 104 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 104 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 104 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 104 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 104 resolved as shift
WARNING: shift/reduce conflict for LESS in state 104 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 104 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 104 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 104 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 105 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for LESS in state 105 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 105 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 105 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 106 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 106 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 106 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 107 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 107 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 107 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 107 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 107 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 107 resolved as shift
WARNING: shift/reduce conflict for LESS in state 107 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 107 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 107 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 107 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 108 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 108 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 108 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 108 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 108 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 108 resolved as shift
WARNING: shift/reduce conflict for LESS in state 108 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 109 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 110 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 110 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for LESS in state 110 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 110 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 110 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 111 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 111 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 111 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 111 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 111 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 111 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for LESS in state 111 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 111 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 111 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 111 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 112 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 112 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 112 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for LESS in state 112 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 112 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 112 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 112 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 113 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 113 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for LESS in state 113 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 113 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 113 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 114 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 114 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for LESS in state 114 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 114 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 114 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 114 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 115 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 115 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for LESS in state 115 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 115 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 115 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 115 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 116 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 116 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for LESS in state 116 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 116 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 116 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 117 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 117 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 117 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 117 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 117 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 117 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 167 resolved as shift
WARNING: reduce/reduce conflict in state 137 resolved using rule (function_call -> IDENTIFIER LPAREN values RPAREN)
WARNING: rejected rule (call_function -> IDENTIFIER LPAREN values RPAREN) in state 137
