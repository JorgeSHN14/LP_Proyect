Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AND
    ARROW_FUNCTION_TYPE
    ARROW_SEND_RECEIVE
    AS
    ASSERT
    BITWISE_XOR
    BITWISE_XOR_ASSIGN
    CLASS
    COMMENT
    COMMENT_MULTI
    CONTINUE
    DEL
    ELIF
    ELLIPSIS
    EXCEPT
    FALSE
    FAT_ARROW
    FINALLY
    FROM
    GLOBAL
    GREATER_THAN
    HEX_NUMBER
    IMPORT
    IN
    IS
    LAMBDA
    LBRACKET
    LESS_THAN
    NONE
    NONLOCAL
    NOT
    NULL
    OR
    PASS
    PIPE
    RAISE
    RBRACKET
    RETURN
    RULE_COMPARATION
    SCIENTIFIC_NOTATION
    TRUE
    TRY
    WITH
    YIELD

Grammar

Rule 0     S' -> loop_program
Rule 1     loop_program -> program
Rule 2     loop_program -> BREAK
Rule 3     loop_program -> loop_program program
Rule 4     loop_program -> loop_program BREAK
Rule 5     program -> sentencia
Rule 6     program -> loop
Rule 7     program -> program sentencia
Rule 8     program -> program loop
Rule 9     loop -> for
Rule 10    sentencia -> print
Rule 11    sentencia -> print_withoutvalue
Rule 12    sentencia -> def_function
Rule 13    sentencia -> call_function
Rule 14    sentencia -> input
Rule 15    sentencia -> assignment
Rule 16    sentencia -> short_assignment
Rule 17    sentencia -> arithmetic_operation
Rule 18    sentencia -> direct_arithmetic_operation
Rule 19    sentencia -> if_statement
Rule 20    sentencia -> function_call
Rule 21    sentencia -> switch_statement
Rule 22    for -> FOR LKEY loop_program RKEY
Rule 23    for -> FOR comparation_operation LKEY loop_program RKEY
Rule 24    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 25    if_statement -> IF rule_comparation LKEY program RKEY
Rule 26    if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
Rule 27    if_statement -> IF value LKEY program RKEY
Rule 28    if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY
Rule 29    switch_statement -> SWITCH expression LKEY case_clauses RKEY
Rule 30    switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
Rule 31    case_clauses -> case_clause case_clauses
Rule 32    case_clauses -> <empty>
Rule 33    case_clause -> CASE value COLON statements
Rule 34    statements -> statement statements
Rule 35    statements -> <empty>
Rule 36    statement -> print
Rule 37    statement -> print_withoutvalue
Rule 38    statement -> def_function
Rule 39    statement -> call_function
Rule 40    statement -> input
Rule 41    statement -> assignment
Rule 42    statement -> short_assignment
Rule 43    statement -> arithmetic_operation
Rule 44    statement -> direct_arithmetic_operation
Rule 45    statement -> if_statement
Rule 46    statement -> function_call
Rule 47    statement -> switch_statement
Rule 48    statement -> statement
Rule 49    expression -> value
Rule 50    expression -> expression PLUS expression
Rule 51    expression -> expression MINUS expression
Rule 52    expression -> expression TIMES expression
Rule 53    expression -> expression DIVIDE expression
Rule 54    expression -> expression ENTERE_DIVIDE expression
Rule 55    expression -> expression MODULE expression
Rule 56    expression -> expression EQUALEQUAL expression
Rule 57    expression -> expression NOT_EQUAL expression
Rule 58    expression -> expression LESS_EQUAL expression
Rule 59    expression -> expression GREATER_EQUAL expression
Rule 60    expression -> expression LESS expression
Rule 61    expression -> expression GREATER expression
Rule 62    expression -> expression LOGICAL_AND expression
Rule 63    expression -> expression LOGICAL_OR expression
Rule 64    print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
Rule 65    print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
Rule 66    print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
Rule 67    print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
Rule 68    data -> value
Rule 69    data -> IDENTIFIER
Rule 70    data -> data COMMA value
Rule 71    data -> data COMMA IDENTIFIER
Rule 72    print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
Rule 73    print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN
Rule 74    assignment -> VAR IDENTIFIER data_type EQUAL usable_value
Rule 75    assignment -> CONST IDENTIFIER data_type EQUAL usable_value
Rule 76    short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value
Rule 77    usable_value -> value
Rule 78    usable_value -> call_function
Rule 79    usable_value -> IDENTIFIER
Rule 80    usable_value -> arithmetic_operation
Rule 81    usable_value -> comparation_operation
Rule 82    direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value
Rule 83    direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value
Rule 84    direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value
Rule 85    direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value
Rule 86    direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value
Rule 87    direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value
Rule 88    direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value
Rule 89    direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value
Rule 90    direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value
Rule 91    direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value
Rule 92    arithmetic_operation -> usable_value PLUS usable_value
Rule 93    arithmetic_operation -> usable_value MINUS usable_value
Rule 94    arithmetic_operation -> usable_value DIVIDE usable_value
Rule 95    arithmetic_operation -> usable_value TIMES usable_value
Rule 96    arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value
Rule 97    arithmetic_operation -> usable_value MODULE usable_value
Rule 98    comparation_operation -> usable_value EQUALEQUAL usable_value
Rule 99    comparation_operation -> usable_value NOT_EQUAL usable_value
Rule 100   comparation_operation -> usable_value LESS_EQUAL usable_value
Rule 101   comparation_operation -> usable_value GREATER_EQUAL usable_value
Rule 102   comparation_operation -> usable_value LESS usable_value
Rule 103   comparation_operation -> usable_value GREATER usable_value
Rule 104   comparation_operation -> usable_value LOGICAL_AND usable_value
Rule 105   comparation_operation -> usable_value LOGICAL_OR usable_value
Rule 106   identifiers -> IDENTIFIER
Rule 107   identifiers -> identifiers COMMA identifiers
Rule 108   rule_comparation -> IDENTIFIER EQUALEQUAL value
Rule 109   rule_comparation -> IDENTIFIER NOT_EQUAL value
Rule 110   rule_comparation -> IDENTIFIER LESS_EQUAL value
Rule 111   rule_comparation -> IDENTIFIER GREATER_EQUAL value
Rule 112   rule_comparation -> IDENTIFIER LESS value
Rule 113   rule_comparation -> IDENTIFIER GREATER value
Rule 114   rule_comparation -> IDENTIFIER LOGICAL_AND value
Rule 115   rule_comparation -> IDENTIFIER LOGICAL_OR value
Rule 116   condition -> value comparation_operation value
Rule 117   condition -> condition LOGICAL_AND condition
Rule 118   condition -> condition LOGICAL_OR condition
Rule 119   condition -> LOGICAL_NOT condition
Rule 120   def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
Rule 121   call_function -> IDENTIFIER LPAREN values RPAREN
Rule 122   parameters -> parameter
Rule 123   parameters -> parameters COMMA parameter
Rule 124   parameter -> IDENTIFIER data_type
Rule 125   values -> value
Rule 126   values -> values COMMA value
Rule 127   value -> STRING
Rule 128   value -> INTEGER
Rule 129   value -> FLOAT32
Rule 130   value -> FLOAT64
Rule 131   value -> BOOLEAN
Rule 132   value -> IDENTIFIER
Rule 133   data_type -> INTEGER_DATA_TYPE
Rule 134   data_type -> FLOAT32_DATA_TYPE
Rule 135   data_type -> FLOAT64_DATA_TYPE
Rule 136   data_type -> BOOLEAN_DATA_TYPE
Rule 137   data_type -> STRING_DATA_TYPE
Rule 138   input -> INPUT LPAREN RPAREN
Rule 139   input -> INPUT LPAREN value RPAREN
Rule 140   input -> INPUT LPAREN identifiers RPAREN

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 
ARROW_FUNCTION_TYPE  : 
ARROW_SEND_RECEIVE   : 
AS                   : 
ASSERT               : 
BITWISE_AND_EQ       : 87
BITWISE_OR_EQ        : 88
BITWISE_XOR          : 
BITWISE_XOR_ASSIGN   : 
BITWISE_XOR_EQ       : 89
BOOLEAN              : 131
BOOLEAN_DATA_TYPE    : 136
BREAK                : 2 4
CASE                 : 33
CLASS                : 
COLON                : 30 33
COMMA                : 66 67 70 71 107 123 126
COMMENT              : 
COMMENT_MULTI        : 
CONST                : 75
CONTINUE             : 
DEFAULT              : 30
DEL                  : 
DIVIDE               : 53 94
DIVIDE_EQ            : 85
DOT                  : 64 65 66 67 72 73
ELIF                 : 
ELLIPSIS             : 
ELSE                 : 26 28
ENTERE_DIVIDE        : 54 96
EQUAL                : 74 75
EQUALEQUAL           : 56 98 108
EXCEPT               : 
FALSE                : 
FAT_ARROW            : 
FINALLY              : 
FLOAT32              : 129
FLOAT32_DATA_TYPE    : 134
FLOAT64              : 130
FLOAT64_DATA_TYPE    : 135
FMT_LIBRARY          : 64 65 66 67 72 73
FOR                  : 22 23
FROM                 : 
FUNC                 : 120
GLOBAL               : 
GREATER              : 61 103 113
GREATER_EQUAL        : 59 101 111
GREATER_THAN         : 
HEX_NUMBER           : 
IDENTIFIER           : 24 69 71 74 75 76 79 82 83 84 85 86 87 88 89 90 91 106 108 109 110 111 112 113 114 115 120 121 124 132
IF                   : 25 26 27 28
IMPORT               : 
IN                   : 
INPUT                : 138 139 140
INTEGER              : 128
INTEGER_DATA_TYPE    : 133
IS                   : 
LAMBDA               : 
LBRACKET             : 
LEFT_SHIFT_EQ        : 90
LESS                 : 60 102 112
LESS_EQUAL           : 58 100 110
LESS_THAN            : 
LKEY                 : 22 23 25 26 26 27 28 28 29 30 120
LOGICAL_AND          : 62 104 114 117
LOGICAL_NOT          : 119
LOGICAL_OR           : 63 105 115 118
LPAREN               : 24 64 65 66 67 72 73 120 121 138 139 140
MINUS                : 51 93
MINUS_EQ             : 83
MODULE               : 55 97
MODULO_EQ            : 86
NONE                 : 
NONLOCAL             : 
NOT                  : 
NOT_EQUAL            : 57 99 109
NULL                 : 
OR                   : 
PASS                 : 
PIPE                 : 
PLUS                 : 50 92
PLUS_EQ              : 82
PRINTF               : 65 66 67 73
PRINTLN              : 64 72
RAISE                : 
RBRACKET             : 
RETURN               : 
RIGHT_SHIFT_EQ       : 91
RKEY                 : 22 23 25 26 26 27 28 28 29 30 120
RPAREN               : 24 64 65 66 67 72 73 120 121 138 139 140
RULE_COMPARATION     : 
SCIENTIFIC_NOTATION  : 
SHORT_VAR_DECL       : 76
STRING               : 127
STRING_DATA_TYPE     : 137
SWITCH               : 29 30
TIMES                : 52 95
TIMES_EQ             : 84
TRUE                 : 
TRY                  : 
VAR                  : 74
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arithmetic_operation : 17 43 80
assignment           : 15 41
call_function        : 13 39 78
case_clause          : 31
case_clauses         : 29 30 31
comparation_operation : 23 81 116
condition            : 117 117 118 118 119
data                 : 64 67 70 71
data_type            : 74 75 124
def_function         : 12 38
direct_arithmetic_operation : 18 44
expression           : 29 30 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63
for                  : 9
function_call        : 20 46
identifiers          : 107 107 140
if_statement         : 19 45
input                : 14 40
loop                 : 6 8
loop_program         : 3 4 22 23 0
parameter            : 122 123
parameters           : 120 123
print                : 10 36
print_withoutvalue   : 11 37
program              : 1 3 7 8 25 26 26 27 28 28 120
rule_comparation     : 25 26
sentencia            : 5 7
short_assignment     : 16 42
statement            : 34 48
statements           : 30 33 34
switch_statement     : 21 47
usable_value         : 74 75 76 92 92 93 93 94 94 95 95 96 96 97 97 98 98 99 99 100 100 101 101 102 102 103 103 104 104 105 105
value                : 27 28 33 49 65 66 67 68 70 77 82 83 84 85 86 87 88 89 90 91 108 109 110 111 112 113 114 115 116 116 125 126 139
values               : 24 121 126

Parsing method: LALR

state 0

    (0) S' -> . loop_program
    (1) loop_program -> . program
    (2) loop_program -> . BREAK
    (3) loop_program -> . loop_program program
    (4) loop_program -> . loop_program BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 3
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    loop_program                   shift and go to state 1
    program                        shift and go to state 2
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 1

    (0) S' -> loop_program .
    (3) loop_program -> loop_program . program
    (4) loop_program -> loop_program . BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 37
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    program                        shift and go to state 36
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 2

    (1) loop_program -> program .
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! shift/reduce conflict for FMT_LIBRARY resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT32 resolved as shift
  ! shift/reduce conflict for FLOAT64 resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    BREAK           reduce using rule 1 (loop_program -> program .)
    $end            reduce using rule 1 (loop_program -> program .)
    RKEY            reduce using rule 1 (loop_program -> program .)
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

  ! FMT_LIBRARY     [ reduce using rule 1 (loop_program -> program .) ]
  ! FUNC            [ reduce using rule 1 (loop_program -> program .) ]
  ! IDENTIFIER      [ reduce using rule 1 (loop_program -> program .) ]
  ! INPUT           [ reduce using rule 1 (loop_program -> program .) ]
  ! VAR             [ reduce using rule 1 (loop_program -> program .) ]
  ! CONST           [ reduce using rule 1 (loop_program -> program .) ]
  ! IF              [ reduce using rule 1 (loop_program -> program .) ]
  ! SWITCH          [ reduce using rule 1 (loop_program -> program .) ]
  ! FOR             [ reduce using rule 1 (loop_program -> program .) ]
  ! STRING          [ reduce using rule 1 (loop_program -> program .) ]
  ! INTEGER         [ reduce using rule 1 (loop_program -> program .) ]
  ! FLOAT32         [ reduce using rule 1 (loop_program -> program .) ]
  ! FLOAT64         [ reduce using rule 1 (loop_program -> program .) ]
  ! BOOLEAN         [ reduce using rule 1 (loop_program -> program .) ]

    sentencia                      shift and go to state 38
    loop                           shift and go to state 39
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 3

    (2) loop_program -> BREAK .

    BREAK           reduce using rule 2 (loop_program -> BREAK .)
    FMT_LIBRARY     reduce using rule 2 (loop_program -> BREAK .)
    FUNC            reduce using rule 2 (loop_program -> BREAK .)
    IDENTIFIER      reduce using rule 2 (loop_program -> BREAK .)
    INPUT           reduce using rule 2 (loop_program -> BREAK .)
    VAR             reduce using rule 2 (loop_program -> BREAK .)
    CONST           reduce using rule 2 (loop_program -> BREAK .)
    IF              reduce using rule 2 (loop_program -> BREAK .)
    SWITCH          reduce using rule 2 (loop_program -> BREAK .)
    FOR             reduce using rule 2 (loop_program -> BREAK .)
    STRING          reduce using rule 2 (loop_program -> BREAK .)
    INTEGER         reduce using rule 2 (loop_program -> BREAK .)
    FLOAT32         reduce using rule 2 (loop_program -> BREAK .)
    FLOAT64         reduce using rule 2 (loop_program -> BREAK .)
    BOOLEAN         reduce using rule 2 (loop_program -> BREAK .)
    $end            reduce using rule 2 (loop_program -> BREAK .)
    RKEY            reduce using rule 2 (loop_program -> BREAK .)


state 4

    (5) program -> sentencia .

    FMT_LIBRARY     reduce using rule 5 (program -> sentencia .)
    FUNC            reduce using rule 5 (program -> sentencia .)
    IDENTIFIER      reduce using rule 5 (program -> sentencia .)
    INPUT           reduce using rule 5 (program -> sentencia .)
    VAR             reduce using rule 5 (program -> sentencia .)
    CONST           reduce using rule 5 (program -> sentencia .)
    IF              reduce using rule 5 (program -> sentencia .)
    SWITCH          reduce using rule 5 (program -> sentencia .)
    FOR             reduce using rule 5 (program -> sentencia .)
    STRING          reduce using rule 5 (program -> sentencia .)
    INTEGER         reduce using rule 5 (program -> sentencia .)
    FLOAT32         reduce using rule 5 (program -> sentencia .)
    FLOAT64         reduce using rule 5 (program -> sentencia .)
    BOOLEAN         reduce using rule 5 (program -> sentencia .)
    BREAK           reduce using rule 5 (program -> sentencia .)
    $end            reduce using rule 5 (program -> sentencia .)
    RKEY            reduce using rule 5 (program -> sentencia .)


state 5

    (6) program -> loop .

    FMT_LIBRARY     reduce using rule 6 (program -> loop .)
    FUNC            reduce using rule 6 (program -> loop .)
    IDENTIFIER      reduce using rule 6 (program -> loop .)
    INPUT           reduce using rule 6 (program -> loop .)
    VAR             reduce using rule 6 (program -> loop .)
    CONST           reduce using rule 6 (program -> loop .)
    IF              reduce using rule 6 (program -> loop .)
    SWITCH          reduce using rule 6 (program -> loop .)
    FOR             reduce using rule 6 (program -> loop .)
    STRING          reduce using rule 6 (program -> loop .)
    INTEGER         reduce using rule 6 (program -> loop .)
    FLOAT32         reduce using rule 6 (program -> loop .)
    FLOAT64         reduce using rule 6 (program -> loop .)
    BOOLEAN         reduce using rule 6 (program -> loop .)
    BREAK           reduce using rule 6 (program -> loop .)
    $end            reduce using rule 6 (program -> loop .)
    RKEY            reduce using rule 6 (program -> loop .)


state 6

    (10) sentencia -> print .

    FMT_LIBRARY     reduce using rule 10 (sentencia -> print .)
    FUNC            reduce using rule 10 (sentencia -> print .)
    IDENTIFIER      reduce using rule 10 (sentencia -> print .)
    INPUT           reduce using rule 10 (sentencia -> print .)
    VAR             reduce using rule 10 (sentencia -> print .)
    CONST           reduce using rule 10 (sentencia -> print .)
    IF              reduce using rule 10 (sentencia -> print .)
    SWITCH          reduce using rule 10 (sentencia -> print .)
    FOR             reduce using rule 10 (sentencia -> print .)
    STRING          reduce using rule 10 (sentencia -> print .)
    INTEGER         reduce using rule 10 (sentencia -> print .)
    FLOAT32         reduce using rule 10 (sentencia -> print .)
    FLOAT64         reduce using rule 10 (sentencia -> print .)
    BOOLEAN         reduce using rule 10 (sentencia -> print .)
    BREAK           reduce using rule 10 (sentencia -> print .)
    $end            reduce using rule 10 (sentencia -> print .)
    RKEY            reduce using rule 10 (sentencia -> print .)


state 7

    (11) sentencia -> print_withoutvalue .

    FMT_LIBRARY     reduce using rule 11 (sentencia -> print_withoutvalue .)
    FUNC            reduce using rule 11 (sentencia -> print_withoutvalue .)
    IDENTIFIER      reduce using rule 11 (sentencia -> print_withoutvalue .)
    INPUT           reduce using rule 11 (sentencia -> print_withoutvalue .)
    VAR             reduce using rule 11 (sentencia -> print_withoutvalue .)
    CONST           reduce using rule 11 (sentencia -> print_withoutvalue .)
    IF              reduce using rule 11 (sentencia -> print_withoutvalue .)
    SWITCH          reduce using rule 11 (sentencia -> print_withoutvalue .)
    FOR             reduce using rule 11 (sentencia -> print_withoutvalue .)
    STRING          reduce using rule 11 (sentencia -> print_withoutvalue .)
    INTEGER         reduce using rule 11 (sentencia -> print_withoutvalue .)
    FLOAT32         reduce using rule 11 (sentencia -> print_withoutvalue .)
    FLOAT64         reduce using rule 11 (sentencia -> print_withoutvalue .)
    BOOLEAN         reduce using rule 11 (sentencia -> print_withoutvalue .)
    BREAK           reduce using rule 11 (sentencia -> print_withoutvalue .)
    $end            reduce using rule 11 (sentencia -> print_withoutvalue .)
    RKEY            reduce using rule 11 (sentencia -> print_withoutvalue .)


state 8

    (12) sentencia -> def_function .

    FMT_LIBRARY     reduce using rule 12 (sentencia -> def_function .)
    FUNC            reduce using rule 12 (sentencia -> def_function .)
    IDENTIFIER      reduce using rule 12 (sentencia -> def_function .)
    INPUT           reduce using rule 12 (sentencia -> def_function .)
    VAR             reduce using rule 12 (sentencia -> def_function .)
    CONST           reduce using rule 12 (sentencia -> def_function .)
    IF              reduce using rule 12 (sentencia -> def_function .)
    SWITCH          reduce using rule 12 (sentencia -> def_function .)
    FOR             reduce using rule 12 (sentencia -> def_function .)
    STRING          reduce using rule 12 (sentencia -> def_function .)
    INTEGER         reduce using rule 12 (sentencia -> def_function .)
    FLOAT32         reduce using rule 12 (sentencia -> def_function .)
    FLOAT64         reduce using rule 12 (sentencia -> def_function .)
    BOOLEAN         reduce using rule 12 (sentencia -> def_function .)
    BREAK           reduce using rule 12 (sentencia -> def_function .)
    $end            reduce using rule 12 (sentencia -> def_function .)
    RKEY            reduce using rule 12 (sentencia -> def_function .)


state 9

    (13) sentencia -> call_function .
    (78) usable_value -> call_function .

    FMT_LIBRARY     reduce using rule 13 (sentencia -> call_function .)
    FUNC            reduce using rule 13 (sentencia -> call_function .)
    IDENTIFIER      reduce using rule 13 (sentencia -> call_function .)
    INPUT           reduce using rule 13 (sentencia -> call_function .)
    VAR             reduce using rule 13 (sentencia -> call_function .)
    CONST           reduce using rule 13 (sentencia -> call_function .)
    IF              reduce using rule 13 (sentencia -> call_function .)
    SWITCH          reduce using rule 13 (sentencia -> call_function .)
    FOR             reduce using rule 13 (sentencia -> call_function .)
    STRING          reduce using rule 13 (sentencia -> call_function .)
    INTEGER         reduce using rule 13 (sentencia -> call_function .)
    FLOAT32         reduce using rule 13 (sentencia -> call_function .)
    FLOAT64         reduce using rule 13 (sentencia -> call_function .)
    BOOLEAN         reduce using rule 13 (sentencia -> call_function .)
    BREAK           reduce using rule 13 (sentencia -> call_function .)
    $end            reduce using rule 13 (sentencia -> call_function .)
    RKEY            reduce using rule 13 (sentencia -> call_function .)
    PLUS            reduce using rule 78 (usable_value -> call_function .)
    MINUS           reduce using rule 78 (usable_value -> call_function .)
    DIVIDE          reduce using rule 78 (usable_value -> call_function .)
    TIMES           reduce using rule 78 (usable_value -> call_function .)
    ENTERE_DIVIDE   reduce using rule 78 (usable_value -> call_function .)
    MODULE          reduce using rule 78 (usable_value -> call_function .)
    EQUALEQUAL      reduce using rule 78 (usable_value -> call_function .)
    NOT_EQUAL       reduce using rule 78 (usable_value -> call_function .)
    LESS_EQUAL      reduce using rule 78 (usable_value -> call_function .)
    GREATER_EQUAL   reduce using rule 78 (usable_value -> call_function .)
    LESS            reduce using rule 78 (usable_value -> call_function .)
    GREATER         reduce using rule 78 (usable_value -> call_function .)
    LOGICAL_AND     reduce using rule 78 (usable_value -> call_function .)
    LOGICAL_OR      reduce using rule 78 (usable_value -> call_function .)


state 10

    (14) sentencia -> input .

    FMT_LIBRARY     reduce using rule 14 (sentencia -> input .)
    FUNC            reduce using rule 14 (sentencia -> input .)
    IDENTIFIER      reduce using rule 14 (sentencia -> input .)
    INPUT           reduce using rule 14 (sentencia -> input .)
    VAR             reduce using rule 14 (sentencia -> input .)
    CONST           reduce using rule 14 (sentencia -> input .)
    IF              reduce using rule 14 (sentencia -> input .)
    SWITCH          reduce using rule 14 (sentencia -> input .)
    FOR             reduce using rule 14 (sentencia -> input .)
    STRING          reduce using rule 14 (sentencia -> input .)
    INTEGER         reduce using rule 14 (sentencia -> input .)
    FLOAT32         reduce using rule 14 (sentencia -> input .)
    FLOAT64         reduce using rule 14 (sentencia -> input .)
    BOOLEAN         reduce using rule 14 (sentencia -> input .)
    BREAK           reduce using rule 14 (sentencia -> input .)
    $end            reduce using rule 14 (sentencia -> input .)
    RKEY            reduce using rule 14 (sentencia -> input .)


state 11

    (15) sentencia -> assignment .

    FMT_LIBRARY     reduce using rule 15 (sentencia -> assignment .)
    FUNC            reduce using rule 15 (sentencia -> assignment .)
    IDENTIFIER      reduce using rule 15 (sentencia -> assignment .)
    INPUT           reduce using rule 15 (sentencia -> assignment .)
    VAR             reduce using rule 15 (sentencia -> assignment .)
    CONST           reduce using rule 15 (sentencia -> assignment .)
    IF              reduce using rule 15 (sentencia -> assignment .)
    SWITCH          reduce using rule 15 (sentencia -> assignment .)
    FOR             reduce using rule 15 (sentencia -> assignment .)
    STRING          reduce using rule 15 (sentencia -> assignment .)
    INTEGER         reduce using rule 15 (sentencia -> assignment .)
    FLOAT32         reduce using rule 15 (sentencia -> assignment .)
    FLOAT64         reduce using rule 15 (sentencia -> assignment .)
    BOOLEAN         reduce using rule 15 (sentencia -> assignment .)
    BREAK           reduce using rule 15 (sentencia -> assignment .)
    $end            reduce using rule 15 (sentencia -> assignment .)
    RKEY            reduce using rule 15 (sentencia -> assignment .)


state 12

    (16) sentencia -> short_assignment .

    FMT_LIBRARY     reduce using rule 16 (sentencia -> short_assignment .)
    FUNC            reduce using rule 16 (sentencia -> short_assignment .)
    IDENTIFIER      reduce using rule 16 (sentencia -> short_assignment .)
    INPUT           reduce using rule 16 (sentencia -> short_assignment .)
    VAR             reduce using rule 16 (sentencia -> short_assignment .)
    CONST           reduce using rule 16 (sentencia -> short_assignment .)
    IF              reduce using rule 16 (sentencia -> short_assignment .)
    SWITCH          reduce using rule 16 (sentencia -> short_assignment .)
    FOR             reduce using rule 16 (sentencia -> short_assignment .)
    STRING          reduce using rule 16 (sentencia -> short_assignment .)
    INTEGER         reduce using rule 16 (sentencia -> short_assignment .)
    FLOAT32         reduce using rule 16 (sentencia -> short_assignment .)
    FLOAT64         reduce using rule 16 (sentencia -> short_assignment .)
    BOOLEAN         reduce using rule 16 (sentencia -> short_assignment .)
    BREAK           reduce using rule 16 (sentencia -> short_assignment .)
    $end            reduce using rule 16 (sentencia -> short_assignment .)
    RKEY            reduce using rule 16 (sentencia -> short_assignment .)


state 13

    (17) sentencia -> arithmetic_operation .
    (80) usable_value -> arithmetic_operation .

    FMT_LIBRARY     reduce using rule 17 (sentencia -> arithmetic_operation .)
    FUNC            reduce using rule 17 (sentencia -> arithmetic_operation .)
    IDENTIFIER      reduce using rule 17 (sentencia -> arithmetic_operation .)
    INPUT           reduce using rule 17 (sentencia -> arithmetic_operation .)
    VAR             reduce using rule 17 (sentencia -> arithmetic_operation .)
    CONST           reduce using rule 17 (sentencia -> arithmetic_operation .)
    IF              reduce using rule 17 (sentencia -> arithmetic_operation .)
    SWITCH          reduce using rule 17 (sentencia -> arithmetic_operation .)
    FOR             reduce using rule 17 (sentencia -> arithmetic_operation .)
    STRING          reduce using rule 17 (sentencia -> arithmetic_operation .)
    INTEGER         reduce using rule 17 (sentencia -> arithmetic_operation .)
    FLOAT32         reduce using rule 17 (sentencia -> arithmetic_operation .)
    FLOAT64         reduce using rule 17 (sentencia -> arithmetic_operation .)
    BOOLEAN         reduce using rule 17 (sentencia -> arithmetic_operation .)
    BREAK           reduce using rule 17 (sentencia -> arithmetic_operation .)
    $end            reduce using rule 17 (sentencia -> arithmetic_operation .)
    RKEY            reduce using rule 17 (sentencia -> arithmetic_operation .)
    PLUS            reduce using rule 80 (usable_value -> arithmetic_operation .)
    MINUS           reduce using rule 80 (usable_value -> arithmetic_operation .)
    DIVIDE          reduce using rule 80 (usable_value -> arithmetic_operation .)
    TIMES           reduce using rule 80 (usable_value -> arithmetic_operation .)
    ENTERE_DIVIDE   reduce using rule 80 (usable_value -> arithmetic_operation .)
    MODULE          reduce using rule 80 (usable_value -> arithmetic_operation .)
    EQUALEQUAL      reduce using rule 80 (usable_value -> arithmetic_operation .)
    NOT_EQUAL       reduce using rule 80 (usable_value -> arithmetic_operation .)
    LESS_EQUAL      reduce using rule 80 (usable_value -> arithmetic_operation .)
    GREATER_EQUAL   reduce using rule 80 (usable_value -> arithmetic_operation .)
    LESS            reduce using rule 80 (usable_value -> arithmetic_operation .)
    GREATER         reduce using rule 80 (usable_value -> arithmetic_operation .)
    LOGICAL_AND     reduce using rule 80 (usable_value -> arithmetic_operation .)
    LOGICAL_OR      reduce using rule 80 (usable_value -> arithmetic_operation .)


state 14

    (18) sentencia -> direct_arithmetic_operation .

    FMT_LIBRARY     reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    FUNC            reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    IDENTIFIER      reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    INPUT           reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    VAR             reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    CONST           reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    IF              reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    SWITCH          reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    FOR             reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    STRING          reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    INTEGER         reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    FLOAT32         reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    FLOAT64         reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    BOOLEAN         reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    BREAK           reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    $end            reduce using rule 18 (sentencia -> direct_arithmetic_operation .)
    RKEY            reduce using rule 18 (sentencia -> direct_arithmetic_operation .)


state 15

    (19) sentencia -> if_statement .

    FMT_LIBRARY     reduce using rule 19 (sentencia -> if_statement .)
    FUNC            reduce using rule 19 (sentencia -> if_statement .)
    IDENTIFIER      reduce using rule 19 (sentencia -> if_statement .)
    INPUT           reduce using rule 19 (sentencia -> if_statement .)
    VAR             reduce using rule 19 (sentencia -> if_statement .)
    CONST           reduce using rule 19 (sentencia -> if_statement .)
    IF              reduce using rule 19 (sentencia -> if_statement .)
    SWITCH          reduce using rule 19 (sentencia -> if_statement .)
    FOR             reduce using rule 19 (sentencia -> if_statement .)
    STRING          reduce using rule 19 (sentencia -> if_statement .)
    INTEGER         reduce using rule 19 (sentencia -> if_statement .)
    FLOAT32         reduce using rule 19 (sentencia -> if_statement .)
    FLOAT64         reduce using rule 19 (sentencia -> if_statement .)
    BOOLEAN         reduce using rule 19 (sentencia -> if_statement .)
    BREAK           reduce using rule 19 (sentencia -> if_statement .)
    $end            reduce using rule 19 (sentencia -> if_statement .)
    RKEY            reduce using rule 19 (sentencia -> if_statement .)


state 16

    (20) sentencia -> function_call .

    FMT_LIBRARY     reduce using rule 20 (sentencia -> function_call .)
    FUNC            reduce using rule 20 (sentencia -> function_call .)
    IDENTIFIER      reduce using rule 20 (sentencia -> function_call .)
    INPUT           reduce using rule 20 (sentencia -> function_call .)
    VAR             reduce using rule 20 (sentencia -> function_call .)
    CONST           reduce using rule 20 (sentencia -> function_call .)
    IF              reduce using rule 20 (sentencia -> function_call .)
    SWITCH          reduce using rule 20 (sentencia -> function_call .)
    FOR             reduce using rule 20 (sentencia -> function_call .)
    STRING          reduce using rule 20 (sentencia -> function_call .)
    INTEGER         reduce using rule 20 (sentencia -> function_call .)
    FLOAT32         reduce using rule 20 (sentencia -> function_call .)
    FLOAT64         reduce using rule 20 (sentencia -> function_call .)
    BOOLEAN         reduce using rule 20 (sentencia -> function_call .)
    BREAK           reduce using rule 20 (sentencia -> function_call .)
    $end            reduce using rule 20 (sentencia -> function_call .)
    RKEY            reduce using rule 20 (sentencia -> function_call .)


state 17

    (21) sentencia -> switch_statement .

    FMT_LIBRARY     reduce using rule 21 (sentencia -> switch_statement .)
    FUNC            reduce using rule 21 (sentencia -> switch_statement .)
    IDENTIFIER      reduce using rule 21 (sentencia -> switch_statement .)
    INPUT           reduce using rule 21 (sentencia -> switch_statement .)
    VAR             reduce using rule 21 (sentencia -> switch_statement .)
    CONST           reduce using rule 21 (sentencia -> switch_statement .)
    IF              reduce using rule 21 (sentencia -> switch_statement .)
    SWITCH          reduce using rule 21 (sentencia -> switch_statement .)
    FOR             reduce using rule 21 (sentencia -> switch_statement .)
    STRING          reduce using rule 21 (sentencia -> switch_statement .)
    INTEGER         reduce using rule 21 (sentencia -> switch_statement .)
    FLOAT32         reduce using rule 21 (sentencia -> switch_statement .)
    FLOAT64         reduce using rule 21 (sentencia -> switch_statement .)
    BOOLEAN         reduce using rule 21 (sentencia -> switch_statement .)
    BREAK           reduce using rule 21 (sentencia -> switch_statement .)
    $end            reduce using rule 21 (sentencia -> switch_statement .)
    RKEY            reduce using rule 21 (sentencia -> switch_statement .)


state 18

    (9) loop -> for .

    FMT_LIBRARY     reduce using rule 9 (loop -> for .)
    FUNC            reduce using rule 9 (loop -> for .)
    IDENTIFIER      reduce using rule 9 (loop -> for .)
    INPUT           reduce using rule 9 (loop -> for .)
    VAR             reduce using rule 9 (loop -> for .)
    CONST           reduce using rule 9 (loop -> for .)
    IF              reduce using rule 9 (loop -> for .)
    SWITCH          reduce using rule 9 (loop -> for .)
    FOR             reduce using rule 9 (loop -> for .)
    STRING          reduce using rule 9 (loop -> for .)
    INTEGER         reduce using rule 9 (loop -> for .)
    FLOAT32         reduce using rule 9 (loop -> for .)
    FLOAT64         reduce using rule 9 (loop -> for .)
    BOOLEAN         reduce using rule 9 (loop -> for .)
    BREAK           reduce using rule 9 (loop -> for .)
    $end            reduce using rule 9 (loop -> for .)
    RKEY            reduce using rule 9 (loop -> for .)


state 19

    (64) print -> FMT_LIBRARY . DOT PRINTLN LPAREN data RPAREN
    (65) print -> FMT_LIBRARY . DOT PRINTF LPAREN value RPAREN
    (66) print -> FMT_LIBRARY . DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> FMT_LIBRARY . DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> FMT_LIBRARY . DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> FMT_LIBRARY . DOT PRINTF LPAREN RPAREN

    DOT             shift and go to state 40


state 20

    (77) usable_value -> value .

    PLUS            reduce using rule 77 (usable_value -> value .)
    MINUS           reduce using rule 77 (usable_value -> value .)
    DIVIDE          reduce using rule 77 (usable_value -> value .)
    TIMES           reduce using rule 77 (usable_value -> value .)
    ENTERE_DIVIDE   reduce using rule 77 (usable_value -> value .)
    MODULE          reduce using rule 77 (usable_value -> value .)
    EQUALEQUAL      reduce using rule 77 (usable_value -> value .)
    NOT_EQUAL       reduce using rule 77 (usable_value -> value .)
    LESS_EQUAL      reduce using rule 77 (usable_value -> value .)
    GREATER_EQUAL   reduce using rule 77 (usable_value -> value .)
    LESS            reduce using rule 77 (usable_value -> value .)
    GREATER         reduce using rule 77 (usable_value -> value .)
    LOGICAL_AND     reduce using rule 77 (usable_value -> value .)
    LOGICAL_OR      reduce using rule 77 (usable_value -> value .)
    FMT_LIBRARY     reduce using rule 77 (usable_value -> value .)
    FUNC            reduce using rule 77 (usable_value -> value .)
    IDENTIFIER      reduce using rule 77 (usable_value -> value .)
    INPUT           reduce using rule 77 (usable_value -> value .)
    VAR             reduce using rule 77 (usable_value -> value .)
    CONST           reduce using rule 77 (usable_value -> value .)
    IF              reduce using rule 77 (usable_value -> value .)
    SWITCH          reduce using rule 77 (usable_value -> value .)
    FOR             reduce using rule 77 (usable_value -> value .)
    STRING          reduce using rule 77 (usable_value -> value .)
    INTEGER         reduce using rule 77 (usable_value -> value .)
    FLOAT32         reduce using rule 77 (usable_value -> value .)
    FLOAT64         reduce using rule 77 (usable_value -> value .)
    BOOLEAN         reduce using rule 77 (usable_value -> value .)
    BREAK           reduce using rule 77 (usable_value -> value .)
    $end            reduce using rule 77 (usable_value -> value .)
    RKEY            reduce using rule 77 (usable_value -> value .)
    CASE            reduce using rule 77 (usable_value -> value .)
    DEFAULT         reduce using rule 77 (usable_value -> value .)
    LKEY            reduce using rule 77 (usable_value -> value .)


state 21

    (120) def_function -> FUNC . IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY

    IDENTIFIER      shift and go to state 41


state 22

    (121) call_function -> IDENTIFIER . LPAREN values RPAREN
    (76) short_assignment -> IDENTIFIER . SHORT_VAR_DECL usable_value
    (82) direct_arithmetic_operation -> IDENTIFIER . PLUS_EQ value
    (83) direct_arithmetic_operation -> IDENTIFIER . MINUS_EQ value
    (84) direct_arithmetic_operation -> IDENTIFIER . TIMES_EQ value
    (85) direct_arithmetic_operation -> IDENTIFIER . DIVIDE_EQ value
    (86) direct_arithmetic_operation -> IDENTIFIER . MODULO_EQ value
    (87) direct_arithmetic_operation -> IDENTIFIER . BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> IDENTIFIER . BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> IDENTIFIER . BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> IDENTIFIER . LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> IDENTIFIER . RIGHT_SHIFT_EQ value
    (24) function_call -> IDENTIFIER . LPAREN values RPAREN
    (79) usable_value -> IDENTIFIER .
    (132) value -> IDENTIFIER .

  ! reduce/reduce conflict for PLUS resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for ENTERE_DIVIDE resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for MODULE resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 79 (usable_value -> IDENTIFIER .)
    LPAREN          shift and go to state 42
    SHORT_VAR_DECL  shift and go to state 43
    PLUS_EQ         shift and go to state 44
    MINUS_EQ        shift and go to state 45
    TIMES_EQ        shift and go to state 46
    DIVIDE_EQ       shift and go to state 47
    MODULO_EQ       shift and go to state 48
    BITWISE_AND_EQ  shift and go to state 49
    BITWISE_OR_EQ   shift and go to state 50
    BITWISE_XOR_EQ  shift and go to state 51
    LEFT_SHIFT_EQ   shift and go to state 52
    RIGHT_SHIFT_EQ  shift and go to state 53
    PLUS            reduce using rule 79 (usable_value -> IDENTIFIER .)
    MINUS           reduce using rule 79 (usable_value -> IDENTIFIER .)
    DIVIDE          reduce using rule 79 (usable_value -> IDENTIFIER .)
    TIMES           reduce using rule 79 (usable_value -> IDENTIFIER .)
    ENTERE_DIVIDE   reduce using rule 79 (usable_value -> IDENTIFIER .)
    MODULE          reduce using rule 79 (usable_value -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 79 (usable_value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 79 (usable_value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 79 (usable_value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 79 (usable_value -> IDENTIFIER .)
    LESS            reduce using rule 79 (usable_value -> IDENTIFIER .)
    GREATER         reduce using rule 79 (usable_value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 79 (usable_value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 79 (usable_value -> IDENTIFIER .)

  ! PLUS            [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! MODULE          [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! EQUALEQUAL      [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! NOT_EQUAL       [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! LESS_EQUAL      [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! GREATER_EQUAL   [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! LESS            [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! GREATER         [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! LOGICAL_AND     [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! LOGICAL_OR      [ reduce using rule 132 (value -> IDENTIFIER .) ]


state 23

    (138) input -> INPUT . LPAREN RPAREN
    (139) input -> INPUT . LPAREN value RPAREN
    (140) input -> INPUT . LPAREN identifiers RPAREN

    LPAREN          shift and go to state 54


state 24

    (74) assignment -> VAR . IDENTIFIER data_type EQUAL usable_value

    IDENTIFIER      shift and go to state 55


state 25

    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69


state 26

    (75) assignment -> CONST . IDENTIFIER data_type EQUAL usable_value

    IDENTIFIER      shift and go to state 70


state 27

    (25) if_statement -> IF . rule_comparation LKEY program RKEY
    (26) if_statement -> IF . rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> IF . value LKEY program RKEY
    (28) if_statement -> IF . value LKEY program RKEY ELSE LKEY program RKEY
    (108) rule_comparation -> . IDENTIFIER EQUALEQUAL value
    (109) rule_comparation -> . IDENTIFIER NOT_EQUAL value
    (110) rule_comparation -> . IDENTIFIER LESS_EQUAL value
    (111) rule_comparation -> . IDENTIFIER GREATER_EQUAL value
    (112) rule_comparation -> . IDENTIFIER LESS value
    (113) rule_comparation -> . IDENTIFIER GREATER value
    (114) rule_comparation -> . IDENTIFIER LOGICAL_AND value
    (115) rule_comparation -> . IDENTIFIER LOGICAL_OR value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    IDENTIFIER      shift and go to state 73
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    rule_comparation               shift and go to state 71
    value                          shift and go to state 72

state 28

    (29) switch_statement -> SWITCH . expression LKEY case_clauses RKEY
    (30) switch_statement -> SWITCH . expression LKEY case_clauses DEFAULT COLON statements RKEY
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 74
    value                          shift and go to state 75

state 29

    (22) for -> FOR . LKEY loop_program RKEY
    (23) for -> FOR . comparation_operation LKEY loop_program RKEY
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value

    LKEY            shift and go to state 77
    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 78
    usable_value                   shift and go to state 79
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82

state 30

    (81) usable_value -> comparation_operation .

    PLUS            reduce using rule 81 (usable_value -> comparation_operation .)
    MINUS           reduce using rule 81 (usable_value -> comparation_operation .)
    DIVIDE          reduce using rule 81 (usable_value -> comparation_operation .)
    TIMES           reduce using rule 81 (usable_value -> comparation_operation .)
    ENTERE_DIVIDE   reduce using rule 81 (usable_value -> comparation_operation .)
    MODULE          reduce using rule 81 (usable_value -> comparation_operation .)
    EQUALEQUAL      reduce using rule 81 (usable_value -> comparation_operation .)
    NOT_EQUAL       reduce using rule 81 (usable_value -> comparation_operation .)
    LESS_EQUAL      reduce using rule 81 (usable_value -> comparation_operation .)
    GREATER_EQUAL   reduce using rule 81 (usable_value -> comparation_operation .)
    LESS            reduce using rule 81 (usable_value -> comparation_operation .)
    GREATER         reduce using rule 81 (usable_value -> comparation_operation .)
    LOGICAL_AND     reduce using rule 81 (usable_value -> comparation_operation .)
    LOGICAL_OR      reduce using rule 81 (usable_value -> comparation_operation .)
    FMT_LIBRARY     reduce using rule 81 (usable_value -> comparation_operation .)
    FUNC            reduce using rule 81 (usable_value -> comparation_operation .)
    IDENTIFIER      reduce using rule 81 (usable_value -> comparation_operation .)
    INPUT           reduce using rule 81 (usable_value -> comparation_operation .)
    VAR             reduce using rule 81 (usable_value -> comparation_operation .)
    CONST           reduce using rule 81 (usable_value -> comparation_operation .)
    IF              reduce using rule 81 (usable_value -> comparation_operation .)
    SWITCH          reduce using rule 81 (usable_value -> comparation_operation .)
    FOR             reduce using rule 81 (usable_value -> comparation_operation .)
    STRING          reduce using rule 81 (usable_value -> comparation_operation .)
    INTEGER         reduce using rule 81 (usable_value -> comparation_operation .)
    FLOAT32         reduce using rule 81 (usable_value -> comparation_operation .)
    FLOAT64         reduce using rule 81 (usable_value -> comparation_operation .)
    BOOLEAN         reduce using rule 81 (usable_value -> comparation_operation .)
    BREAK           reduce using rule 81 (usable_value -> comparation_operation .)
    $end            reduce using rule 81 (usable_value -> comparation_operation .)
    RKEY            reduce using rule 81 (usable_value -> comparation_operation .)
    CASE            reduce using rule 81 (usable_value -> comparation_operation .)
    DEFAULT         reduce using rule 81 (usable_value -> comparation_operation .)
    LKEY            reduce using rule 81 (usable_value -> comparation_operation .)


state 31

    (127) value -> STRING .

    PLUS            reduce using rule 127 (value -> STRING .)
    MINUS           reduce using rule 127 (value -> STRING .)
    DIVIDE          reduce using rule 127 (value -> STRING .)
    TIMES           reduce using rule 127 (value -> STRING .)
    ENTERE_DIVIDE   reduce using rule 127 (value -> STRING .)
    MODULE          reduce using rule 127 (value -> STRING .)
    EQUALEQUAL      reduce using rule 127 (value -> STRING .)
    NOT_EQUAL       reduce using rule 127 (value -> STRING .)
    LESS_EQUAL      reduce using rule 127 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 127 (value -> STRING .)
    LESS            reduce using rule 127 (value -> STRING .)
    GREATER         reduce using rule 127 (value -> STRING .)
    LOGICAL_AND     reduce using rule 127 (value -> STRING .)
    LOGICAL_OR      reduce using rule 127 (value -> STRING .)
    LKEY            reduce using rule 127 (value -> STRING .)
    RPAREN          reduce using rule 127 (value -> STRING .)
    COMMA           reduce using rule 127 (value -> STRING .)
    FMT_LIBRARY     reduce using rule 127 (value -> STRING .)
    FUNC            reduce using rule 127 (value -> STRING .)
    IDENTIFIER      reduce using rule 127 (value -> STRING .)
    INPUT           reduce using rule 127 (value -> STRING .)
    VAR             reduce using rule 127 (value -> STRING .)
    CONST           reduce using rule 127 (value -> STRING .)
    IF              reduce using rule 127 (value -> STRING .)
    SWITCH          reduce using rule 127 (value -> STRING .)
    FOR             reduce using rule 127 (value -> STRING .)
    STRING          reduce using rule 127 (value -> STRING .)
    INTEGER         reduce using rule 127 (value -> STRING .)
    FLOAT32         reduce using rule 127 (value -> STRING .)
    FLOAT64         reduce using rule 127 (value -> STRING .)
    BOOLEAN         reduce using rule 127 (value -> STRING .)
    BREAK           reduce using rule 127 (value -> STRING .)
    $end            reduce using rule 127 (value -> STRING .)
    RKEY            reduce using rule 127 (value -> STRING .)
    CASE            reduce using rule 127 (value -> STRING .)
    DEFAULT         reduce using rule 127 (value -> STRING .)
    COLON           reduce using rule 127 (value -> STRING .)


state 32

    (128) value -> INTEGER .

    PLUS            reduce using rule 128 (value -> INTEGER .)
    MINUS           reduce using rule 128 (value -> INTEGER .)
    DIVIDE          reduce using rule 128 (value -> INTEGER .)
    TIMES           reduce using rule 128 (value -> INTEGER .)
    ENTERE_DIVIDE   reduce using rule 128 (value -> INTEGER .)
    MODULE          reduce using rule 128 (value -> INTEGER .)
    EQUALEQUAL      reduce using rule 128 (value -> INTEGER .)
    NOT_EQUAL       reduce using rule 128 (value -> INTEGER .)
    LESS_EQUAL      reduce using rule 128 (value -> INTEGER .)
    GREATER_EQUAL   reduce using rule 128 (value -> INTEGER .)
    LESS            reduce using rule 128 (value -> INTEGER .)
    GREATER         reduce using rule 128 (value -> INTEGER .)
    LOGICAL_AND     reduce using rule 128 (value -> INTEGER .)
    LOGICAL_OR      reduce using rule 128 (value -> INTEGER .)
    LKEY            reduce using rule 128 (value -> INTEGER .)
    RPAREN          reduce using rule 128 (value -> INTEGER .)
    COMMA           reduce using rule 128 (value -> INTEGER .)
    FMT_LIBRARY     reduce using rule 128 (value -> INTEGER .)
    FUNC            reduce using rule 128 (value -> INTEGER .)
    IDENTIFIER      reduce using rule 128 (value -> INTEGER .)
    INPUT           reduce using rule 128 (value -> INTEGER .)
    VAR             reduce using rule 128 (value -> INTEGER .)
    CONST           reduce using rule 128 (value -> INTEGER .)
    IF              reduce using rule 128 (value -> INTEGER .)
    SWITCH          reduce using rule 128 (value -> INTEGER .)
    FOR             reduce using rule 128 (value -> INTEGER .)
    STRING          reduce using rule 128 (value -> INTEGER .)
    INTEGER         reduce using rule 128 (value -> INTEGER .)
    FLOAT32         reduce using rule 128 (value -> INTEGER .)
    FLOAT64         reduce using rule 128 (value -> INTEGER .)
    BOOLEAN         reduce using rule 128 (value -> INTEGER .)
    BREAK           reduce using rule 128 (value -> INTEGER .)
    $end            reduce using rule 128 (value -> INTEGER .)
    RKEY            reduce using rule 128 (value -> INTEGER .)
    CASE            reduce using rule 128 (value -> INTEGER .)
    DEFAULT         reduce using rule 128 (value -> INTEGER .)
    COLON           reduce using rule 128 (value -> INTEGER .)


state 33

    (129) value -> FLOAT32 .

    PLUS            reduce using rule 129 (value -> FLOAT32 .)
    MINUS           reduce using rule 129 (value -> FLOAT32 .)
    DIVIDE          reduce using rule 129 (value -> FLOAT32 .)
    TIMES           reduce using rule 129 (value -> FLOAT32 .)
    ENTERE_DIVIDE   reduce using rule 129 (value -> FLOAT32 .)
    MODULE          reduce using rule 129 (value -> FLOAT32 .)
    EQUALEQUAL      reduce using rule 129 (value -> FLOAT32 .)
    NOT_EQUAL       reduce using rule 129 (value -> FLOAT32 .)
    LESS_EQUAL      reduce using rule 129 (value -> FLOAT32 .)
    GREATER_EQUAL   reduce using rule 129 (value -> FLOAT32 .)
    LESS            reduce using rule 129 (value -> FLOAT32 .)
    GREATER         reduce using rule 129 (value -> FLOAT32 .)
    LOGICAL_AND     reduce using rule 129 (value -> FLOAT32 .)
    LOGICAL_OR      reduce using rule 129 (value -> FLOAT32 .)
    LKEY            reduce using rule 129 (value -> FLOAT32 .)
    RPAREN          reduce using rule 129 (value -> FLOAT32 .)
    COMMA           reduce using rule 129 (value -> FLOAT32 .)
    FMT_LIBRARY     reduce using rule 129 (value -> FLOAT32 .)
    FUNC            reduce using rule 129 (value -> FLOAT32 .)
    IDENTIFIER      reduce using rule 129 (value -> FLOAT32 .)
    INPUT           reduce using rule 129 (value -> FLOAT32 .)
    VAR             reduce using rule 129 (value -> FLOAT32 .)
    CONST           reduce using rule 129 (value -> FLOAT32 .)
    IF              reduce using rule 129 (value -> FLOAT32 .)
    SWITCH          reduce using rule 129 (value -> FLOAT32 .)
    FOR             reduce using rule 129 (value -> FLOAT32 .)
    STRING          reduce using rule 129 (value -> FLOAT32 .)
    INTEGER         reduce using rule 129 (value -> FLOAT32 .)
    FLOAT32         reduce using rule 129 (value -> FLOAT32 .)
    FLOAT64         reduce using rule 129 (value -> FLOAT32 .)
    BOOLEAN         reduce using rule 129 (value -> FLOAT32 .)
    BREAK           reduce using rule 129 (value -> FLOAT32 .)
    $end            reduce using rule 129 (value -> FLOAT32 .)
    RKEY            reduce using rule 129 (value -> FLOAT32 .)
    CASE            reduce using rule 129 (value -> FLOAT32 .)
    DEFAULT         reduce using rule 129 (value -> FLOAT32 .)
    COLON           reduce using rule 129 (value -> FLOAT32 .)


state 34

    (130) value -> FLOAT64 .

    PLUS            reduce using rule 130 (value -> FLOAT64 .)
    MINUS           reduce using rule 130 (value -> FLOAT64 .)
    DIVIDE          reduce using rule 130 (value -> FLOAT64 .)
    TIMES           reduce using rule 130 (value -> FLOAT64 .)
    ENTERE_DIVIDE   reduce using rule 130 (value -> FLOAT64 .)
    MODULE          reduce using rule 130 (value -> FLOAT64 .)
    EQUALEQUAL      reduce using rule 130 (value -> FLOAT64 .)
    NOT_EQUAL       reduce using rule 130 (value -> FLOAT64 .)
    LESS_EQUAL      reduce using rule 130 (value -> FLOAT64 .)
    GREATER_EQUAL   reduce using rule 130 (value -> FLOAT64 .)
    LESS            reduce using rule 130 (value -> FLOAT64 .)
    GREATER         reduce using rule 130 (value -> FLOAT64 .)
    LOGICAL_AND     reduce using rule 130 (value -> FLOAT64 .)
    LOGICAL_OR      reduce using rule 130 (value -> FLOAT64 .)
    LKEY            reduce using rule 130 (value -> FLOAT64 .)
    RPAREN          reduce using rule 130 (value -> FLOAT64 .)
    COMMA           reduce using rule 130 (value -> FLOAT64 .)
    FMT_LIBRARY     reduce using rule 130 (value -> FLOAT64 .)
    FUNC            reduce using rule 130 (value -> FLOAT64 .)
    IDENTIFIER      reduce using rule 130 (value -> FLOAT64 .)
    INPUT           reduce using rule 130 (value -> FLOAT64 .)
    VAR             reduce using rule 130 (value -> FLOAT64 .)
    CONST           reduce using rule 130 (value -> FLOAT64 .)
    IF              reduce using rule 130 (value -> FLOAT64 .)
    SWITCH          reduce using rule 130 (value -> FLOAT64 .)
    FOR             reduce using rule 130 (value -> FLOAT64 .)
    STRING          reduce using rule 130 (value -> FLOAT64 .)
    INTEGER         reduce using rule 130 (value -> FLOAT64 .)
    FLOAT32         reduce using rule 130 (value -> FLOAT64 .)
    FLOAT64         reduce using rule 130 (value -> FLOAT64 .)
    BOOLEAN         reduce using rule 130 (value -> FLOAT64 .)
    BREAK           reduce using rule 130 (value -> FLOAT64 .)
    $end            reduce using rule 130 (value -> FLOAT64 .)
    RKEY            reduce using rule 130 (value -> FLOAT64 .)
    CASE            reduce using rule 130 (value -> FLOAT64 .)
    DEFAULT         reduce using rule 130 (value -> FLOAT64 .)
    COLON           reduce using rule 130 (value -> FLOAT64 .)


state 35

    (131) value -> BOOLEAN .

    PLUS            reduce using rule 131 (value -> BOOLEAN .)
    MINUS           reduce using rule 131 (value -> BOOLEAN .)
    DIVIDE          reduce using rule 131 (value -> BOOLEAN .)
    TIMES           reduce using rule 131 (value -> BOOLEAN .)
    ENTERE_DIVIDE   reduce using rule 131 (value -> BOOLEAN .)
    MODULE          reduce using rule 131 (value -> BOOLEAN .)
    EQUALEQUAL      reduce using rule 131 (value -> BOOLEAN .)
    NOT_EQUAL       reduce using rule 131 (value -> BOOLEAN .)
    LESS_EQUAL      reduce using rule 131 (value -> BOOLEAN .)
    GREATER_EQUAL   reduce using rule 131 (value -> BOOLEAN .)
    LESS            reduce using rule 131 (value -> BOOLEAN .)
    GREATER         reduce using rule 131 (value -> BOOLEAN .)
    LOGICAL_AND     reduce using rule 131 (value -> BOOLEAN .)
    LOGICAL_OR      reduce using rule 131 (value -> BOOLEAN .)
    LKEY            reduce using rule 131 (value -> BOOLEAN .)
    RPAREN          reduce using rule 131 (value -> BOOLEAN .)
    COMMA           reduce using rule 131 (value -> BOOLEAN .)
    FMT_LIBRARY     reduce using rule 131 (value -> BOOLEAN .)
    FUNC            reduce using rule 131 (value -> BOOLEAN .)
    IDENTIFIER      reduce using rule 131 (value -> BOOLEAN .)
    INPUT           reduce using rule 131 (value -> BOOLEAN .)
    VAR             reduce using rule 131 (value -> BOOLEAN .)
    CONST           reduce using rule 131 (value -> BOOLEAN .)
    IF              reduce using rule 131 (value -> BOOLEAN .)
    SWITCH          reduce using rule 131 (value -> BOOLEAN .)
    FOR             reduce using rule 131 (value -> BOOLEAN .)
    STRING          reduce using rule 131 (value -> BOOLEAN .)
    INTEGER         reduce using rule 131 (value -> BOOLEAN .)
    FLOAT32         reduce using rule 131 (value -> BOOLEAN .)
    FLOAT64         reduce using rule 131 (value -> BOOLEAN .)
    BOOLEAN         reduce using rule 131 (value -> BOOLEAN .)
    BREAK           reduce using rule 131 (value -> BOOLEAN .)
    $end            reduce using rule 131 (value -> BOOLEAN .)
    RKEY            reduce using rule 131 (value -> BOOLEAN .)
    CASE            reduce using rule 131 (value -> BOOLEAN .)
    DEFAULT         reduce using rule 131 (value -> BOOLEAN .)
    COLON           reduce using rule 131 (value -> BOOLEAN .)


state 36

    (3) loop_program -> loop_program program .
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! shift/reduce conflict for FMT_LIBRARY resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT32 resolved as shift
  ! shift/reduce conflict for FLOAT64 resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    BREAK           reduce using rule 3 (loop_program -> loop_program program .)
    $end            reduce using rule 3 (loop_program -> loop_program program .)
    RKEY            reduce using rule 3 (loop_program -> loop_program program .)
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

  ! FMT_LIBRARY     [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FUNC            [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! IDENTIFIER      [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! INPUT           [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! VAR             [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! CONST           [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! IF              [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! SWITCH          [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FOR             [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! STRING          [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! INTEGER         [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FLOAT32         [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! FLOAT64         [ reduce using rule 3 (loop_program -> loop_program program .) ]
  ! BOOLEAN         [ reduce using rule 3 (loop_program -> loop_program program .) ]

    sentencia                      shift and go to state 38
    loop                           shift and go to state 39
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 37

    (4) loop_program -> loop_program BREAK .

    BREAK           reduce using rule 4 (loop_program -> loop_program BREAK .)
    FMT_LIBRARY     reduce using rule 4 (loop_program -> loop_program BREAK .)
    FUNC            reduce using rule 4 (loop_program -> loop_program BREAK .)
    IDENTIFIER      reduce using rule 4 (loop_program -> loop_program BREAK .)
    INPUT           reduce using rule 4 (loop_program -> loop_program BREAK .)
    VAR             reduce using rule 4 (loop_program -> loop_program BREAK .)
    CONST           reduce using rule 4 (loop_program -> loop_program BREAK .)
    IF              reduce using rule 4 (loop_program -> loop_program BREAK .)
    SWITCH          reduce using rule 4 (loop_program -> loop_program BREAK .)
    FOR             reduce using rule 4 (loop_program -> loop_program BREAK .)
    STRING          reduce using rule 4 (loop_program -> loop_program BREAK .)
    INTEGER         reduce using rule 4 (loop_program -> loop_program BREAK .)
    FLOAT32         reduce using rule 4 (loop_program -> loop_program BREAK .)
    FLOAT64         reduce using rule 4 (loop_program -> loop_program BREAK .)
    BOOLEAN         reduce using rule 4 (loop_program -> loop_program BREAK .)
    $end            reduce using rule 4 (loop_program -> loop_program BREAK .)
    RKEY            reduce using rule 4 (loop_program -> loop_program BREAK .)


state 38

    (7) program -> program sentencia .

    FMT_LIBRARY     reduce using rule 7 (program -> program sentencia .)
    FUNC            reduce using rule 7 (program -> program sentencia .)
    IDENTIFIER      reduce using rule 7 (program -> program sentencia .)
    INPUT           reduce using rule 7 (program -> program sentencia .)
    VAR             reduce using rule 7 (program -> program sentencia .)
    CONST           reduce using rule 7 (program -> program sentencia .)
    IF              reduce using rule 7 (program -> program sentencia .)
    SWITCH          reduce using rule 7 (program -> program sentencia .)
    FOR             reduce using rule 7 (program -> program sentencia .)
    STRING          reduce using rule 7 (program -> program sentencia .)
    INTEGER         reduce using rule 7 (program -> program sentencia .)
    FLOAT32         reduce using rule 7 (program -> program sentencia .)
    FLOAT64         reduce using rule 7 (program -> program sentencia .)
    BOOLEAN         reduce using rule 7 (program -> program sentencia .)
    BREAK           reduce using rule 7 (program -> program sentencia .)
    $end            reduce using rule 7 (program -> program sentencia .)
    RKEY            reduce using rule 7 (program -> program sentencia .)


state 39

    (8) program -> program loop .

    FMT_LIBRARY     reduce using rule 8 (program -> program loop .)
    FUNC            reduce using rule 8 (program -> program loop .)
    IDENTIFIER      reduce using rule 8 (program -> program loop .)
    INPUT           reduce using rule 8 (program -> program loop .)
    VAR             reduce using rule 8 (program -> program loop .)
    CONST           reduce using rule 8 (program -> program loop .)
    IF              reduce using rule 8 (program -> program loop .)
    SWITCH          reduce using rule 8 (program -> program loop .)
    FOR             reduce using rule 8 (program -> program loop .)
    STRING          reduce using rule 8 (program -> program loop .)
    INTEGER         reduce using rule 8 (program -> program loop .)
    FLOAT32         reduce using rule 8 (program -> program loop .)
    FLOAT64         reduce using rule 8 (program -> program loop .)
    BOOLEAN         reduce using rule 8 (program -> program loop .)
    BREAK           reduce using rule 8 (program -> program loop .)
    $end            reduce using rule 8 (program -> program loop .)
    RKEY            reduce using rule 8 (program -> program loop .)


state 40

    (64) print -> FMT_LIBRARY DOT . PRINTLN LPAREN data RPAREN
    (65) print -> FMT_LIBRARY DOT . PRINTF LPAREN value RPAREN
    (66) print -> FMT_LIBRARY DOT . PRINTF LPAREN value COMMA RPAREN
    (67) print -> FMT_LIBRARY DOT . PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> FMT_LIBRARY DOT . PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> FMT_LIBRARY DOT . PRINTF LPAREN RPAREN

    PRINTLN         shift and go to state 83
    PRINTF          shift and go to state 84


state 41

    (120) def_function -> FUNC IDENTIFIER . LPAREN parameters RPAREN LKEY program RKEY

    LPAREN          shift and go to state 85


state 42

    (121) call_function -> IDENTIFIER LPAREN . values RPAREN
    (24) function_call -> IDENTIFIER LPAREN . values RPAREN
    (125) values -> . value
    (126) values -> . values COMMA value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    values                         shift and go to state 86
    value                          shift and go to state 87

state 43

    (76) short_assignment -> IDENTIFIER SHORT_VAR_DECL . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 88
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 44

    (82) direct_arithmetic_operation -> IDENTIFIER PLUS_EQ . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 89

state 45

    (83) direct_arithmetic_operation -> IDENTIFIER MINUS_EQ . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 90

state 46

    (84) direct_arithmetic_operation -> IDENTIFIER TIMES_EQ . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 91

state 47

    (85) direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 92

state 48

    (86) direct_arithmetic_operation -> IDENTIFIER MODULO_EQ . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 93

state 49

    (87) direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 94

state 50

    (88) direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 95

state 51

    (89) direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 96

state 52

    (90) direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 97

state 53

    (91) direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 98

state 54

    (138) input -> INPUT LPAREN . RPAREN
    (139) input -> INPUT LPAREN . value RPAREN
    (140) input -> INPUT LPAREN . identifiers RPAREN
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (106) identifiers -> . IDENTIFIER
    (107) identifiers -> . identifiers COMMA identifiers

    RPAREN          shift and go to state 99
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 102

    value                          shift and go to state 100
    identifiers                    shift and go to state 101

state 55

    (74) assignment -> VAR IDENTIFIER . data_type EQUAL usable_value
    (133) data_type -> . INTEGER_DATA_TYPE
    (134) data_type -> . FLOAT32_DATA_TYPE
    (135) data_type -> . FLOAT64_DATA_TYPE
    (136) data_type -> . BOOLEAN_DATA_TYPE
    (137) data_type -> . STRING_DATA_TYPE

    INTEGER_DATA_TYPE shift and go to state 104
    FLOAT32_DATA_TYPE shift and go to state 105
    FLOAT64_DATA_TYPE shift and go to state 106
    BOOLEAN_DATA_TYPE shift and go to state 107
    STRING_DATA_TYPE shift and go to state 108

    data_type                      shift and go to state 103

state 56

    (92) arithmetic_operation -> usable_value PLUS . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 109
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 57

    (93) arithmetic_operation -> usable_value MINUS . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 110
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 58

    (94) arithmetic_operation -> usable_value DIVIDE . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 111
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 59

    (95) arithmetic_operation -> usable_value TIMES . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 112
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 60

    (96) arithmetic_operation -> usable_value ENTERE_DIVIDE . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 113
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 61

    (97) arithmetic_operation -> usable_value MODULE . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 114
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 62

    (98) comparation_operation -> usable_value EQUALEQUAL . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 115
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 63

    (99) comparation_operation -> usable_value NOT_EQUAL . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 116
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 64

    (100) comparation_operation -> usable_value LESS_EQUAL . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 117
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 65

    (101) comparation_operation -> usable_value GREATER_EQUAL . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 118
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 66

    (102) comparation_operation -> usable_value LESS . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 119
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 67

    (103) comparation_operation -> usable_value GREATER . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 120
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 68

    (104) comparation_operation -> usable_value LOGICAL_AND . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 121
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 69

    (105) comparation_operation -> usable_value LOGICAL_OR . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 122
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 70

    (75) assignment -> CONST IDENTIFIER . data_type EQUAL usable_value
    (133) data_type -> . INTEGER_DATA_TYPE
    (134) data_type -> . FLOAT32_DATA_TYPE
    (135) data_type -> . FLOAT64_DATA_TYPE
    (136) data_type -> . BOOLEAN_DATA_TYPE
    (137) data_type -> . STRING_DATA_TYPE

    INTEGER_DATA_TYPE shift and go to state 104
    FLOAT32_DATA_TYPE shift and go to state 105
    FLOAT64_DATA_TYPE shift and go to state 106
    BOOLEAN_DATA_TYPE shift and go to state 107
    STRING_DATA_TYPE shift and go to state 108

    data_type                      shift and go to state 123

state 71

    (25) if_statement -> IF rule_comparation . LKEY program RKEY
    (26) if_statement -> IF rule_comparation . LKEY program RKEY ELSE LKEY program RKEY

    LKEY            shift and go to state 124


state 72

    (27) if_statement -> IF value . LKEY program RKEY
    (28) if_statement -> IF value . LKEY program RKEY ELSE LKEY program RKEY

    LKEY            shift and go to state 125


state 73

    (108) rule_comparation -> IDENTIFIER . EQUALEQUAL value
    (109) rule_comparation -> IDENTIFIER . NOT_EQUAL value
    (110) rule_comparation -> IDENTIFIER . LESS_EQUAL value
    (111) rule_comparation -> IDENTIFIER . GREATER_EQUAL value
    (112) rule_comparation -> IDENTIFIER . LESS value
    (113) rule_comparation -> IDENTIFIER . GREATER value
    (114) rule_comparation -> IDENTIFIER . LOGICAL_AND value
    (115) rule_comparation -> IDENTIFIER . LOGICAL_OR value
    (132) value -> IDENTIFIER .

    EQUALEQUAL      shift and go to state 126
    NOT_EQUAL       shift and go to state 127
    LESS_EQUAL      shift and go to state 128
    GREATER_EQUAL   shift and go to state 129
    LESS            shift and go to state 130
    GREATER         shift and go to state 131
    LOGICAL_AND     shift and go to state 132
    LOGICAL_OR      shift and go to state 133
    LKEY            reduce using rule 132 (value -> IDENTIFIER .)


state 74

    (29) switch_statement -> SWITCH expression . LKEY case_clauses RKEY
    (30) switch_statement -> SWITCH expression . LKEY case_clauses DEFAULT COLON statements RKEY
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

    LKEY            shift and go to state 134
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148


state 75

    (49) expression -> value .

    LKEY            reduce using rule 49 (expression -> value .)
    PLUS            reduce using rule 49 (expression -> value .)
    MINUS           reduce using rule 49 (expression -> value .)
    TIMES           reduce using rule 49 (expression -> value .)
    DIVIDE          reduce using rule 49 (expression -> value .)
    ENTERE_DIVIDE   reduce using rule 49 (expression -> value .)
    MODULE          reduce using rule 49 (expression -> value .)
    EQUALEQUAL      reduce using rule 49 (expression -> value .)
    NOT_EQUAL       reduce using rule 49 (expression -> value .)
    LESS_EQUAL      reduce using rule 49 (expression -> value .)
    GREATER_EQUAL   reduce using rule 49 (expression -> value .)
    LESS            reduce using rule 49 (expression -> value .)
    GREATER         reduce using rule 49 (expression -> value .)
    LOGICAL_AND     reduce using rule 49 (expression -> value .)
    LOGICAL_OR      reduce using rule 49 (expression -> value .)


state 76

    (132) value -> IDENTIFIER .

    LKEY            reduce using rule 132 (value -> IDENTIFIER .)
    PLUS            reduce using rule 132 (value -> IDENTIFIER .)
    MINUS           reduce using rule 132 (value -> IDENTIFIER .)
    TIMES           reduce using rule 132 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 132 (value -> IDENTIFIER .)
    ENTERE_DIVIDE   reduce using rule 132 (value -> IDENTIFIER .)
    MODULE          reduce using rule 132 (value -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 132 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 132 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 132 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 132 (value -> IDENTIFIER .)
    LESS            reduce using rule 132 (value -> IDENTIFIER .)
    GREATER         reduce using rule 132 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 132 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 132 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 132 (value -> IDENTIFIER .)
    COMMA           reduce using rule 132 (value -> IDENTIFIER .)
    FMT_LIBRARY     reduce using rule 132 (value -> IDENTIFIER .)
    FUNC            reduce using rule 132 (value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 132 (value -> IDENTIFIER .)
    INPUT           reduce using rule 132 (value -> IDENTIFIER .)
    VAR             reduce using rule 132 (value -> IDENTIFIER .)
    CONST           reduce using rule 132 (value -> IDENTIFIER .)
    IF              reduce using rule 132 (value -> IDENTIFIER .)
    SWITCH          reduce using rule 132 (value -> IDENTIFIER .)
    FOR             reduce using rule 132 (value -> IDENTIFIER .)
    STRING          reduce using rule 132 (value -> IDENTIFIER .)
    INTEGER         reduce using rule 132 (value -> IDENTIFIER .)
    FLOAT32         reduce using rule 132 (value -> IDENTIFIER .)
    FLOAT64         reduce using rule 132 (value -> IDENTIFIER .)
    BOOLEAN         reduce using rule 132 (value -> IDENTIFIER .)
    BREAK           reduce using rule 132 (value -> IDENTIFIER .)
    $end            reduce using rule 132 (value -> IDENTIFIER .)
    RKEY            reduce using rule 132 (value -> IDENTIFIER .)
    CASE            reduce using rule 132 (value -> IDENTIFIER .)
    DEFAULT         reduce using rule 132 (value -> IDENTIFIER .)
    COLON           reduce using rule 132 (value -> IDENTIFIER .)


state 77

    (22) for -> FOR LKEY . loop_program RKEY
    (1) loop_program -> . program
    (2) loop_program -> . BREAK
    (3) loop_program -> . loop_program program
    (4) loop_program -> . loop_program BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 3
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    loop_program                   shift and go to state 149
    program                        shift and go to state 2
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 78

    (23) for -> FOR comparation_operation . LKEY loop_program RKEY
    (81) usable_value -> comparation_operation .

    LKEY            shift and go to state 150
    EQUALEQUAL      reduce using rule 81 (usable_value -> comparation_operation .)
    NOT_EQUAL       reduce using rule 81 (usable_value -> comparation_operation .)
    LESS_EQUAL      reduce using rule 81 (usable_value -> comparation_operation .)
    GREATER_EQUAL   reduce using rule 81 (usable_value -> comparation_operation .)
    LESS            reduce using rule 81 (usable_value -> comparation_operation .)
    GREATER         reduce using rule 81 (usable_value -> comparation_operation .)
    LOGICAL_AND     reduce using rule 81 (usable_value -> comparation_operation .)
    LOGICAL_OR      reduce using rule 81 (usable_value -> comparation_operation .)
    PLUS            reduce using rule 81 (usable_value -> comparation_operation .)
    MINUS           reduce using rule 81 (usable_value -> comparation_operation .)
    DIVIDE          reduce using rule 81 (usable_value -> comparation_operation .)
    TIMES           reduce using rule 81 (usable_value -> comparation_operation .)
    ENTERE_DIVIDE   reduce using rule 81 (usable_value -> comparation_operation .)
    MODULE          reduce using rule 81 (usable_value -> comparation_operation .)


state 79

    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value

    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61


state 80

    (78) usable_value -> call_function .

    EQUALEQUAL      reduce using rule 78 (usable_value -> call_function .)
    NOT_EQUAL       reduce using rule 78 (usable_value -> call_function .)
    LESS_EQUAL      reduce using rule 78 (usable_value -> call_function .)
    GREATER_EQUAL   reduce using rule 78 (usable_value -> call_function .)
    LESS            reduce using rule 78 (usable_value -> call_function .)
    GREATER         reduce using rule 78 (usable_value -> call_function .)
    LOGICAL_AND     reduce using rule 78 (usable_value -> call_function .)
    LOGICAL_OR      reduce using rule 78 (usable_value -> call_function .)
    PLUS            reduce using rule 78 (usable_value -> call_function .)
    MINUS           reduce using rule 78 (usable_value -> call_function .)
    DIVIDE          reduce using rule 78 (usable_value -> call_function .)
    TIMES           reduce using rule 78 (usable_value -> call_function .)
    ENTERE_DIVIDE   reduce using rule 78 (usable_value -> call_function .)
    MODULE          reduce using rule 78 (usable_value -> call_function .)
    FMT_LIBRARY     reduce using rule 78 (usable_value -> call_function .)
    FUNC            reduce using rule 78 (usable_value -> call_function .)
    IDENTIFIER      reduce using rule 78 (usable_value -> call_function .)
    INPUT           reduce using rule 78 (usable_value -> call_function .)
    VAR             reduce using rule 78 (usable_value -> call_function .)
    CONST           reduce using rule 78 (usable_value -> call_function .)
    IF              reduce using rule 78 (usable_value -> call_function .)
    SWITCH          reduce using rule 78 (usable_value -> call_function .)
    FOR             reduce using rule 78 (usable_value -> call_function .)
    STRING          reduce using rule 78 (usable_value -> call_function .)
    INTEGER         reduce using rule 78 (usable_value -> call_function .)
    FLOAT32         reduce using rule 78 (usable_value -> call_function .)
    FLOAT64         reduce using rule 78 (usable_value -> call_function .)
    BOOLEAN         reduce using rule 78 (usable_value -> call_function .)
    BREAK           reduce using rule 78 (usable_value -> call_function .)
    $end            reduce using rule 78 (usable_value -> call_function .)
    RKEY            reduce using rule 78 (usable_value -> call_function .)
    CASE            reduce using rule 78 (usable_value -> call_function .)
    DEFAULT         reduce using rule 78 (usable_value -> call_function .)
    LKEY            reduce using rule 78 (usable_value -> call_function .)


state 81

    (79) usable_value -> IDENTIFIER .
    (132) value -> IDENTIFIER .
    (121) call_function -> IDENTIFIER . LPAREN values RPAREN

  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for ENTERE_DIVIDE resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for MODULE resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for FMT_LIBRARY resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for FUNC resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for INPUT resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for VAR resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for CONST resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for FOR resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for STRING resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for BREAK resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for $end resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for RKEY resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for CASE resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 79 (usable_value -> IDENTIFIER .)
  ! reduce/reduce conflict for LKEY resolved using rule 79 (usable_value -> IDENTIFIER .)
    EQUALEQUAL      reduce using rule 79 (usable_value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 79 (usable_value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 79 (usable_value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 79 (usable_value -> IDENTIFIER .)
    LESS            reduce using rule 79 (usable_value -> IDENTIFIER .)
    GREATER         reduce using rule 79 (usable_value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 79 (usable_value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 79 (usable_value -> IDENTIFIER .)
    PLUS            reduce using rule 79 (usable_value -> IDENTIFIER .)
    MINUS           reduce using rule 79 (usable_value -> IDENTIFIER .)
    DIVIDE          reduce using rule 79 (usable_value -> IDENTIFIER .)
    TIMES           reduce using rule 79 (usable_value -> IDENTIFIER .)
    ENTERE_DIVIDE   reduce using rule 79 (usable_value -> IDENTIFIER .)
    MODULE          reduce using rule 79 (usable_value -> IDENTIFIER .)
    FMT_LIBRARY     reduce using rule 79 (usable_value -> IDENTIFIER .)
    FUNC            reduce using rule 79 (usable_value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 79 (usable_value -> IDENTIFIER .)
    INPUT           reduce using rule 79 (usable_value -> IDENTIFIER .)
    VAR             reduce using rule 79 (usable_value -> IDENTIFIER .)
    CONST           reduce using rule 79 (usable_value -> IDENTIFIER .)
    IF              reduce using rule 79 (usable_value -> IDENTIFIER .)
    SWITCH          reduce using rule 79 (usable_value -> IDENTIFIER .)
    FOR             reduce using rule 79 (usable_value -> IDENTIFIER .)
    STRING          reduce using rule 79 (usable_value -> IDENTIFIER .)
    INTEGER         reduce using rule 79 (usable_value -> IDENTIFIER .)
    FLOAT32         reduce using rule 79 (usable_value -> IDENTIFIER .)
    FLOAT64         reduce using rule 79 (usable_value -> IDENTIFIER .)
    BOOLEAN         reduce using rule 79 (usable_value -> IDENTIFIER .)
    BREAK           reduce using rule 79 (usable_value -> IDENTIFIER .)
    $end            reduce using rule 79 (usable_value -> IDENTIFIER .)
    RKEY            reduce using rule 79 (usable_value -> IDENTIFIER .)
    CASE            reduce using rule 79 (usable_value -> IDENTIFIER .)
    DEFAULT         reduce using rule 79 (usable_value -> IDENTIFIER .)
    LKEY            reduce using rule 79 (usable_value -> IDENTIFIER .)
    LPAREN          shift and go to state 151

  ! EQUALEQUAL      [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! NOT_EQUAL       [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! LESS_EQUAL      [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! GREATER_EQUAL   [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! LESS            [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! GREATER         [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! LOGICAL_AND     [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! LOGICAL_OR      [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! MODULE          [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! FMT_LIBRARY     [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! FUNC            [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! INPUT           [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! VAR             [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! CONST           [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! IF              [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! SWITCH          [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! FOR             [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! STRING          [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! INTEGER         [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! FLOAT32         [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! FLOAT64         [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! BOOLEAN         [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! BREAK           [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! $end            [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! RKEY            [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! CASE            [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! DEFAULT         [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! LKEY            [ reduce using rule 132 (value -> IDENTIFIER .) ]


state 82

    (80) usable_value -> arithmetic_operation .

    EQUALEQUAL      reduce using rule 80 (usable_value -> arithmetic_operation .)
    NOT_EQUAL       reduce using rule 80 (usable_value -> arithmetic_operation .)
    LESS_EQUAL      reduce using rule 80 (usable_value -> arithmetic_operation .)
    GREATER_EQUAL   reduce using rule 80 (usable_value -> arithmetic_operation .)
    LESS            reduce using rule 80 (usable_value -> arithmetic_operation .)
    GREATER         reduce using rule 80 (usable_value -> arithmetic_operation .)
    LOGICAL_AND     reduce using rule 80 (usable_value -> arithmetic_operation .)
    LOGICAL_OR      reduce using rule 80 (usable_value -> arithmetic_operation .)
    PLUS            reduce using rule 80 (usable_value -> arithmetic_operation .)
    MINUS           reduce using rule 80 (usable_value -> arithmetic_operation .)
    DIVIDE          reduce using rule 80 (usable_value -> arithmetic_operation .)
    TIMES           reduce using rule 80 (usable_value -> arithmetic_operation .)
    ENTERE_DIVIDE   reduce using rule 80 (usable_value -> arithmetic_operation .)
    MODULE          reduce using rule 80 (usable_value -> arithmetic_operation .)
    FMT_LIBRARY     reduce using rule 80 (usable_value -> arithmetic_operation .)
    FUNC            reduce using rule 80 (usable_value -> arithmetic_operation .)
    IDENTIFIER      reduce using rule 80 (usable_value -> arithmetic_operation .)
    INPUT           reduce using rule 80 (usable_value -> arithmetic_operation .)
    VAR             reduce using rule 80 (usable_value -> arithmetic_operation .)
    CONST           reduce using rule 80 (usable_value -> arithmetic_operation .)
    IF              reduce using rule 80 (usable_value -> arithmetic_operation .)
    SWITCH          reduce using rule 80 (usable_value -> arithmetic_operation .)
    FOR             reduce using rule 80 (usable_value -> arithmetic_operation .)
    STRING          reduce using rule 80 (usable_value -> arithmetic_operation .)
    INTEGER         reduce using rule 80 (usable_value -> arithmetic_operation .)
    FLOAT32         reduce using rule 80 (usable_value -> arithmetic_operation .)
    FLOAT64         reduce using rule 80 (usable_value -> arithmetic_operation .)
    BOOLEAN         reduce using rule 80 (usable_value -> arithmetic_operation .)
    BREAK           reduce using rule 80 (usable_value -> arithmetic_operation .)
    $end            reduce using rule 80 (usable_value -> arithmetic_operation .)
    RKEY            reduce using rule 80 (usable_value -> arithmetic_operation .)
    CASE            reduce using rule 80 (usable_value -> arithmetic_operation .)
    DEFAULT         reduce using rule 80 (usable_value -> arithmetic_operation .)
    LKEY            reduce using rule 80 (usable_value -> arithmetic_operation .)


state 83

    (64) print -> FMT_LIBRARY DOT PRINTLN . LPAREN data RPAREN
    (72) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN . LPAREN RPAREN

    LPAREN          shift and go to state 152


state 84

    (65) print -> FMT_LIBRARY DOT PRINTF . LPAREN value RPAREN
    (66) print -> FMT_LIBRARY DOT PRINTF . LPAREN value COMMA RPAREN
    (67) print -> FMT_LIBRARY DOT PRINTF . LPAREN value COMMA data RPAREN
    (73) print_withoutvalue -> FMT_LIBRARY DOT PRINTF . LPAREN RPAREN

    LPAREN          shift and go to state 153


state 85

    (120) def_function -> FUNC IDENTIFIER LPAREN . parameters RPAREN LKEY program RKEY
    (122) parameters -> . parameter
    (123) parameters -> . parameters COMMA parameter
    (124) parameter -> . IDENTIFIER data_type

    IDENTIFIER      shift and go to state 154

    parameters                     shift and go to state 155
    parameter                      shift and go to state 156

state 86

    (121) call_function -> IDENTIFIER LPAREN values . RPAREN
    (24) function_call -> IDENTIFIER LPAREN values . RPAREN
    (126) values -> values . COMMA value

    RPAREN          shift and go to state 157
    COMMA           shift and go to state 158


state 87

    (125) values -> value .

    RPAREN          reduce using rule 125 (values -> value .)
    COMMA           reduce using rule 125 (values -> value .)


state 88

    (76) short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

    FMT_LIBRARY     reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FUNC            reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    IDENTIFIER      reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    INPUT           reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    VAR             reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    CONST           reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    IF              reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    SWITCH          reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FOR             reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    STRING          reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    INTEGER         reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FLOAT32         reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    FLOAT64         reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    BOOLEAN         reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    BREAK           reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    $end            reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    RKEY            reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    CASE            reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    DEFAULT         reduce using rule 76 (short_assignment -> IDENTIFIER SHORT_VAR_DECL usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69


state 89

    (82) direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .

    FMT_LIBRARY     reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FUNC            reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    IDENTIFIER      reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    INPUT           reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    VAR             reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    CONST           reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    IF              reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    SWITCH          reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FOR             reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    STRING          reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    INTEGER         reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FLOAT32         reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    FLOAT64         reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    BOOLEAN         reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    BREAK           reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    $end            reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    RKEY            reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    CASE            reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)
    DEFAULT         reduce using rule 82 (direct_arithmetic_operation -> IDENTIFIER PLUS_EQ value .)


state 90

    (83) direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .

    FMT_LIBRARY     reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FUNC            reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    IDENTIFIER      reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    INPUT           reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    VAR             reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    CONST           reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    IF              reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    SWITCH          reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FOR             reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    STRING          reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    INTEGER         reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FLOAT32         reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    FLOAT64         reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    BOOLEAN         reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    BREAK           reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    $end            reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    RKEY            reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    CASE            reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)
    DEFAULT         reduce using rule 83 (direct_arithmetic_operation -> IDENTIFIER MINUS_EQ value .)


state 91

    (84) direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .

    FMT_LIBRARY     reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FUNC            reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    IDENTIFIER      reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    INPUT           reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    VAR             reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    CONST           reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    IF              reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    SWITCH          reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FOR             reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    STRING          reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    INTEGER         reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FLOAT32         reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    FLOAT64         reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    BOOLEAN         reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    BREAK           reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    $end            reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    RKEY            reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    CASE            reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)
    DEFAULT         reduce using rule 84 (direct_arithmetic_operation -> IDENTIFIER TIMES_EQ value .)


state 92

    (85) direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .

    FMT_LIBRARY     reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FUNC            reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    IDENTIFIER      reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    INPUT           reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    VAR             reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    CONST           reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    IF              reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    SWITCH          reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FOR             reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    STRING          reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    INTEGER         reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FLOAT32         reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    FLOAT64         reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    BOOLEAN         reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    BREAK           reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    $end            reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    RKEY            reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    CASE            reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)
    DEFAULT         reduce using rule 85 (direct_arithmetic_operation -> IDENTIFIER DIVIDE_EQ value .)


state 93

    (86) direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .

    FMT_LIBRARY     reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FUNC            reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    IDENTIFIER      reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    INPUT           reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    VAR             reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    CONST           reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    IF              reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    SWITCH          reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FOR             reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    STRING          reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    INTEGER         reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FLOAT32         reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    FLOAT64         reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    BOOLEAN         reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    BREAK           reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    $end            reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    RKEY            reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    CASE            reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)
    DEFAULT         reduce using rule 86 (direct_arithmetic_operation -> IDENTIFIER MODULO_EQ value .)


state 94

    (87) direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .

    FMT_LIBRARY     reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FUNC            reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    IDENTIFIER      reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    INPUT           reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    VAR             reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    CONST           reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    IF              reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    SWITCH          reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FOR             reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    STRING          reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    INTEGER         reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FLOAT32         reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    FLOAT64         reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    BOOLEAN         reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    BREAK           reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    $end            reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    RKEY            reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    CASE            reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)
    DEFAULT         reduce using rule 87 (direct_arithmetic_operation -> IDENTIFIER BITWISE_AND_EQ value .)


state 95

    (88) direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .

    FMT_LIBRARY     reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FUNC            reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    IDENTIFIER      reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    INPUT           reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    VAR             reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    CONST           reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    IF              reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    SWITCH          reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FOR             reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    STRING          reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    INTEGER         reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FLOAT32         reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    FLOAT64         reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    BOOLEAN         reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    BREAK           reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    $end            reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    RKEY            reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    CASE            reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)
    DEFAULT         reduce using rule 88 (direct_arithmetic_operation -> IDENTIFIER BITWISE_OR_EQ value .)


state 96

    (89) direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .

    FMT_LIBRARY     reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FUNC            reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    IDENTIFIER      reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    INPUT           reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    VAR             reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    CONST           reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    IF              reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    SWITCH          reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FOR             reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    STRING          reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    INTEGER         reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FLOAT32         reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    FLOAT64         reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    BOOLEAN         reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    BREAK           reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    $end            reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    RKEY            reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    CASE            reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)
    DEFAULT         reduce using rule 89 (direct_arithmetic_operation -> IDENTIFIER BITWISE_XOR_EQ value .)


state 97

    (90) direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .

    FMT_LIBRARY     reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FUNC            reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    IDENTIFIER      reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    INPUT           reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    VAR             reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    CONST           reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    IF              reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    SWITCH          reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FOR             reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    STRING          reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    INTEGER         reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FLOAT32         reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    FLOAT64         reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    BOOLEAN         reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    BREAK           reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    $end            reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    RKEY            reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    CASE            reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)
    DEFAULT         reduce using rule 90 (direct_arithmetic_operation -> IDENTIFIER LEFT_SHIFT_EQ value .)


state 98

    (91) direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .

    FMT_LIBRARY     reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FUNC            reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    IDENTIFIER      reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    INPUT           reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    VAR             reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    CONST           reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    IF              reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    SWITCH          reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FOR             reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    STRING          reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    INTEGER         reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FLOAT32         reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    FLOAT64         reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    BOOLEAN         reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    BREAK           reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    $end            reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    RKEY            reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    CASE            reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)
    DEFAULT         reduce using rule 91 (direct_arithmetic_operation -> IDENTIFIER RIGHT_SHIFT_EQ value .)


state 99

    (138) input -> INPUT LPAREN RPAREN .

    FMT_LIBRARY     reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    FUNC            reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    CONST           reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    SWITCH          reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    STRING          reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    INTEGER         reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    FLOAT32         reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    FLOAT64         reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    BOOLEAN         reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    BREAK           reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    RKEY            reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    CASE            reduce using rule 138 (input -> INPUT LPAREN RPAREN .)
    DEFAULT         reduce using rule 138 (input -> INPUT LPAREN RPAREN .)


state 100

    (139) input -> INPUT LPAREN value . RPAREN

    RPAREN          shift and go to state 159


state 101

    (140) input -> INPUT LPAREN identifiers . RPAREN
    (107) identifiers -> identifiers . COMMA identifiers

    RPAREN          shift and go to state 160
    COMMA           shift and go to state 161


state 102

    (132) value -> IDENTIFIER .
    (106) identifiers -> IDENTIFIER .

  ! reduce/reduce conflict for RPAREN resolved using rule 106 (identifiers -> IDENTIFIER .)
    RPAREN          reduce using rule 106 (identifiers -> IDENTIFIER .)
    COMMA           reduce using rule 106 (identifiers -> IDENTIFIER .)

  ! RPAREN          [ reduce using rule 132 (value -> IDENTIFIER .) ]


state 103

    (74) assignment -> VAR IDENTIFIER data_type . EQUAL usable_value

    EQUAL           shift and go to state 162


state 104

    (133) data_type -> INTEGER_DATA_TYPE .

    EQUAL           reduce using rule 133 (data_type -> INTEGER_DATA_TYPE .)
    RPAREN          reduce using rule 133 (data_type -> INTEGER_DATA_TYPE .)
    COMMA           reduce using rule 133 (data_type -> INTEGER_DATA_TYPE .)


state 105

    (134) data_type -> FLOAT32_DATA_TYPE .

    EQUAL           reduce using rule 134 (data_type -> FLOAT32_DATA_TYPE .)
    RPAREN          reduce using rule 134 (data_type -> FLOAT32_DATA_TYPE .)
    COMMA           reduce using rule 134 (data_type -> FLOAT32_DATA_TYPE .)


state 106

    (135) data_type -> FLOAT64_DATA_TYPE .

    EQUAL           reduce using rule 135 (data_type -> FLOAT64_DATA_TYPE .)
    RPAREN          reduce using rule 135 (data_type -> FLOAT64_DATA_TYPE .)
    COMMA           reduce using rule 135 (data_type -> FLOAT64_DATA_TYPE .)


state 107

    (136) data_type -> BOOLEAN_DATA_TYPE .

    EQUAL           reduce using rule 136 (data_type -> BOOLEAN_DATA_TYPE .)
    RPAREN          reduce using rule 136 (data_type -> BOOLEAN_DATA_TYPE .)
    COMMA           reduce using rule 136 (data_type -> BOOLEAN_DATA_TYPE .)


state 108

    (137) data_type -> STRING_DATA_TYPE .

    EQUAL           reduce using rule 137 (data_type -> STRING_DATA_TYPE .)
    RPAREN          reduce using rule 137 (data_type -> STRING_DATA_TYPE .)
    COMMA           reduce using rule 137 (data_type -> STRING_DATA_TYPE .)


state 109

    (92) arithmetic_operation -> usable_value PLUS usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    FUNC            reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    IDENTIFIER      reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    INPUT           reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    VAR             reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    CONST           reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    IF              reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    SWITCH          reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    FOR             reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    STRING          reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    INTEGER         reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    FLOAT32         reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    FLOAT64         reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    BOOLEAN         reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    BREAK           reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    $end            reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    RKEY            reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    CASE            reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    DEFAULT         reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    LKEY            reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! MINUS           [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! DIVIDE          [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! TIMES           [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! MODULE          [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LESS            [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! GREATER         [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (arithmetic_operation -> usable_value PLUS usable_value .) ]


state 110

    (93) arithmetic_operation -> usable_value MINUS usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    FUNC            reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    IDENTIFIER      reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    INPUT           reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    VAR             reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    CONST           reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    IF              reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    SWITCH          reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    FOR             reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    STRING          reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    INTEGER         reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    FLOAT32         reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    FLOAT64         reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    BOOLEAN         reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    BREAK           reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    $end            reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    RKEY            reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    CASE            reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    DEFAULT         reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    LKEY            reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! MINUS           [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! DIVIDE          [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! TIMES           [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! MODULE          [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LESS            [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! GREATER         [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 93 (arithmetic_operation -> usable_value MINUS usable_value .) ]


state 111

    (94) arithmetic_operation -> usable_value DIVIDE usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FUNC            reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    IDENTIFIER      reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    INPUT           reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    VAR             reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    CONST           reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    IF              reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    SWITCH          reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FOR             reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    STRING          reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    INTEGER         reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FLOAT32         reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    FLOAT64         reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    BOOLEAN         reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    BREAK           reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    $end            reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    RKEY            reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    CASE            reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    DEFAULT         reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    LKEY            reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! MINUS           [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! DIVIDE          [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! TIMES           [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! MODULE          [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LESS            [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! GREATER         [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 94 (arithmetic_operation -> usable_value DIVIDE usable_value .) ]


state 112

    (95) arithmetic_operation -> usable_value TIMES usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    FUNC            reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    IDENTIFIER      reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    INPUT           reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    VAR             reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    CONST           reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    IF              reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    SWITCH          reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    FOR             reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    STRING          reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    INTEGER         reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    FLOAT32         reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    FLOAT64         reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    BOOLEAN         reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    BREAK           reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    $end            reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    RKEY            reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    CASE            reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    DEFAULT         reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    LKEY            reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! MINUS           [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! DIVIDE          [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! TIMES           [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! MODULE          [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LESS            [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! GREATER         [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 95 (arithmetic_operation -> usable_value TIMES usable_value .) ]


state 113

    (96) arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FUNC            reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    IDENTIFIER      reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    INPUT           reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    VAR             reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    CONST           reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    IF              reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    SWITCH          reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FOR             reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    STRING          reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    INTEGER         reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FLOAT32         reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    FLOAT64         reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    BOOLEAN         reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    BREAK           reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    $end            reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    RKEY            reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    CASE            reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    DEFAULT         reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    LKEY            reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! MINUS           [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! DIVIDE          [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! TIMES           [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! MODULE          [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LESS            [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! GREATER         [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 96 (arithmetic_operation -> usable_value ENTERE_DIVIDE usable_value .) ]


state 114

    (97) arithmetic_operation -> usable_value MODULE usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    FMT_LIBRARY     reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    FUNC            reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    IDENTIFIER      reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    INPUT           reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    VAR             reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    CONST           reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    IF              reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    SWITCH          reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    FOR             reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    STRING          reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    INTEGER         reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    FLOAT32         reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    FLOAT64         reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    BOOLEAN         reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    BREAK           reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    $end            reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    RKEY            reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    CASE            reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    DEFAULT         reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    LKEY            reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! MINUS           [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! DIVIDE          [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! TIMES           [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! MODULE          [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LESS            [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! GREATER         [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 97 (arithmetic_operation -> usable_value MODULE usable_value .) ]


state 115

    (98) comparation_operation -> usable_value EQUALEQUAL usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FUNC            reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    IDENTIFIER      reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    INPUT           reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    VAR             reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    CONST           reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    IF              reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    SWITCH          reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FOR             reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    STRING          reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    INTEGER         reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FLOAT32         reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    FLOAT64         reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    BOOLEAN         reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    BREAK           reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    $end            reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    RKEY            reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    CASE            reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    DEFAULT         reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LESS            [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 98 (comparation_operation -> usable_value EQUALEQUAL usable_value .) ]


state 116

    (99) comparation_operation -> usable_value NOT_EQUAL usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FUNC            reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    IDENTIFIER      reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    INPUT           reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    VAR             reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    CONST           reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    IF              reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    SWITCH          reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FOR             reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    STRING          reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    INTEGER         reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FLOAT32         reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    FLOAT64         reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    BOOLEAN         reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    BREAK           reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    $end            reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    RKEY            reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    CASE            reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    DEFAULT         reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LESS            [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 99 (comparation_operation -> usable_value NOT_EQUAL usable_value .) ]


state 117

    (100) comparation_operation -> usable_value LESS_EQUAL usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FUNC            reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    IDENTIFIER      reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    INPUT           reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    VAR             reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    CONST           reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    IF              reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    SWITCH          reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FOR             reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    STRING          reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    INTEGER         reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FLOAT32         reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    FLOAT64         reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    BOOLEAN         reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    BREAK           reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    $end            reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    RKEY            reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    CASE            reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    DEFAULT         reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LESS            [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 100 (comparation_operation -> usable_value LESS_EQUAL usable_value .) ]


state 118

    (101) comparation_operation -> usable_value GREATER_EQUAL usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FMT_LIBRARY     reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FUNC            reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    IDENTIFIER      reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    INPUT           reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    VAR             reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    CONST           reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    IF              reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    SWITCH          reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FOR             reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    STRING          reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    INTEGER         reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FLOAT32         reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    FLOAT64         reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    BOOLEAN         reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    BREAK           reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    $end            reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    RKEY            reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    CASE            reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    DEFAULT         reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! MINUS           [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! DIVIDE          [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! TIMES           [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! MODULE          [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LESS            [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! GREATER         [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 101 (comparation_operation -> usable_value GREATER_EQUAL usable_value .) ]


state 119

    (102) comparation_operation -> usable_value LESS usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    FMT_LIBRARY     reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    FUNC            reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    IDENTIFIER      reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    INPUT           reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    VAR             reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    CONST           reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    IF              reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    SWITCH          reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    FOR             reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    STRING          reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    INTEGER         reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    FLOAT32         reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    FLOAT64         reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    BOOLEAN         reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    BREAK           reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    $end            reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    RKEY            reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    CASE            reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    DEFAULT         reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! MINUS           [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! DIVIDE          [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! TIMES           [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! MODULE          [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LESS            [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! GREATER         [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 102 (comparation_operation -> usable_value LESS usable_value .) ]


state 120

    (103) comparation_operation -> usable_value GREATER usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    FMT_LIBRARY     reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    FUNC            reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    IDENTIFIER      reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    INPUT           reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    VAR             reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    CONST           reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    IF              reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    SWITCH          reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    FOR             reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    STRING          reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    INTEGER         reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    FLOAT32         reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    FLOAT64         reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    BOOLEAN         reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    BREAK           reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    $end            reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    RKEY            reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    CASE            reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    DEFAULT         reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! MINUS           [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! DIVIDE          [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! TIMES           [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! MODULE          [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LESS            [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! GREATER         [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 103 (comparation_operation -> usable_value GREATER usable_value .) ]


state 121

    (104) comparation_operation -> usable_value LOGICAL_AND usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FMT_LIBRARY     reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FUNC            reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    IDENTIFIER      reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    INPUT           reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    VAR             reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    CONST           reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    IF              reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    SWITCH          reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FOR             reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    STRING          reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    INTEGER         reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FLOAT32         reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    FLOAT64         reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    BOOLEAN         reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    BREAK           reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    $end            reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    RKEY            reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    CASE            reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    DEFAULT         reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! MINUS           [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! DIVIDE          [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! TIMES           [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! MODULE          [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LESS            [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! GREATER         [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 104 (comparation_operation -> usable_value LOGICAL_AND usable_value .) ]


state 122

    (105) comparation_operation -> usable_value LOGICAL_OR usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FMT_LIBRARY     reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FUNC            reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    IDENTIFIER      reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    INPUT           reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    VAR             reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    CONST           reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    IF              reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    SWITCH          reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FOR             reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    STRING          reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    INTEGER         reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FLOAT32         reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    FLOAT64         reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    BOOLEAN         reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    BREAK           reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    $end            reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    RKEY            reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    CASE            reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    DEFAULT         reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69

  ! PLUS            [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! MINUS           [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! DIVIDE          [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! TIMES           [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! MODULE          [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! EQUALEQUAL      [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! NOT_EQUAL       [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LESS_EQUAL      [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! GREATER_EQUAL   [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LESS            [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! GREATER         [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LOGICAL_AND     [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]
  ! LOGICAL_OR      [ reduce using rule 105 (comparation_operation -> usable_value LOGICAL_OR usable_value .) ]


state 123

    (75) assignment -> CONST IDENTIFIER data_type . EQUAL usable_value

    EQUAL           shift and go to state 163


state 124

    (25) if_statement -> IF rule_comparation LKEY . program RKEY
    (26) if_statement -> IF rule_comparation LKEY . program RKEY ELSE LKEY program RKEY
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    program                        shift and go to state 164
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 125

    (27) if_statement -> IF value LKEY . program RKEY
    (28) if_statement -> IF value LKEY . program RKEY ELSE LKEY program RKEY
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    value                          shift and go to state 20
    program                        shift and go to state 165
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 126

    (108) rule_comparation -> IDENTIFIER EQUALEQUAL . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 166

state 127

    (109) rule_comparation -> IDENTIFIER NOT_EQUAL . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 167

state 128

    (110) rule_comparation -> IDENTIFIER LESS_EQUAL . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 168

state 129

    (111) rule_comparation -> IDENTIFIER GREATER_EQUAL . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 169

state 130

    (112) rule_comparation -> IDENTIFIER LESS . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 170

state 131

    (113) rule_comparation -> IDENTIFIER GREATER . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 171

state 132

    (114) rule_comparation -> IDENTIFIER LOGICAL_AND . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 172

state 133

    (115) rule_comparation -> IDENTIFIER LOGICAL_OR . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 173

state 134

    (29) switch_statement -> SWITCH expression LKEY . case_clauses RKEY
    (30) switch_statement -> SWITCH expression LKEY . case_clauses DEFAULT COLON statements RKEY
    (31) case_clauses -> . case_clause case_clauses
    (32) case_clauses -> .
    (33) case_clause -> . CASE value COLON statements

    RKEY            reduce using rule 32 (case_clauses -> .)
    DEFAULT         reduce using rule 32 (case_clauses -> .)
    CASE            shift and go to state 176

    case_clauses                   shift and go to state 174
    case_clause                    shift and go to state 175

state 135

    (50) expression -> expression PLUS . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 177
    value                          shift and go to state 75

state 136

    (51) expression -> expression MINUS . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 178
    value                          shift and go to state 75

state 137

    (52) expression -> expression TIMES . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 179
    value                          shift and go to state 75

state 138

    (53) expression -> expression DIVIDE . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 180
    value                          shift and go to state 75

state 139

    (54) expression -> expression ENTERE_DIVIDE . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 181
    value                          shift and go to state 75

state 140

    (55) expression -> expression MODULE . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 182
    value                          shift and go to state 75

state 141

    (56) expression -> expression EQUALEQUAL . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 183
    value                          shift and go to state 75

state 142

    (57) expression -> expression NOT_EQUAL . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 184
    value                          shift and go to state 75

state 143

    (58) expression -> expression LESS_EQUAL . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 185
    value                          shift and go to state 75

state 144

    (59) expression -> expression GREATER_EQUAL . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 186
    value                          shift and go to state 75

state 145

    (60) expression -> expression LESS . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 187
    value                          shift and go to state 75

state 146

    (61) expression -> expression GREATER . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 188
    value                          shift and go to state 75

state 147

    (62) expression -> expression LOGICAL_AND . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 189
    value                          shift and go to state 75

state 148

    (63) expression -> expression LOGICAL_OR . expression
    (49) expression -> . value
    (50) expression -> . expression PLUS expression
    (51) expression -> . expression MINUS expression
    (52) expression -> . expression TIMES expression
    (53) expression -> . expression DIVIDE expression
    (54) expression -> . expression ENTERE_DIVIDE expression
    (55) expression -> . expression MODULE expression
    (56) expression -> . expression EQUALEQUAL expression
    (57) expression -> . expression NOT_EQUAL expression
    (58) expression -> . expression LESS_EQUAL expression
    (59) expression -> . expression GREATER_EQUAL expression
    (60) expression -> . expression LESS expression
    (61) expression -> . expression GREATER expression
    (62) expression -> . expression LOGICAL_AND expression
    (63) expression -> . expression LOGICAL_OR expression
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    expression                     shift and go to state 190
    value                          shift and go to state 75

state 149

    (22) for -> FOR LKEY loop_program . RKEY
    (3) loop_program -> loop_program . program
    (4) loop_program -> loop_program . BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 191
    BREAK           shift and go to state 37
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    program                        shift and go to state 36
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 150

    (23) for -> FOR comparation_operation LKEY . loop_program RKEY
    (1) loop_program -> . program
    (2) loop_program -> . BREAK
    (3) loop_program -> . loop_program program
    (4) loop_program -> . loop_program BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    BREAK           shift and go to state 3
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    loop_program                   shift and go to state 192
    program                        shift and go to state 2
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25

state 151

    (121) call_function -> IDENTIFIER LPAREN . values RPAREN
    (125) values -> . value
    (126) values -> . values COMMA value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    values                         shift and go to state 193
    value                          shift and go to state 87

state 152

    (64) print -> FMT_LIBRARY DOT PRINTLN LPAREN . data RPAREN
    (72) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN . RPAREN
    (68) data -> . value
    (69) data -> . IDENTIFIER
    (70) data -> . data COMMA value
    (71) data -> . data COMMA IDENTIFIER
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    RPAREN          shift and go to state 195
    IDENTIFIER      shift and go to state 197
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    data                           shift and go to state 194
    value                          shift and go to state 196

state 153

    (65) print -> FMT_LIBRARY DOT PRINTF LPAREN . value RPAREN
    (66) print -> FMT_LIBRARY DOT PRINTF LPAREN . value COMMA RPAREN
    (67) print -> FMT_LIBRARY DOT PRINTF LPAREN . value COMMA data RPAREN
    (73) print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN . RPAREN
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    RPAREN          shift and go to state 199
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 198

state 154

    (124) parameter -> IDENTIFIER . data_type
    (133) data_type -> . INTEGER_DATA_TYPE
    (134) data_type -> . FLOAT32_DATA_TYPE
    (135) data_type -> . FLOAT64_DATA_TYPE
    (136) data_type -> . BOOLEAN_DATA_TYPE
    (137) data_type -> . STRING_DATA_TYPE

    INTEGER_DATA_TYPE shift and go to state 104
    FLOAT32_DATA_TYPE shift and go to state 105
    FLOAT64_DATA_TYPE shift and go to state 106
    BOOLEAN_DATA_TYPE shift and go to state 107
    STRING_DATA_TYPE shift and go to state 108

    data_type                      shift and go to state 200

state 155

    (120) def_function -> FUNC IDENTIFIER LPAREN parameters . RPAREN LKEY program RKEY
    (123) parameters -> parameters . COMMA parameter

    RPAREN          shift and go to state 201
    COMMA           shift and go to state 202


state 156

    (122) parameters -> parameter .

    RPAREN          reduce using rule 122 (parameters -> parameter .)
    COMMA           reduce using rule 122 (parameters -> parameter .)


state 157

    (121) call_function -> IDENTIFIER LPAREN values RPAREN .
    (24) function_call -> IDENTIFIER LPAREN values RPAREN .

  ! reduce/reduce conflict for FMT_LIBRARY resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for INPUT resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for VAR resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for CONST resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for SWITCH resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for STRING resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for INTEGER resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for RKEY resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for CASE resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PLUS            reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MINUS           reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    DIVIDE          reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    TIMES           reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    ENTERE_DIVIDE   reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MODULE          reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    EQUALEQUAL      reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    NOT_EQUAL       reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS_EQUAL      reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER_EQUAL   reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS            reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER         reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_AND     reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_OR      reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FMT_LIBRARY     reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FUNC            reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INPUT           reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    SWITCH          reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING          reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER         reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FLOAT32         reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FLOAT64         reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN         reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BREAK           reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    $end            reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RKEY            reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CASE            reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DEFAULT         reduce using rule 24 (function_call -> IDENTIFIER LPAREN values RPAREN .)

  ! FMT_LIBRARY     [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FUNC            [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! IDENTIFIER      [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! INPUT           [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! VAR             [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! CONST           [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! IF              [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! SWITCH          [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FOR             [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! STRING          [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! INTEGER         [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FLOAT32         [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! FLOAT64         [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! BOOLEAN         [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! BREAK           [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! $end            [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! RKEY            [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! CASE            [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]
  ! DEFAULT         [ reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .) ]


state 158

    (126) values -> values COMMA . value
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 203

state 159

    (139) input -> INPUT LPAREN value RPAREN .

    FMT_LIBRARY     reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    FUNC            reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    IDENTIFIER      reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    INPUT           reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    VAR             reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    CONST           reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    IF              reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    SWITCH          reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    FOR             reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    STRING          reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    INTEGER         reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    FLOAT32         reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    FLOAT64         reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    BOOLEAN         reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    BREAK           reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    $end            reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    RKEY            reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    CASE            reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)
    DEFAULT         reduce using rule 139 (input -> INPUT LPAREN value RPAREN .)


state 160

    (140) input -> INPUT LPAREN identifiers RPAREN .

    FMT_LIBRARY     reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    FUNC            reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    IDENTIFIER      reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    INPUT           reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    VAR             reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    CONST           reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    IF              reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    SWITCH          reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    FOR             reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    STRING          reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    INTEGER         reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    FLOAT32         reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    FLOAT64         reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    BOOLEAN         reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    BREAK           reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    $end            reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    RKEY            reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    CASE            reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)
    DEFAULT         reduce using rule 140 (input -> INPUT LPAREN identifiers RPAREN .)


state 161

    (107) identifiers -> identifiers COMMA . identifiers
    (106) identifiers -> . IDENTIFIER
    (107) identifiers -> . identifiers COMMA identifiers

    IDENTIFIER      shift and go to state 205

    identifiers                    shift and go to state 204

state 162

    (74) assignment -> VAR IDENTIFIER data_type EQUAL . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 206
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 163

    (75) assignment -> CONST IDENTIFIER data_type EQUAL . usable_value
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    IDENTIFIER      shift and go to state 81
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    usable_value                   shift and go to state 207
    value                          shift and go to state 20
    call_function                  shift and go to state 80
    arithmetic_operation           shift and go to state 82
    comparation_operation          shift and go to state 30

state 164

    (25) if_statement -> IF rule_comparation LKEY program . RKEY
    (26) if_statement -> IF rule_comparation LKEY program . RKEY ELSE LKEY program RKEY
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 208
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    sentencia                      shift and go to state 38
    loop                           shift and go to state 39
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 165

    (27) if_statement -> IF value LKEY program . RKEY
    (28) if_statement -> IF value LKEY program . RKEY ELSE LKEY program RKEY
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 209
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    value                          shift and go to state 20
    sentencia                      shift and go to state 38
    loop                           shift and go to state 39
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 166

    (108) rule_comparation -> IDENTIFIER EQUALEQUAL value .

    LKEY            reduce using rule 108 (rule_comparation -> IDENTIFIER EQUALEQUAL value .)


state 167

    (109) rule_comparation -> IDENTIFIER NOT_EQUAL value .

    LKEY            reduce using rule 109 (rule_comparation -> IDENTIFIER NOT_EQUAL value .)


state 168

    (110) rule_comparation -> IDENTIFIER LESS_EQUAL value .

    LKEY            reduce using rule 110 (rule_comparation -> IDENTIFIER LESS_EQUAL value .)


state 169

    (111) rule_comparation -> IDENTIFIER GREATER_EQUAL value .

    LKEY            reduce using rule 111 (rule_comparation -> IDENTIFIER GREATER_EQUAL value .)


state 170

    (112) rule_comparation -> IDENTIFIER LESS value .

    LKEY            reduce using rule 112 (rule_comparation -> IDENTIFIER LESS value .)


state 171

    (113) rule_comparation -> IDENTIFIER GREATER value .

    LKEY            reduce using rule 113 (rule_comparation -> IDENTIFIER GREATER value .)


state 172

    (114) rule_comparation -> IDENTIFIER LOGICAL_AND value .

    LKEY            reduce using rule 114 (rule_comparation -> IDENTIFIER LOGICAL_AND value .)


state 173

    (115) rule_comparation -> IDENTIFIER LOGICAL_OR value .

    LKEY            reduce using rule 115 (rule_comparation -> IDENTIFIER LOGICAL_OR value .)


state 174

    (29) switch_statement -> SWITCH expression LKEY case_clauses . RKEY
    (30) switch_statement -> SWITCH expression LKEY case_clauses . DEFAULT COLON statements RKEY

    RKEY            shift and go to state 210
    DEFAULT         shift and go to state 211


state 175

    (31) case_clauses -> case_clause . case_clauses
    (31) case_clauses -> . case_clause case_clauses
    (32) case_clauses -> .
    (33) case_clause -> . CASE value COLON statements

    RKEY            reduce using rule 32 (case_clauses -> .)
    DEFAULT         reduce using rule 32 (case_clauses -> .)
    CASE            shift and go to state 176

    case_clause                    shift and go to state 175
    case_clauses                   shift and go to state 212

state 176

    (33) case_clause -> CASE . value COLON statements
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35
    IDENTIFIER      shift and go to state 76

    value                          shift and go to state 213

state 177

    (50) expression -> expression PLUS expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 50 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! MODULE          [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! EQUALEQUAL      [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! NOT_EQUAL       [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! LESS_EQUAL      [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! LESS            [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! GREATER         [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 50 (expression -> expression PLUS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 50 (expression -> expression PLUS expression .) ]


state 178

    (51) expression -> expression MINUS expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 51 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! MODULE          [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! EQUALEQUAL      [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! NOT_EQUAL       [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! LESS_EQUAL      [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! LESS            [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! GREATER         [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 51 (expression -> expression MINUS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 51 (expression -> expression MINUS expression .) ]


state 179

    (52) expression -> expression TIMES expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 52 (expression -> expression TIMES expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! TIMES           [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! MODULE          [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! EQUALEQUAL      [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! NOT_EQUAL       [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! LESS_EQUAL      [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! LESS            [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! GREATER         [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! LOGICAL_AND     [ reduce using rule 52 (expression -> expression TIMES expression .) ]
  ! LOGICAL_OR      [ reduce using rule 52 (expression -> expression TIMES expression .) ]


state 180

    (53) expression -> expression DIVIDE expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 53 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! MODULE          [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! EQUALEQUAL      [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! NOT_EQUAL       [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! LESS_EQUAL      [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! LESS            [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! GREATER         [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! LOGICAL_AND     [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]
  ! LOGICAL_OR      [ reduce using rule 53 (expression -> expression DIVIDE expression .) ]


state 181

    (54) expression -> expression ENTERE_DIVIDE expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! MODULE          [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! EQUALEQUAL      [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! NOT_EQUAL       [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! LESS_EQUAL      [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! LESS            [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! GREATER         [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! LOGICAL_AND     [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]
  ! LOGICAL_OR      [ reduce using rule 54 (expression -> expression ENTERE_DIVIDE expression .) ]


state 182

    (55) expression -> expression MODULE expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 55 (expression -> expression MODULE expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! MINUS           [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! TIMES           [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! DIVIDE          [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! MODULE          [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! EQUALEQUAL      [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! NOT_EQUAL       [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! LESS_EQUAL      [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! LESS            [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! GREATER         [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! LOGICAL_AND     [ reduce using rule 55 (expression -> expression MODULE expression .) ]
  ! LOGICAL_OR      [ reduce using rule 55 (expression -> expression MODULE expression .) ]


state 183

    (56) expression -> expression EQUALEQUAL expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 56 (expression -> expression EQUALEQUAL expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! MINUS           [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! TIMES           [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! MODULE          [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! EQUALEQUAL      [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! LESS            [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! GREATER         [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! LOGICAL_AND     [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]
  ! LOGICAL_OR      [ reduce using rule 56 (expression -> expression EQUALEQUAL expression .) ]


state 184

    (57) expression -> expression NOT_EQUAL expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 57 (expression -> expression NOT_EQUAL expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! EQUALEQUAL      [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! LESS            [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! LOGICAL_AND     [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]
  ! LOGICAL_OR      [ reduce using rule 57 (expression -> expression NOT_EQUAL expression .) ]


state 185

    (58) expression -> expression LESS_EQUAL expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 58 (expression -> expression LESS_EQUAL expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! EQUALEQUAL      [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! LESS            [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! LOGICAL_AND     [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]
  ! LOGICAL_OR      [ reduce using rule 58 (expression -> expression LESS_EQUAL expression .) ]


state 186

    (59) expression -> expression GREATER_EQUAL expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 59 (expression -> expression GREATER_EQUAL expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! MODULE          [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! EQUALEQUAL      [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! LESS            [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! LOGICAL_AND     [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]
  ! LOGICAL_OR      [ reduce using rule 59 (expression -> expression GREATER_EQUAL expression .) ]


state 187

    (60) expression -> expression LESS expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 60 (expression -> expression LESS expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! MINUS           [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! TIMES           [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! DIVIDE          [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! MODULE          [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! EQUALEQUAL      [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! NOT_EQUAL       [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! LESS_EQUAL      [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! LESS            [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! GREATER         [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! LOGICAL_AND     [ reduce using rule 60 (expression -> expression LESS expression .) ]
  ! LOGICAL_OR      [ reduce using rule 60 (expression -> expression LESS expression .) ]


state 188

    (61) expression -> expression GREATER expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 61 (expression -> expression GREATER expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! MINUS           [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! TIMES           [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! DIVIDE          [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! MODULE          [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! EQUALEQUAL      [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! NOT_EQUAL       [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! LESS_EQUAL      [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! LESS            [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! GREATER         [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! LOGICAL_AND     [ reduce using rule 61 (expression -> expression GREATER expression .) ]
  ! LOGICAL_OR      [ reduce using rule 61 (expression -> expression GREATER expression .) ]


state 189

    (62) expression -> expression LOGICAL_AND expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 62 (expression -> expression LOGICAL_AND expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! MINUS           [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! TIMES           [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! DIVIDE          [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! MODULE          [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! EQUALEQUAL      [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! NOT_EQUAL       [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! LESS_EQUAL      [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! LESS            [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! GREATER         [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! LOGICAL_AND     [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]
  ! LOGICAL_OR      [ reduce using rule 62 (expression -> expression LOGICAL_AND expression .) ]


state 190

    (63) expression -> expression LOGICAL_OR expression .
    (50) expression -> expression . PLUS expression
    (51) expression -> expression . MINUS expression
    (52) expression -> expression . TIMES expression
    (53) expression -> expression . DIVIDE expression
    (54) expression -> expression . ENTERE_DIVIDE expression
    (55) expression -> expression . MODULE expression
    (56) expression -> expression . EQUALEQUAL expression
    (57) expression -> expression . NOT_EQUAL expression
    (58) expression -> expression . LESS_EQUAL expression
    (59) expression -> expression . GREATER_EQUAL expression
    (60) expression -> expression . LESS expression
    (61) expression -> expression . GREATER expression
    (62) expression -> expression . LOGICAL_AND expression
    (63) expression -> expression . LOGICAL_OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for ENTERE_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQUALEQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    LKEY            reduce using rule 63 (expression -> expression LOGICAL_OR expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 138
    ENTERE_DIVIDE   shift and go to state 139
    MODULE          shift and go to state 140
    EQUALEQUAL      shift and go to state 141
    NOT_EQUAL       shift and go to state 142
    LESS_EQUAL      shift and go to state 143
    GREATER_EQUAL   shift and go to state 144
    LESS            shift and go to state 145
    GREATER         shift and go to state 146
    LOGICAL_AND     shift and go to state 147
    LOGICAL_OR      shift and go to state 148

  ! PLUS            [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! MINUS           [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! TIMES           [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! DIVIDE          [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! ENTERE_DIVIDE   [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! MODULE          [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! EQUALEQUAL      [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! NOT_EQUAL       [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! LESS_EQUAL      [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! LESS            [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! GREATER         [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! LOGICAL_AND     [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]
  ! LOGICAL_OR      [ reduce using rule 63 (expression -> expression LOGICAL_OR expression .) ]


state 191

    (22) for -> FOR LKEY loop_program RKEY .

    FMT_LIBRARY     reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    FUNC            reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    IDENTIFIER      reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    INPUT           reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    VAR             reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    CONST           reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    IF              reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    SWITCH          reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    FOR             reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    STRING          reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    INTEGER         reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    FLOAT32         reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    FLOAT64         reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    BOOLEAN         reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    BREAK           reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    $end            reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)
    RKEY            reduce using rule 22 (for -> FOR LKEY loop_program RKEY .)


state 192

    (23) for -> FOR comparation_operation LKEY loop_program . RKEY
    (3) loop_program -> loop_program . program
    (4) loop_program -> loop_program . BREAK
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 214
    BREAK           shift and go to state 37
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    comparation_operation          shift and go to state 30
    program                        shift and go to state 36
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25

state 193

    (121) call_function -> IDENTIFIER LPAREN values . RPAREN
    (126) values -> values . COMMA value

    RPAREN          shift and go to state 215
    COMMA           shift and go to state 158


state 194

    (64) print -> FMT_LIBRARY DOT PRINTLN LPAREN data . RPAREN
    (70) data -> data . COMMA value
    (71) data -> data . COMMA IDENTIFIER

    RPAREN          shift and go to state 216
    COMMA           shift and go to state 217


state 195

    (72) print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .

    FMT_LIBRARY     reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FUNC            reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    INPUT           reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    VAR             reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    CONST           reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    IF              reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    SWITCH          reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FOR             reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    STRING          reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    INTEGER         reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FLOAT32         reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    FLOAT64         reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    BOOLEAN         reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    BREAK           reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    $end            reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    RKEY            reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    CASE            reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)
    DEFAULT         reduce using rule 72 (print_withoutvalue -> FMT_LIBRARY DOT PRINTLN LPAREN RPAREN .)


state 196

    (68) data -> value .

    RPAREN          reduce using rule 68 (data -> value .)
    COMMA           reduce using rule 68 (data -> value .)


state 197

    (69) data -> IDENTIFIER .
    (132) value -> IDENTIFIER .

  ! reduce/reduce conflict for RPAREN resolved using rule 69 (data -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 69 (data -> IDENTIFIER .)
    RPAREN          reduce using rule 69 (data -> IDENTIFIER .)
    COMMA           reduce using rule 69 (data -> IDENTIFIER .)

  ! RPAREN          [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 132 (value -> IDENTIFIER .) ]


state 198

    (65) print -> FMT_LIBRARY DOT PRINTF LPAREN value . RPAREN
    (66) print -> FMT_LIBRARY DOT PRINTF LPAREN value . COMMA RPAREN
    (67) print -> FMT_LIBRARY DOT PRINTF LPAREN value . COMMA data RPAREN

    RPAREN          shift and go to state 218
    COMMA           shift and go to state 219


state 199

    (73) print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .

    FMT_LIBRARY     reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FUNC            reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    INPUT           reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    VAR             reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    CONST           reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    IF              reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    SWITCH          reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FOR             reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    STRING          reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    INTEGER         reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FLOAT32         reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    FLOAT64         reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    BOOLEAN         reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    BREAK           reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    $end            reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    RKEY            reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    CASE            reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)
    DEFAULT         reduce using rule 73 (print_withoutvalue -> FMT_LIBRARY DOT PRINTF LPAREN RPAREN .)


state 200

    (124) parameter -> IDENTIFIER data_type .

    RPAREN          reduce using rule 124 (parameter -> IDENTIFIER data_type .)
    COMMA           reduce using rule 124 (parameter -> IDENTIFIER data_type .)


state 201

    (120) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN . LKEY program RKEY

    LKEY            shift and go to state 220


state 202

    (123) parameters -> parameters COMMA . parameter
    (124) parameter -> . IDENTIFIER data_type

    IDENTIFIER      shift and go to state 154

    parameter                      shift and go to state 221

state 203

    (126) values -> values COMMA value .

    RPAREN          reduce using rule 126 (values -> values COMMA value .)
    COMMA           reduce using rule 126 (values -> values COMMA value .)


state 204

    (107) identifiers -> identifiers COMMA identifiers .
    (107) identifiers -> identifiers . COMMA identifiers

  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 107 (identifiers -> identifiers COMMA identifiers .)
    COMMA           shift and go to state 161

  ! COMMA           [ reduce using rule 107 (identifiers -> identifiers COMMA identifiers .) ]


state 205

    (106) identifiers -> IDENTIFIER .

    COMMA           reduce using rule 106 (identifiers -> IDENTIFIER .)
    RPAREN          reduce using rule 106 (identifiers -> IDENTIFIER .)


state 206

    (74) assignment -> VAR IDENTIFIER data_type EQUAL usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

    FMT_LIBRARY     reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    FUNC            reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    IDENTIFIER      reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    INPUT           reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    VAR             reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    CONST           reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    IF              reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    SWITCH          reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    FOR             reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    STRING          reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    INTEGER         reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    FLOAT32         reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    FLOAT64         reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    BOOLEAN         reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    BREAK           reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    $end            reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    RKEY            reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    CASE            reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    DEFAULT         reduce using rule 74 (assignment -> VAR IDENTIFIER data_type EQUAL usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69


state 207

    (75) assignment -> CONST IDENTIFIER data_type EQUAL usable_value .
    (92) arithmetic_operation -> usable_value . PLUS usable_value
    (93) arithmetic_operation -> usable_value . MINUS usable_value
    (94) arithmetic_operation -> usable_value . DIVIDE usable_value
    (95) arithmetic_operation -> usable_value . TIMES usable_value
    (96) arithmetic_operation -> usable_value . ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> usable_value . MODULE usable_value
    (98) comparation_operation -> usable_value . EQUALEQUAL usable_value
    (99) comparation_operation -> usable_value . NOT_EQUAL usable_value
    (100) comparation_operation -> usable_value . LESS_EQUAL usable_value
    (101) comparation_operation -> usable_value . GREATER_EQUAL usable_value
    (102) comparation_operation -> usable_value . LESS usable_value
    (103) comparation_operation -> usable_value . GREATER usable_value
    (104) comparation_operation -> usable_value . LOGICAL_AND usable_value
    (105) comparation_operation -> usable_value . LOGICAL_OR usable_value

    FMT_LIBRARY     reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    FUNC            reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    IDENTIFIER      reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    INPUT           reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    VAR             reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    CONST           reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    IF              reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    SWITCH          reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    FOR             reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    STRING          reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    INTEGER         reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    FLOAT32         reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    FLOAT64         reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    BOOLEAN         reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    BREAK           reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    $end            reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    RKEY            reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    CASE            reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    DEFAULT         reduce using rule 75 (assignment -> CONST IDENTIFIER data_type EQUAL usable_value .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    DIVIDE          shift and go to state 58
    TIMES           shift and go to state 59
    ENTERE_DIVIDE   shift and go to state 60
    MODULE          shift and go to state 61
    EQUALEQUAL      shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    LESS_EQUAL      shift and go to state 64
    GREATER_EQUAL   shift and go to state 65
    LESS            shift and go to state 66
    GREATER         shift and go to state 67
    LOGICAL_AND     shift and go to state 68
    LOGICAL_OR      shift and go to state 69


state 208

    (25) if_statement -> IF rule_comparation LKEY program RKEY .
    (26) if_statement -> IF rule_comparation LKEY program RKEY . ELSE LKEY program RKEY

    FMT_LIBRARY     reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    FUNC            reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    IDENTIFIER      reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    INPUT           reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    VAR             reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    CONST           reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    IF              reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    SWITCH          reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    FOR             reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    STRING          reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    INTEGER         reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    FLOAT32         reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    FLOAT64         reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    BOOLEAN         reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    BREAK           reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    $end            reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    RKEY            reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    CASE            reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    DEFAULT         reduce using rule 25 (if_statement -> IF rule_comparation LKEY program RKEY .)
    ELSE            shift and go to state 222


state 209

    (27) if_statement -> IF value LKEY program RKEY .
    (28) if_statement -> IF value LKEY program RKEY . ELSE LKEY program RKEY

    FMT_LIBRARY     reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    FUNC            reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    IDENTIFIER      reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    INPUT           reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    VAR             reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    CONST           reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    IF              reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    SWITCH          reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    FOR             reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    STRING          reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    INTEGER         reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    FLOAT32         reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    FLOAT64         reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    BOOLEAN         reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    BREAK           reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    $end            reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    RKEY            reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    CASE            reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    DEFAULT         reduce using rule 27 (if_statement -> IF value LKEY program RKEY .)
    ELSE            shift and go to state 223


state 210

    (29) switch_statement -> SWITCH expression LKEY case_clauses RKEY .

    FMT_LIBRARY     reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    FUNC            reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    IDENTIFIER      reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    INPUT           reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    VAR             reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    CONST           reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    IF              reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    SWITCH          reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    FOR             reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    STRING          reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    INTEGER         reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    FLOAT32         reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    FLOAT64         reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    BOOLEAN         reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    BREAK           reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    $end            reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    RKEY            reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    CASE            reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)
    DEFAULT         reduce using rule 29 (switch_statement -> SWITCH expression LKEY case_clauses RKEY .)


state 211

    (30) switch_statement -> SWITCH expression LKEY case_clauses DEFAULT . COLON statements RKEY

    COLON           shift and go to state 224


state 212

    (31) case_clauses -> case_clause case_clauses .

    RKEY            reduce using rule 31 (case_clauses -> case_clause case_clauses .)
    DEFAULT         reduce using rule 31 (case_clauses -> case_clause case_clauses .)


state 213

    (33) case_clause -> CASE value . COLON statements

    COLON           shift and go to state 225


state 214

    (23) for -> FOR comparation_operation LKEY loop_program RKEY .

    FMT_LIBRARY     reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FUNC            reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    IDENTIFIER      reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    INPUT           reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    VAR             reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    CONST           reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    IF              reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    SWITCH          reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FOR             reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    STRING          reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    INTEGER         reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FLOAT32         reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    FLOAT64         reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    BOOLEAN         reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    BREAK           reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    $end            reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)
    RKEY            reduce using rule 23 (for -> FOR comparation_operation LKEY loop_program RKEY .)


state 215

    (121) call_function -> IDENTIFIER LPAREN values RPAREN .

    EQUALEQUAL      reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    NOT_EQUAL       reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS_EQUAL      reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER_EQUAL   reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LESS            reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    GREATER         reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_AND     reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_OR      reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    PLUS            reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MINUS           reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    DIVIDE          reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    TIMES           reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    ENTERE_DIVIDE   reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    MODULE          reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FMT_LIBRARY     reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FUNC            reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    INPUT           reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    SWITCH          reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    STRING          reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER         reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FLOAT32         reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    FLOAT64         reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN         reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    BREAK           reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    $end            reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    RKEY            reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    CASE            reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    DEFAULT         reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)
    LKEY            reduce using rule 121 (call_function -> IDENTIFIER LPAREN values RPAREN .)


state 216

    (64) print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .

    FMT_LIBRARY     reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FUNC            reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    IDENTIFIER      reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    INPUT           reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    VAR             reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    CONST           reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    IF              reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    SWITCH          reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FOR             reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    STRING          reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    INTEGER         reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FLOAT32         reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    FLOAT64         reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    BOOLEAN         reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    BREAK           reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    $end            reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    RKEY            reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    CASE            reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)
    DEFAULT         reduce using rule 64 (print -> FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN .)


state 217

    (70) data -> data COMMA . value
    (71) data -> data COMMA . IDENTIFIER
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    IDENTIFIER      shift and go to state 227
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    value                          shift and go to state 226

state 218

    (65) print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .

    FMT_LIBRARY     reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    FUNC            reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    IDENTIFIER      reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    INPUT           reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    VAR             reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    CONST           reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    IF              reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    SWITCH          reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    FOR             reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    STRING          reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    INTEGER         reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    FLOAT32         reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    FLOAT64         reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    BOOLEAN         reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    BREAK           reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    $end            reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    RKEY            reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    CASE            reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)
    DEFAULT         reduce using rule 65 (print -> FMT_LIBRARY DOT PRINTF LPAREN value RPAREN .)


state 219

    (66) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA . RPAREN
    (67) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA . data RPAREN
    (68) data -> . value
    (69) data -> . IDENTIFIER
    (70) data -> . data COMMA value
    (71) data -> . data COMMA IDENTIFIER
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER

    RPAREN          shift and go to state 228
    IDENTIFIER      shift and go to state 197
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    value                          shift and go to state 196
    data                           shift and go to state 229

state 220

    (120) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY . program RKEY
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    program                        shift and go to state 230
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 221

    (123) parameters -> parameters COMMA parameter .

    RPAREN          reduce using rule 123 (parameters -> parameters COMMA parameter .)
    COMMA           reduce using rule 123 (parameters -> parameters COMMA parameter .)


state 222

    (26) if_statement -> IF rule_comparation LKEY program RKEY ELSE . LKEY program RKEY

    LKEY            shift and go to state 231


state 223

    (28) if_statement -> IF value LKEY program RKEY ELSE . LKEY program RKEY

    LKEY            shift and go to state 232


state 224

    (30) switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON . statements RKEY
    (34) statements -> . statement statements
    (35) statements -> .
    (36) statement -> . print
    (37) statement -> . print_withoutvalue
    (38) statement -> . def_function
    (39) statement -> . call_function
    (40) statement -> . input
    (41) statement -> . assignment
    (42) statement -> . short_assignment
    (43) statement -> . arithmetic_operation
    (44) statement -> . direct_arithmetic_operation
    (45) statement -> . if_statement
    (46) statement -> . function_call
    (47) statement -> . switch_statement
    (48) statement -> . statement
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            reduce using rule 35 (statements -> .)
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    statements                     shift and go to state 233
    statement                      shift and go to state 234
    print                          shift and go to state 235
    print_withoutvalue             shift and go to state 236
    def_function                   shift and go to state 237
    call_function                  shift and go to state 238
    input                          shift and go to state 239
    assignment                     shift and go to state 240
    short_assignment               shift and go to state 241
    arithmetic_operation           shift and go to state 242
    direct_arithmetic_operation    shift and go to state 243
    if_statement                   shift and go to state 244
    function_call                  shift and go to state 245
    switch_statement               shift and go to state 246
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 225

    (33) case_clause -> CASE value COLON . statements
    (34) statements -> . statement statements
    (35) statements -> .
    (36) statement -> . print
    (37) statement -> . print_withoutvalue
    (38) statement -> . def_function
    (39) statement -> . call_function
    (40) statement -> . input
    (41) statement -> . assignment
    (42) statement -> . short_assignment
    (43) statement -> . arithmetic_operation
    (44) statement -> . direct_arithmetic_operation
    (45) statement -> . if_statement
    (46) statement -> . function_call
    (47) statement -> . switch_statement
    (48) statement -> . statement
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    CASE            reduce using rule 35 (statements -> .)
    RKEY            reduce using rule 35 (statements -> .)
    DEFAULT         reduce using rule 35 (statements -> .)
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    value                          shift and go to state 20
    statements                     shift and go to state 247
    statement                      shift and go to state 234
    print                          shift and go to state 235
    print_withoutvalue             shift and go to state 236
    def_function                   shift and go to state 237
    call_function                  shift and go to state 238
    input                          shift and go to state 239
    assignment                     shift and go to state 240
    short_assignment               shift and go to state 241
    arithmetic_operation           shift and go to state 242
    direct_arithmetic_operation    shift and go to state 243
    if_statement                   shift and go to state 244
    function_call                  shift and go to state 245
    switch_statement               shift and go to state 246
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 226

    (70) data -> data COMMA value .

    RPAREN          reduce using rule 70 (data -> data COMMA value .)
    COMMA           reduce using rule 70 (data -> data COMMA value .)


state 227

    (71) data -> data COMMA IDENTIFIER .
    (132) value -> IDENTIFIER .

  ! reduce/reduce conflict for RPAREN resolved using rule 71 (data -> data COMMA IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 71 (data -> data COMMA IDENTIFIER .)
    RPAREN          reduce using rule 71 (data -> data COMMA IDENTIFIER .)
    COMMA           reduce using rule 71 (data -> data COMMA IDENTIFIER .)

  ! RPAREN          [ reduce using rule 132 (value -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 132 (value -> IDENTIFIER .) ]


state 228

    (66) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .

    FMT_LIBRARY     reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    FUNC            reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    IDENTIFIER      reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    INPUT           reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    VAR             reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    CONST           reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    IF              reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    SWITCH          reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    FOR             reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    STRING          reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    INTEGER         reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    FLOAT32         reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    FLOAT64         reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    BOOLEAN         reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    BREAK           reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    $end            reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    RKEY            reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    CASE            reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)
    DEFAULT         reduce using rule 66 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN .)


state 229

    (67) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data . RPAREN
    (70) data -> data . COMMA value
    (71) data -> data . COMMA IDENTIFIER

    RPAREN          shift and go to state 248
    COMMA           shift and go to state 217


state 230

    (120) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program . RKEY
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 249
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    sentencia                      shift and go to state 38
    loop                           shift and go to state 39
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 231

    (26) if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY . program RKEY
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    program                        shift and go to state 250
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 232

    (28) if_statement -> IF value LKEY program RKEY ELSE LKEY . program RKEY
    (5) program -> . sentencia
    (6) program -> . loop
    (7) program -> . program sentencia
    (8) program -> . program loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    value                          shift and go to state 20
    program                        shift and go to state 251
    sentencia                      shift and go to state 4
    loop                           shift and go to state 5
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 233

    (30) switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements . RKEY

    RKEY            shift and go to state 252


state 234

    (34) statements -> statement . statements
    (48) statement -> statement .
    (34) statements -> . statement statements
    (35) statements -> .
    (36) statement -> . print
    (37) statement -> . print_withoutvalue
    (38) statement -> . def_function
    (39) statement -> . call_function
    (40) statement -> . input
    (41) statement -> . assignment
    (42) statement -> . short_assignment
    (43) statement -> . arithmetic_operation
    (44) statement -> . direct_arithmetic_operation
    (45) statement -> . if_statement
    (46) statement -> . function_call
    (47) statement -> . switch_statement
    (48) statement -> . statement
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

  ! reduce/reduce conflict for RKEY resolved using rule 35 (statements -> .)
  ! reduce/reduce conflict for CASE resolved using rule 35 (statements -> .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 35 (statements -> .)
  ! shift/reduce conflict for FMT_LIBRARY resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT32 resolved as shift
  ! shift/reduce conflict for FLOAT64 resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RKEY            reduce using rule 35 (statements -> .)
    CASE            reduce using rule 35 (statements -> .)
    DEFAULT         reduce using rule 35 (statements -> .)
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

  ! FMT_LIBRARY     [ reduce using rule 48 (statement -> statement .) ]
  ! FUNC            [ reduce using rule 48 (statement -> statement .) ]
  ! IDENTIFIER      [ reduce using rule 48 (statement -> statement .) ]
  ! INPUT           [ reduce using rule 48 (statement -> statement .) ]
  ! VAR             [ reduce using rule 48 (statement -> statement .) ]
  ! CONST           [ reduce using rule 48 (statement -> statement .) ]
  ! IF              [ reduce using rule 48 (statement -> statement .) ]
  ! SWITCH          [ reduce using rule 48 (statement -> statement .) ]
  ! STRING          [ reduce using rule 48 (statement -> statement .) ]
  ! INTEGER         [ reduce using rule 48 (statement -> statement .) ]
  ! FLOAT32         [ reduce using rule 48 (statement -> statement .) ]
  ! FLOAT64         [ reduce using rule 48 (statement -> statement .) ]
  ! BOOLEAN         [ reduce using rule 48 (statement -> statement .) ]
  ! RKEY            [ reduce using rule 48 (statement -> statement .) ]
  ! CASE            [ reduce using rule 48 (statement -> statement .) ]
  ! DEFAULT         [ reduce using rule 48 (statement -> statement .) ]

    statement                      shift and go to state 234
    statements                     shift and go to state 253
    print                          shift and go to state 235
    print_withoutvalue             shift and go to state 236
    def_function                   shift and go to state 237
    call_function                  shift and go to state 238
    input                          shift and go to state 239
    assignment                     shift and go to state 240
    short_assignment               shift and go to state 241
    arithmetic_operation           shift and go to state 242
    direct_arithmetic_operation    shift and go to state 243
    if_statement                   shift and go to state 244
    function_call                  shift and go to state 245
    switch_statement               shift and go to state 246
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 235

    (36) statement -> print .

    FMT_LIBRARY     reduce using rule 36 (statement -> print .)
    FUNC            reduce using rule 36 (statement -> print .)
    IDENTIFIER      reduce using rule 36 (statement -> print .)
    INPUT           reduce using rule 36 (statement -> print .)
    VAR             reduce using rule 36 (statement -> print .)
    CONST           reduce using rule 36 (statement -> print .)
    IF              reduce using rule 36 (statement -> print .)
    SWITCH          reduce using rule 36 (statement -> print .)
    STRING          reduce using rule 36 (statement -> print .)
    INTEGER         reduce using rule 36 (statement -> print .)
    FLOAT32         reduce using rule 36 (statement -> print .)
    FLOAT64         reduce using rule 36 (statement -> print .)
    BOOLEAN         reduce using rule 36 (statement -> print .)
    RKEY            reduce using rule 36 (statement -> print .)
    CASE            reduce using rule 36 (statement -> print .)
    DEFAULT         reduce using rule 36 (statement -> print .)


state 236

    (37) statement -> print_withoutvalue .

    FMT_LIBRARY     reduce using rule 37 (statement -> print_withoutvalue .)
    FUNC            reduce using rule 37 (statement -> print_withoutvalue .)
    IDENTIFIER      reduce using rule 37 (statement -> print_withoutvalue .)
    INPUT           reduce using rule 37 (statement -> print_withoutvalue .)
    VAR             reduce using rule 37 (statement -> print_withoutvalue .)
    CONST           reduce using rule 37 (statement -> print_withoutvalue .)
    IF              reduce using rule 37 (statement -> print_withoutvalue .)
    SWITCH          reduce using rule 37 (statement -> print_withoutvalue .)
    STRING          reduce using rule 37 (statement -> print_withoutvalue .)
    INTEGER         reduce using rule 37 (statement -> print_withoutvalue .)
    FLOAT32         reduce using rule 37 (statement -> print_withoutvalue .)
    FLOAT64         reduce using rule 37 (statement -> print_withoutvalue .)
    BOOLEAN         reduce using rule 37 (statement -> print_withoutvalue .)
    RKEY            reduce using rule 37 (statement -> print_withoutvalue .)
    CASE            reduce using rule 37 (statement -> print_withoutvalue .)
    DEFAULT         reduce using rule 37 (statement -> print_withoutvalue .)


state 237

    (38) statement -> def_function .

    FMT_LIBRARY     reduce using rule 38 (statement -> def_function .)
    FUNC            reduce using rule 38 (statement -> def_function .)
    IDENTIFIER      reduce using rule 38 (statement -> def_function .)
    INPUT           reduce using rule 38 (statement -> def_function .)
    VAR             reduce using rule 38 (statement -> def_function .)
    CONST           reduce using rule 38 (statement -> def_function .)
    IF              reduce using rule 38 (statement -> def_function .)
    SWITCH          reduce using rule 38 (statement -> def_function .)
    STRING          reduce using rule 38 (statement -> def_function .)
    INTEGER         reduce using rule 38 (statement -> def_function .)
    FLOAT32         reduce using rule 38 (statement -> def_function .)
    FLOAT64         reduce using rule 38 (statement -> def_function .)
    BOOLEAN         reduce using rule 38 (statement -> def_function .)
    RKEY            reduce using rule 38 (statement -> def_function .)
    CASE            reduce using rule 38 (statement -> def_function .)
    DEFAULT         reduce using rule 38 (statement -> def_function .)


state 238

    (39) statement -> call_function .
    (78) usable_value -> call_function .

    FMT_LIBRARY     reduce using rule 39 (statement -> call_function .)
    FUNC            reduce using rule 39 (statement -> call_function .)
    IDENTIFIER      reduce using rule 39 (statement -> call_function .)
    INPUT           reduce using rule 39 (statement -> call_function .)
    VAR             reduce using rule 39 (statement -> call_function .)
    CONST           reduce using rule 39 (statement -> call_function .)
    IF              reduce using rule 39 (statement -> call_function .)
    SWITCH          reduce using rule 39 (statement -> call_function .)
    STRING          reduce using rule 39 (statement -> call_function .)
    INTEGER         reduce using rule 39 (statement -> call_function .)
    FLOAT32         reduce using rule 39 (statement -> call_function .)
    FLOAT64         reduce using rule 39 (statement -> call_function .)
    BOOLEAN         reduce using rule 39 (statement -> call_function .)
    RKEY            reduce using rule 39 (statement -> call_function .)
    CASE            reduce using rule 39 (statement -> call_function .)
    DEFAULT         reduce using rule 39 (statement -> call_function .)
    PLUS            reduce using rule 78 (usable_value -> call_function .)
    MINUS           reduce using rule 78 (usable_value -> call_function .)
    DIVIDE          reduce using rule 78 (usable_value -> call_function .)
    TIMES           reduce using rule 78 (usable_value -> call_function .)
    ENTERE_DIVIDE   reduce using rule 78 (usable_value -> call_function .)
    MODULE          reduce using rule 78 (usable_value -> call_function .)
    EQUALEQUAL      reduce using rule 78 (usable_value -> call_function .)
    NOT_EQUAL       reduce using rule 78 (usable_value -> call_function .)
    LESS_EQUAL      reduce using rule 78 (usable_value -> call_function .)
    GREATER_EQUAL   reduce using rule 78 (usable_value -> call_function .)
    LESS            reduce using rule 78 (usable_value -> call_function .)
    GREATER         reduce using rule 78 (usable_value -> call_function .)
    LOGICAL_AND     reduce using rule 78 (usable_value -> call_function .)
    LOGICAL_OR      reduce using rule 78 (usable_value -> call_function .)


state 239

    (40) statement -> input .

    FMT_LIBRARY     reduce using rule 40 (statement -> input .)
    FUNC            reduce using rule 40 (statement -> input .)
    IDENTIFIER      reduce using rule 40 (statement -> input .)
    INPUT           reduce using rule 40 (statement -> input .)
    VAR             reduce using rule 40 (statement -> input .)
    CONST           reduce using rule 40 (statement -> input .)
    IF              reduce using rule 40 (statement -> input .)
    SWITCH          reduce using rule 40 (statement -> input .)
    STRING          reduce using rule 40 (statement -> input .)
    INTEGER         reduce using rule 40 (statement -> input .)
    FLOAT32         reduce using rule 40 (statement -> input .)
    FLOAT64         reduce using rule 40 (statement -> input .)
    BOOLEAN         reduce using rule 40 (statement -> input .)
    RKEY            reduce using rule 40 (statement -> input .)
    CASE            reduce using rule 40 (statement -> input .)
    DEFAULT         reduce using rule 40 (statement -> input .)


state 240

    (41) statement -> assignment .

    FMT_LIBRARY     reduce using rule 41 (statement -> assignment .)
    FUNC            reduce using rule 41 (statement -> assignment .)
    IDENTIFIER      reduce using rule 41 (statement -> assignment .)
    INPUT           reduce using rule 41 (statement -> assignment .)
    VAR             reduce using rule 41 (statement -> assignment .)
    CONST           reduce using rule 41 (statement -> assignment .)
    IF              reduce using rule 41 (statement -> assignment .)
    SWITCH          reduce using rule 41 (statement -> assignment .)
    STRING          reduce using rule 41 (statement -> assignment .)
    INTEGER         reduce using rule 41 (statement -> assignment .)
    FLOAT32         reduce using rule 41 (statement -> assignment .)
    FLOAT64         reduce using rule 41 (statement -> assignment .)
    BOOLEAN         reduce using rule 41 (statement -> assignment .)
    RKEY            reduce using rule 41 (statement -> assignment .)
    CASE            reduce using rule 41 (statement -> assignment .)
    DEFAULT         reduce using rule 41 (statement -> assignment .)


state 241

    (42) statement -> short_assignment .

    FMT_LIBRARY     reduce using rule 42 (statement -> short_assignment .)
    FUNC            reduce using rule 42 (statement -> short_assignment .)
    IDENTIFIER      reduce using rule 42 (statement -> short_assignment .)
    INPUT           reduce using rule 42 (statement -> short_assignment .)
    VAR             reduce using rule 42 (statement -> short_assignment .)
    CONST           reduce using rule 42 (statement -> short_assignment .)
    IF              reduce using rule 42 (statement -> short_assignment .)
    SWITCH          reduce using rule 42 (statement -> short_assignment .)
    STRING          reduce using rule 42 (statement -> short_assignment .)
    INTEGER         reduce using rule 42 (statement -> short_assignment .)
    FLOAT32         reduce using rule 42 (statement -> short_assignment .)
    FLOAT64         reduce using rule 42 (statement -> short_assignment .)
    BOOLEAN         reduce using rule 42 (statement -> short_assignment .)
    RKEY            reduce using rule 42 (statement -> short_assignment .)
    CASE            reduce using rule 42 (statement -> short_assignment .)
    DEFAULT         reduce using rule 42 (statement -> short_assignment .)


state 242

    (43) statement -> arithmetic_operation .
    (80) usable_value -> arithmetic_operation .

    FMT_LIBRARY     reduce using rule 43 (statement -> arithmetic_operation .)
    FUNC            reduce using rule 43 (statement -> arithmetic_operation .)
    IDENTIFIER      reduce using rule 43 (statement -> arithmetic_operation .)
    INPUT           reduce using rule 43 (statement -> arithmetic_operation .)
    VAR             reduce using rule 43 (statement -> arithmetic_operation .)
    CONST           reduce using rule 43 (statement -> arithmetic_operation .)
    IF              reduce using rule 43 (statement -> arithmetic_operation .)
    SWITCH          reduce using rule 43 (statement -> arithmetic_operation .)
    STRING          reduce using rule 43 (statement -> arithmetic_operation .)
    INTEGER         reduce using rule 43 (statement -> arithmetic_operation .)
    FLOAT32         reduce using rule 43 (statement -> arithmetic_operation .)
    FLOAT64         reduce using rule 43 (statement -> arithmetic_operation .)
    BOOLEAN         reduce using rule 43 (statement -> arithmetic_operation .)
    RKEY            reduce using rule 43 (statement -> arithmetic_operation .)
    CASE            reduce using rule 43 (statement -> arithmetic_operation .)
    DEFAULT         reduce using rule 43 (statement -> arithmetic_operation .)
    PLUS            reduce using rule 80 (usable_value -> arithmetic_operation .)
    MINUS           reduce using rule 80 (usable_value -> arithmetic_operation .)
    DIVIDE          reduce using rule 80 (usable_value -> arithmetic_operation .)
    TIMES           reduce using rule 80 (usable_value -> arithmetic_operation .)
    ENTERE_DIVIDE   reduce using rule 80 (usable_value -> arithmetic_operation .)
    MODULE          reduce using rule 80 (usable_value -> arithmetic_operation .)
    EQUALEQUAL      reduce using rule 80 (usable_value -> arithmetic_operation .)
    NOT_EQUAL       reduce using rule 80 (usable_value -> arithmetic_operation .)
    LESS_EQUAL      reduce using rule 80 (usable_value -> arithmetic_operation .)
    GREATER_EQUAL   reduce using rule 80 (usable_value -> arithmetic_operation .)
    LESS            reduce using rule 80 (usable_value -> arithmetic_operation .)
    GREATER         reduce using rule 80 (usable_value -> arithmetic_operation .)
    LOGICAL_AND     reduce using rule 80 (usable_value -> arithmetic_operation .)
    LOGICAL_OR      reduce using rule 80 (usable_value -> arithmetic_operation .)


state 243

    (44) statement -> direct_arithmetic_operation .

    FMT_LIBRARY     reduce using rule 44 (statement -> direct_arithmetic_operation .)
    FUNC            reduce using rule 44 (statement -> direct_arithmetic_operation .)
    IDENTIFIER      reduce using rule 44 (statement -> direct_arithmetic_operation .)
    INPUT           reduce using rule 44 (statement -> direct_arithmetic_operation .)
    VAR             reduce using rule 44 (statement -> direct_arithmetic_operation .)
    CONST           reduce using rule 44 (statement -> direct_arithmetic_operation .)
    IF              reduce using rule 44 (statement -> direct_arithmetic_operation .)
    SWITCH          reduce using rule 44 (statement -> direct_arithmetic_operation .)
    STRING          reduce using rule 44 (statement -> direct_arithmetic_operation .)
    INTEGER         reduce using rule 44 (statement -> direct_arithmetic_operation .)
    FLOAT32         reduce using rule 44 (statement -> direct_arithmetic_operation .)
    FLOAT64         reduce using rule 44 (statement -> direct_arithmetic_operation .)
    BOOLEAN         reduce using rule 44 (statement -> direct_arithmetic_operation .)
    RKEY            reduce using rule 44 (statement -> direct_arithmetic_operation .)
    CASE            reduce using rule 44 (statement -> direct_arithmetic_operation .)
    DEFAULT         reduce using rule 44 (statement -> direct_arithmetic_operation .)


state 244

    (45) statement -> if_statement .

    FMT_LIBRARY     reduce using rule 45 (statement -> if_statement .)
    FUNC            reduce using rule 45 (statement -> if_statement .)
    IDENTIFIER      reduce using rule 45 (statement -> if_statement .)
    INPUT           reduce using rule 45 (statement -> if_statement .)
    VAR             reduce using rule 45 (statement -> if_statement .)
    CONST           reduce using rule 45 (statement -> if_statement .)
    IF              reduce using rule 45 (statement -> if_statement .)
    SWITCH          reduce using rule 45 (statement -> if_statement .)
    STRING          reduce using rule 45 (statement -> if_statement .)
    INTEGER         reduce using rule 45 (statement -> if_statement .)
    FLOAT32         reduce using rule 45 (statement -> if_statement .)
    FLOAT64         reduce using rule 45 (statement -> if_statement .)
    BOOLEAN         reduce using rule 45 (statement -> if_statement .)
    RKEY            reduce using rule 45 (statement -> if_statement .)
    CASE            reduce using rule 45 (statement -> if_statement .)
    DEFAULT         reduce using rule 45 (statement -> if_statement .)


state 245

    (46) statement -> function_call .

    FMT_LIBRARY     reduce using rule 46 (statement -> function_call .)
    FUNC            reduce using rule 46 (statement -> function_call .)
    IDENTIFIER      reduce using rule 46 (statement -> function_call .)
    INPUT           reduce using rule 46 (statement -> function_call .)
    VAR             reduce using rule 46 (statement -> function_call .)
    CONST           reduce using rule 46 (statement -> function_call .)
    IF              reduce using rule 46 (statement -> function_call .)
    SWITCH          reduce using rule 46 (statement -> function_call .)
    STRING          reduce using rule 46 (statement -> function_call .)
    INTEGER         reduce using rule 46 (statement -> function_call .)
    FLOAT32         reduce using rule 46 (statement -> function_call .)
    FLOAT64         reduce using rule 46 (statement -> function_call .)
    BOOLEAN         reduce using rule 46 (statement -> function_call .)
    RKEY            reduce using rule 46 (statement -> function_call .)
    CASE            reduce using rule 46 (statement -> function_call .)
    DEFAULT         reduce using rule 46 (statement -> function_call .)


state 246

    (47) statement -> switch_statement .

    FMT_LIBRARY     reduce using rule 47 (statement -> switch_statement .)
    FUNC            reduce using rule 47 (statement -> switch_statement .)
    IDENTIFIER      reduce using rule 47 (statement -> switch_statement .)
    INPUT           reduce using rule 47 (statement -> switch_statement .)
    VAR             reduce using rule 47 (statement -> switch_statement .)
    CONST           reduce using rule 47 (statement -> switch_statement .)
    IF              reduce using rule 47 (statement -> switch_statement .)
    SWITCH          reduce using rule 47 (statement -> switch_statement .)
    STRING          reduce using rule 47 (statement -> switch_statement .)
    INTEGER         reduce using rule 47 (statement -> switch_statement .)
    FLOAT32         reduce using rule 47 (statement -> switch_statement .)
    FLOAT64         reduce using rule 47 (statement -> switch_statement .)
    BOOLEAN         reduce using rule 47 (statement -> switch_statement .)
    RKEY            reduce using rule 47 (statement -> switch_statement .)
    CASE            reduce using rule 47 (statement -> switch_statement .)
    DEFAULT         reduce using rule 47 (statement -> switch_statement .)


state 247

    (33) case_clause -> CASE value COLON statements .

    CASE            reduce using rule 33 (case_clause -> CASE value COLON statements .)
    RKEY            reduce using rule 33 (case_clause -> CASE value COLON statements .)
    DEFAULT         reduce using rule 33 (case_clause -> CASE value COLON statements .)


state 248

    (67) print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .

    FMT_LIBRARY     reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    FUNC            reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    IDENTIFIER      reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    INPUT           reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    VAR             reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    CONST           reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    IF              reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    SWITCH          reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    FOR             reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    STRING          reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    INTEGER         reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    FLOAT32         reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    FLOAT64         reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    BOOLEAN         reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    BREAK           reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    $end            reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    RKEY            reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    CASE            reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)
    DEFAULT         reduce using rule 67 (print -> FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN .)


state 249

    (120) def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .

    FMT_LIBRARY     reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    FUNC            reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    IDENTIFIER      reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    INPUT           reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    VAR             reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    CONST           reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    IF              reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    SWITCH          reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    FOR             reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    STRING          reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    INTEGER         reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    FLOAT32         reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    FLOAT64         reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    BOOLEAN         reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    BREAK           reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    $end            reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    RKEY            reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    CASE            reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)
    DEFAULT         reduce using rule 120 (def_function -> FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY .)


state 250

    (26) if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program . RKEY
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 254
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    sentencia                      shift and go to state 38
    loop                           shift and go to state 39
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    value                          shift and go to state 20
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 251

    (28) if_statement -> IF value LKEY program RKEY ELSE LKEY program . RKEY
    (7) program -> program . sentencia
    (8) program -> program . loop
    (10) sentencia -> . print
    (11) sentencia -> . print_withoutvalue
    (12) sentencia -> . def_function
    (13) sentencia -> . call_function
    (14) sentencia -> . input
    (15) sentencia -> . assignment
    (16) sentencia -> . short_assignment
    (17) sentencia -> . arithmetic_operation
    (18) sentencia -> . direct_arithmetic_operation
    (19) sentencia -> . if_statement
    (20) sentencia -> . function_call
    (21) sentencia -> . switch_statement
    (9) loop -> . for
    (64) print -> . FMT_LIBRARY DOT PRINTLN LPAREN data RPAREN
    (65) print -> . FMT_LIBRARY DOT PRINTF LPAREN value RPAREN
    (66) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA RPAREN
    (67) print -> . FMT_LIBRARY DOT PRINTF LPAREN value COMMA data RPAREN
    (72) print_withoutvalue -> . FMT_LIBRARY DOT PRINTLN LPAREN RPAREN
    (73) print_withoutvalue -> . FMT_LIBRARY DOT PRINTF LPAREN RPAREN
    (120) def_function -> . FUNC IDENTIFIER LPAREN parameters RPAREN LKEY program RKEY
    (121) call_function -> . IDENTIFIER LPAREN values RPAREN
    (138) input -> . INPUT LPAREN RPAREN
    (139) input -> . INPUT LPAREN value RPAREN
    (140) input -> . INPUT LPAREN identifiers RPAREN
    (74) assignment -> . VAR IDENTIFIER data_type EQUAL usable_value
    (75) assignment -> . CONST IDENTIFIER data_type EQUAL usable_value
    (76) short_assignment -> . IDENTIFIER SHORT_VAR_DECL usable_value
    (92) arithmetic_operation -> . usable_value PLUS usable_value
    (93) arithmetic_operation -> . usable_value MINUS usable_value
    (94) arithmetic_operation -> . usable_value DIVIDE usable_value
    (95) arithmetic_operation -> . usable_value TIMES usable_value
    (96) arithmetic_operation -> . usable_value ENTERE_DIVIDE usable_value
    (97) arithmetic_operation -> . usable_value MODULE usable_value
    (82) direct_arithmetic_operation -> . IDENTIFIER PLUS_EQ value
    (83) direct_arithmetic_operation -> . IDENTIFIER MINUS_EQ value
    (84) direct_arithmetic_operation -> . IDENTIFIER TIMES_EQ value
    (85) direct_arithmetic_operation -> . IDENTIFIER DIVIDE_EQ value
    (86) direct_arithmetic_operation -> . IDENTIFIER MODULO_EQ value
    (87) direct_arithmetic_operation -> . IDENTIFIER BITWISE_AND_EQ value
    (88) direct_arithmetic_operation -> . IDENTIFIER BITWISE_OR_EQ value
    (89) direct_arithmetic_operation -> . IDENTIFIER BITWISE_XOR_EQ value
    (90) direct_arithmetic_operation -> . IDENTIFIER LEFT_SHIFT_EQ value
    (91) direct_arithmetic_operation -> . IDENTIFIER RIGHT_SHIFT_EQ value
    (25) if_statement -> . IF rule_comparation LKEY program RKEY
    (26) if_statement -> . IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY
    (27) if_statement -> . IF value LKEY program RKEY
    (28) if_statement -> . IF value LKEY program RKEY ELSE LKEY program RKEY
    (24) function_call -> . IDENTIFIER LPAREN values RPAREN
    (29) switch_statement -> . SWITCH expression LKEY case_clauses RKEY
    (30) switch_statement -> . SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY
    (22) for -> . FOR LKEY loop_program RKEY
    (23) for -> . FOR comparation_operation LKEY loop_program RKEY
    (77) usable_value -> . value
    (78) usable_value -> . call_function
    (79) usable_value -> . IDENTIFIER
    (80) usable_value -> . arithmetic_operation
    (81) usable_value -> . comparation_operation
    (127) value -> . STRING
    (128) value -> . INTEGER
    (129) value -> . FLOAT32
    (130) value -> . FLOAT64
    (131) value -> . BOOLEAN
    (132) value -> . IDENTIFIER
    (98) comparation_operation -> . usable_value EQUALEQUAL usable_value
    (99) comparation_operation -> . usable_value NOT_EQUAL usable_value
    (100) comparation_operation -> . usable_value LESS_EQUAL usable_value
    (101) comparation_operation -> . usable_value GREATER_EQUAL usable_value
    (102) comparation_operation -> . usable_value LESS usable_value
    (103) comparation_operation -> . usable_value GREATER usable_value
    (104) comparation_operation -> . usable_value LOGICAL_AND usable_value
    (105) comparation_operation -> . usable_value LOGICAL_OR usable_value

    RKEY            shift and go to state 255
    FMT_LIBRARY     shift and go to state 19
    FUNC            shift and go to state 21
    IDENTIFIER      shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 24
    CONST           shift and go to state 26
    IF              shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 29
    STRING          shift and go to state 31
    INTEGER         shift and go to state 32
    FLOAT32         shift and go to state 33
    FLOAT64         shift and go to state 34
    BOOLEAN         shift and go to state 35

    value                          shift and go to state 20
    sentencia                      shift and go to state 38
    loop                           shift and go to state 39
    print                          shift and go to state 6
    print_withoutvalue             shift and go to state 7
    def_function                   shift and go to state 8
    call_function                  shift and go to state 9
    input                          shift and go to state 10
    assignment                     shift and go to state 11
    short_assignment               shift and go to state 12
    arithmetic_operation           shift and go to state 13
    direct_arithmetic_operation    shift and go to state 14
    if_statement                   shift and go to state 15
    function_call                  shift and go to state 16
    switch_statement               shift and go to state 17
    for                            shift and go to state 18
    usable_value                   shift and go to state 25
    comparation_operation          shift and go to state 30

state 252

    (30) switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .

    FMT_LIBRARY     reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    FUNC            reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    IDENTIFIER      reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    INPUT           reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    VAR             reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    CONST           reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    IF              reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    SWITCH          reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    FOR             reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    STRING          reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    INTEGER         reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    FLOAT32         reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    FLOAT64         reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    BOOLEAN         reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    BREAK           reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    $end            reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    RKEY            reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    CASE            reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)
    DEFAULT         reduce using rule 30 (switch_statement -> SWITCH expression LKEY case_clauses DEFAULT COLON statements RKEY .)


state 253

    (34) statements -> statement statements .

    RKEY            reduce using rule 34 (statements -> statement statements .)
    CASE            reduce using rule 34 (statements -> statement statements .)
    DEFAULT         reduce using rule 34 (statements -> statement statements .)


state 254

    (26) if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .

    FMT_LIBRARY     reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    FUNC            reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    IDENTIFIER      reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    INPUT           reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    VAR             reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    CONST           reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    IF              reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    SWITCH          reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    FOR             reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    STRING          reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    INTEGER         reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    FLOAT32         reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    FLOAT64         reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    BOOLEAN         reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    BREAK           reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    $end            reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    RKEY            reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    CASE            reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)
    DEFAULT         reduce using rule 26 (if_statement -> IF rule_comparation LKEY program RKEY ELSE LKEY program RKEY .)


state 255

    (28) if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .

    FMT_LIBRARY     reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    FUNC            reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    IDENTIFIER      reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    INPUT           reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    VAR             reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    CONST           reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    IF              reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    SWITCH          reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    FOR             reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    STRING          reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    INTEGER         reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    FLOAT32         reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    FLOAT64         reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    BOOLEAN         reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    BREAK           reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    $end            reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    RKEY            reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    CASE            reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)
    DEFAULT         reduce using rule 28 (if_statement -> IF value LKEY program RKEY ELSE LKEY program RKEY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FMT_LIBRARY in state 2 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 2 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 2 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 2 resolved as shift
WARNING: shift/reduce conflict for VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for CONST in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for STRING in state 2 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT32 in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT64 in state 2 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 2 resolved as shift
WARNING: shift/reduce conflict for FMT_LIBRARY in state 36 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 36 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 36 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 36 resolved as shift
WARNING: shift/reduce conflict for VAR in state 36 resolved as shift
WARNING: shift/reduce conflict for CONST in state 36 resolved as shift
WARNING: shift/reduce conflict for IF in state 36 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 36 resolved as shift
WARNING: shift/reduce conflict for FOR in state 36 resolved as shift
WARNING: shift/reduce conflict for STRING in state 36 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 36 resolved as shift
WARNING: shift/reduce conflict for FLOAT32 in state 36 resolved as shift
WARNING: shift/reduce conflict for FLOAT64 in state 36 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 36 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 109 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 110 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 110 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 110 resolved as shift
WARNING: shift/reduce conflict for LESS in state 110 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 110 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 110 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 111 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 111 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 111 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 111 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 111 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 111 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 111 resolved as shift
WARNING: shift/reduce conflict for LESS in state 111 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 111 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 111 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 111 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 112 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 112 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 112 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 112 resolved as shift
WARNING: shift/reduce conflict for LESS in state 112 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 112 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 112 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 112 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 113 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 113 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for LESS in state 113 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 113 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 113 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 114 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 114 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for LESS in state 114 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 114 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 114 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 114 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 115 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 115 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 115 resolved as shift
WARNING: shift/reduce conflict for LESS in state 115 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 115 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 115 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 115 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 116 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 116 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for LESS in state 116 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 116 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 116 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 117 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 117 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 117 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 117 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 117 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 117 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 118 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 118 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 118 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 118 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for LESS in state 118 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 118 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 118 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 118 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 119 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 119 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 119 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 119 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 119 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 119 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 119 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 119 resolved as shift
WARNING: shift/reduce conflict for LESS in state 119 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 119 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 119 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 119 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 120 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 120 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 120 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 120 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 120 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for LESS in state 120 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 120 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 120 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 121 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 121 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 121 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 121 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 121 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 121 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 121 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 121 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 121 resolved as shift
WARNING: shift/reduce conflict for LESS in state 121 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 121 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 121 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 121 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 122 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 122 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 122 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 122 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 122 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 122 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 122 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 122 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 122 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 122 resolved as shift
WARNING: shift/reduce conflict for LESS in state 122 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 122 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 122 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 122 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 177 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 177 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 177 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 177 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 177 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 177 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for LESS in state 177 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 177 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 177 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 177 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 178 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 178 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 178 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 178 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 178 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 178 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 178 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 178 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 178 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 178 resolved as shift
WARNING: shift/reduce conflict for LESS in state 178 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 178 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 178 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 178 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 179 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 179 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 179 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 179 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 179 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 179 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 179 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 179 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 179 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 179 resolved as shift
WARNING: shift/reduce conflict for LESS in state 179 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 179 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 179 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 179 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 180 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 180 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 180 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 180 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 180 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 180 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for LESS in state 180 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 180 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 180 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 180 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 181 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 181 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 181 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 181 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 181 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 181 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 181 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 181 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 181 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 181 resolved as shift
WARNING: shift/reduce conflict for LESS in state 181 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 181 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 181 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 181 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 182 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 182 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 182 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 182 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 182 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 182 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 182 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 182 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 182 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 182 resolved as shift
WARNING: shift/reduce conflict for LESS in state 182 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 182 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 182 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 182 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 183 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 183 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 183 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 183 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 183 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 183 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for LESS in state 183 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 183 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 183 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 183 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 184 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 184 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 184 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 184 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 184 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 184 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 184 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 184 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 184 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 184 resolved as shift
WARNING: shift/reduce conflict for LESS in state 184 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 184 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 184 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 184 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 185 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 185 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 185 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 185 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 185 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 185 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 185 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 185 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 185 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 185 resolved as shift
WARNING: shift/reduce conflict for LESS in state 185 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 185 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 185 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 185 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 186 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 186 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 186 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 186 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 186 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 186 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for LESS in state 186 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 186 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 186 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 186 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 187 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 187 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 187 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 187 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 187 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 187 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 187 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 187 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 187 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 187 resolved as shift
WARNING: shift/reduce conflict for LESS in state 187 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 187 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 187 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 187 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 188 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 188 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 188 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 188 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 188 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 188 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for LESS in state 188 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 188 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 188 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 188 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 189 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 189 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 189 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 189 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 189 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 189 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 189 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 189 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 189 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 189 resolved as shift
WARNING: shift/reduce conflict for LESS in state 189 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 189 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 189 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 189 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 190 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 190 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 190 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 190 resolved as shift
WARNING: shift/reduce conflict for ENTERE_DIVIDE in state 190 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 190 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 190 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 190 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 190 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 190 resolved as shift
WARNING: shift/reduce conflict for LESS in state 190 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 190 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 190 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 190 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 204 resolved as shift
WARNING: shift/reduce conflict for FMT_LIBRARY in state 234 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 234 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 234 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 234 resolved as shift
WARNING: shift/reduce conflict for VAR in state 234 resolved as shift
WARNING: shift/reduce conflict for CONST in state 234 resolved as shift
WARNING: shift/reduce conflict for IF in state 234 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 234 resolved as shift
WARNING: shift/reduce conflict for STRING in state 234 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 234 resolved as shift
WARNING: shift/reduce conflict for FLOAT32 in state 234 resolved as shift
WARNING: shift/reduce conflict for FLOAT64 in state 234 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 234 resolved as shift
WARNING: reduce/reduce conflict in state 22 resolved using rule (usable_value -> IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 22
WARNING: reduce/reduce conflict in state 81 resolved using rule (usable_value -> IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 81
WARNING: reduce/reduce conflict in state 102 resolved using rule (identifiers -> IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 102
WARNING: reduce/reduce conflict in state 157 resolved using rule (function_call -> IDENTIFIER LPAREN values RPAREN)
WARNING: rejected rule (call_function -> IDENTIFIER LPAREN values RPAREN) in state 157
WARNING: reduce/reduce conflict in state 197 resolved using rule (data -> IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 197
WARNING: reduce/reduce conflict in state 227 resolved using rule (data -> data COMMA IDENTIFIER)
WARNING: rejected rule (value -> IDENTIFIER) in state 227
WARNING: reduce/reduce conflict in state 234 resolved using rule (statements -> <empty>)
WARNING: rejected rule (statement -> statement) in state 234
WARNING: Rule (statement -> statement) is never reduced
